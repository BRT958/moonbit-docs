# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit Document
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: MoonBit Document \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-12-18 11:20+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/docs.md:1
msgid "Documentation"
msgstr "文档"

#: ../../language/docs.md:3
msgid "Doc Comments"
msgstr "文档注释"

#: ../../language/docs.md:5
msgid ""
"Doc comments are comments prefix with `///` in each line in the leading "
"of toplevel structure like `fn`,`let`,`enum`,`struct`,`type`. The doc "
"comments contains a markdown text and several pragmas."
msgstr ""
"文档注释是在顶层结构（如 `fn`、`let`、`enum`、`struct`、`type`）的每一行前面加上 `///` 的注释。文档注释包含一个 "
"markdown 文本和几个注解。"

#: ../../language/docs.md:7
msgid ""
"/// Return a new array with reversed elements.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"
msgstr ""
"/// 返回一个新数组，其中元素被反转。\n"
"///\n"
"/// # 示例\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"

#: ../../language/docs.md:13
msgid "Pragmas"
msgstr "注解"

#: ../../language/docs.md:15
msgid ""
"Pragmas are annotations inside doc comments. They all take the form `/// "
"@word ...`. The _word_ indicates the type of pragma and is followed "
"optionally by several _word_ or string literals. Pragmas do not normally "
"affect the meaning of programs. Unrecognized pragmas will be reported as "
"warnings."
msgstr ""
"注解是文档注释中的标记。它们都采用 `/// @word ...` 的形式。_word_ 表示注解的类型，后面可以跟几个 _word_ 或字符串文字。注解通常不会影响程序的含义。未识别的注解将被报告为警告。"

#: ../../language/docs.md:17
msgid "Alert Pragmas"
msgstr "警告注解"

#: ../../language/docs.md:19
msgid ""
"Alert pragmas in doc comments of functions will be reported when those "
"functions are referenced. This mechanism is a generalized way to mark "
"functions as `deprecated` or `unsafe`."
msgstr ""
"函数文档注释中的警告注解将在引用这些函数时报告。这种机制是一种通用的方法，用于将函数标记为 `deprecated` 或 `unsafe`。"

#: ../../language/docs.md:21
msgid "It takes the form `@alert category \"alert message...\"`."
msgstr ""
"它采用 `@alert category \"alert message...\"` 的形式。"

#: ../../language/docs.md:23
msgid ""
"The category can be an arbitrary identifier. It allows configuration to "
"decide which alerts are enabled or turned into errors."
msgstr ""
"类别可以是任意标识符。它允许配置决定哪些警告是启用的或转换为错误。"

#: ../../language/docs.md:26
msgid ""
"/// @alert deprecated \"Use foo2 instead\"\n"
"pub fn foo() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"/// @alert unsafe \"Div will cause an error when y is zero\"\n"
"pub fn div(x : Int, y : Int) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"test {\n"
"  // Warning (Alert deprecated): Use foo2 instead\n"
"  foo()\n"
"  // Warning (Alert unsafe): Div will cause an error when y is zero\n"
"  div(1, 2) |> ignore\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:1
msgid "Error handling"
msgstr "错误处理"

#: ../../language/error-handling.md:3
msgid ""
"Error handling has always been at core of our language design. In the "
"following we'll be explaining how error handling is done in MoonBit. We "
"assume you have some prior knowledge of MoonBit, if not, please checkout "
"[A tour of MoonBit](../tutorial/tour.md)."
msgstr ""
"错误处理一直是我们语言设计的核心。接下来我们将解释 MoonBit 中的错误处理。我们假设您对 MoonBit 有一些了解，如果没有，请查看 "
"[MoonBit 之旅](../tutorial/tour.md)。"

#: ../../language/error-handling.md:7
msgid "Error types"
msgstr "错误类型"

#: ../../language/error-handling.md:9
msgid ""
"The error values used in MoonBit must have an error type. An error type "
"can be defined in the following forms:"
msgstr ""
"MoonBit 中使用的错误值必须具有错误类型。错误类型可以用以下形式定义："

#: ../../language/error-handling.md:12
msgid ""
"type! E1 Int // error type E1 has one constructor E1 with an Int payload\n"
"\n"
"type! E2  // error type E2 has one constructor E2 with no payload\n"
"\n"
"type! E3 { // error type E3 has three constructors like a normal enum "
"type\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"
msgstr ""
"type! E1 Int  // 错误类型 E1 具有一个构造函数 E1，并带有一个 Int 负载\n"
"type! E2      // 错误类型 E2 具有一个没有负载的构造函数 E2\n"
"type! E3 {    // 错误类型 E3 类似于普通的枚举类型，有三个构造函数\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"

#: ../../language/error-handling.md:19
msgid ""
"The return type of a function can include an error type to indicate that "
"the function might return an error. For example, the following function "
"`div` might return an error of type `DivError`:"
msgstr ""
"函数的返回类型可以包含错误类型，以表明函数可能返回一个错误。例如，以下函数 `div` 可能返回一个类型为 `DivError` 的错误："

#: ../../language/error-handling.md:23
msgid ""
"type! DivError String\n"
"\n"
"fn div(x : Int, y : Int) -> Int!DivError {\n"
"  if y == 0 {\n"
"    raise DivError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:30
msgid ""
"Here, the keyword `raise` is used to interrupt the function execution and"
" return an error."
msgstr ""
"这里使用了关键字 `raise` 来中断函数执行并返回一个错误。"

#: ../../language/error-handling.md:33
msgid "The Default Error Type"
msgstr "默认错误类型"

#: ../../language/error-handling.md:35
msgid ""
"MoonBit provides a default error type `Error` that can be used when the "
"concrete error type is not important. For convenience, you can annotate "
"the function name or the return type with the suffix `!` to indicate that"
" the `Error` type is used. For example, the following function signatures"
" are equivalent:"
msgstr ""
"MoonBit 提供了一个默认错误类型 `Error`，当具体的错误类型不重要时可以使用它。为了方便起见，您可以在函数名或返回类型后面加上后缀 `!`，"
"以表示使用了 `Error` 类型。例如，以下函数签名是等价的："

#: ../../language/error-handling.md:40
msgid ""
"fn f() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"fn g!() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn h() -> Unit!Error {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:47
msgid ""
"For anonymous function and matrix function, you can annotate the keyword "
"`fn` with the `!` suffix to achieve that. For example,"
msgstr ""
"对于匿名函数和矩阵函数，您可以在关键字 `fn` 后面加上 `!` 后缀来实现这一点。例如："

#: ../../language/error-handling.md:50
msgid ""
"type! IntError Int\n"
"\n"
"fn h(f : (Int) -> Int!, x : Int) -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn g() -> Unit {\n"
"  let _ = h(fn! { x => raise IntError(x) }, 0)\n"
"  let _ = h(fn!(x) { raise IntError(x) }, 0)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:56
msgid ""
"As shown in the above example, the error types defined by `type!` can be "
"used as value of the type `Error` when the error is raised."
msgstr ""
"如上例所示，`type!` 定义的错误类型可以在引发错误时作为 `Error` 类型的值使用。"

#: ../../language/error-handling.md:59
msgid ""
"Note that only error types or the type `Error` can be used as errors. For"
" functions that are generic in the error type, you can use the `Error` "
"bound to do that. For example,"
msgstr ""
"请注意，只有错误类型或 `Error` 类型可以用作错误。对于在错误类型上是泛型的函数，您可以使用 `Error` 约束来实现。例如："

#: ../../language/error-handling.md:63
msgid ""
"// Result::unwrap_or_error\n"
"fn unwrap_or_error[T, E : Error](result : Result[T, E]) -> T!E {\n"
"  match result {\n"
"    Ok(x) => x\n"
"    Err(e) => raise e\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:69
msgid ""
"Since the type `Error` can include multiple error types, pattern matching"
" on the `Error` type must use the wildcard `_` to match all error types. "
"For example,"
msgstr ""
"由于 `Error` 类型可以包含多个错误类型，对 `Error` 类型进行模式匹配必须使用通配符 `_` 来匹配所有错误类型。例如："

#: ../../language/error-handling.md:72
msgid ""
"type! E4\n"
"\n"
"type! E5\n"
"\n"
"fn f(e : Error) -> Unit {\n"
"  match e {\n"
"    E4 => println(\"E1\")\n"
"    E5 => println(\"E2\")\n"
"    _ => println(\"unknown error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:78
msgid "Handling Errors"
msgstr "处理错误"

#: ../../language/error-handling.md:80
msgid "There are three ways to handle errors:"
msgstr "有三种方式可以处理错误："

#: ../../language/error-handling.md:82
msgid ""
"Append `!` after the function name in a function application to rethrow "
"the error directly in case of an error, for example:"
msgstr ""
"在函数应用中的函数名后面附加 `!`，以便在出现错误时直接重新抛出错误，例如："

#: ../../language/error-handling.md:85
msgid ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // Rethrow the error if `div` raised an error\n"
"}\n"
msgstr ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // 如果 `div` 引发错误，则重新抛出错误\n"
"}\n"

#: ../../language/error-handling.md:91
msgid ""
"Append `?` after the function name to convert the result into a first-"
"class value of the `Result` type, for example:"
msgstr ""
"在函数名后面附加 `?`，将结果转换为 `Result` 类型的值，例如："

#: ../../language/error-handling.md:94
msgid ""
"test {\n"
"  let res = div?(6, 3)\n"
"  inspect!(res, content=\"Ok(2)\")\n"
"  let res = div?(6, 0)\n"
"  inspect!(\n"
"    res,\n"
"    content=\n"
"      #|Err(\"division by zero\")\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:100
msgid "Use `try` and `catch` to catch and handle errors, for example:"
msgstr ""

#: ../../language/error-handling.md:102
msgid ""
"fn main {\n"
"try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  DivError(s) => println(s)\n"
"} else {\n"
"  v => println(v)\n"
"}\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:111 ../../language/fundamentals.md:115
#: ../../language/fundamentals.md:147 ../../language/fundamentals.md:174
#: ../../language/fundamentals.md:198 ../../language/fundamentals.md:590
#: ../../language/fundamentals.md:604 ../../language/fundamentals.md:618
#: ../../language/fundamentals.md:632 ../../language/fundamentals.md:644
#: ../../language/fundamentals.md:661 ../../language/fundamentals.md:699
#: ../../language/fundamentals.md:746 ../../language/fundamentals.md:760
#: ../../language/fundamentals.md:883 ../../language/fundamentals.md:919
#: ../../language/fundamentals.md:950 ../../language/fundamentals.md:977
#: ../../language/fundamentals.md:1006 ../../language/fundamentals.md:1026
#: ../../language/fundamentals.md:1060 ../../language/fundamentals.md:1074
#: ../../language/methods.md:91
msgid "Output"
msgstr "输出"

#: ../../language/error-handling.md:111
msgid "division by zero\n"
msgstr "除零"

#: ../../language/error-handling.md:115
msgid ""
"Here, `try` is used to call a function that might throw an error, and "
"`catch` is used to match and handle the caught error. If no error is "
"caught, the catch block will not be executed and the `else` block will be"
" executed instead."
msgstr ""
"这里，`try` 用于调用可能引发错误的函数，`catch` 用于匹配和处理捕获的错误。如果没有捕获到错误，`catch` 块将不会执行，而是执行 `else` 块。"

#: ../../language/error-handling.md:119
msgid ""
"The `else` block can be omitted if no action is needed when no error is "
"caught. For example:"
msgstr ""
"如果不需要在没有捕获到错误时执行任何操作，则可以省略 `else` 块。例如："

#: ../../language/error-handling.md:122
msgid ""
"try {\n"
"  println(div!(42, 0))\n"
"} catch {\n"
"  _ => println(\"Error\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:129
msgid ""
"The `catch` keyword is optional, and when the body of `try` is a simple "
"expression, the curly braces can be omitted. For example:"
msgstr ""
"`catch` 关键字是可选的，当 `try` 的主体是一个简单表达式时，大括号可以省略。例如："

#: ../../language/error-handling.md:132
msgid ""
"let a = try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  _ => 0\n"
"}\n"
"println(a)\n"
msgstr ""

#: ../../language/error-handling.md:139
msgid ""
"The `!` and `?` attributes can also be used on method invocation and pipe"
" operator. For example:"
msgstr ""
"`!` 和 `?` 符号也可以用于方法调用和管道运算符。例如："

#: ../../language/error-handling.md:142
msgid ""
"type T Int\n"
"\n"
"type! E Int derive(Show)\n"
"\n"
"fn k(self : T) -> Unit!E {\n"
"  ...\n"
"}\n"
"\n"
"fn l() -> Unit!E {\n"
"  let x = T(42)\n"
"  k!(x)\n"
"  x.k!()\n"
"  x |> k!()\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:148
msgid ""
"However for infix operators such as `+` `*` that may raise an error, the "
"original form has to be used, e.g. `x.op_add!(y)`, `x.op_mul!(y)`."
msgstr ""
"然而对于可能引发错误的中缀运算符，如 `+` `*`，必须使用原始形式，例如 `x.op_add!(y)`，`x.op_mul!(y)`。"

#: ../../language/error-handling.md:151
msgid ""
"Additionally, if the return type of a function includes an error type, "
"the function call must use `!` or `?` for error handling, otherwise the "
"compiler will report an error."
msgstr ""
"此外，如果函数的返回类型包含错误类型，则函数调用必须使用 `!` 或 `?` 进行错误处理，否则编译器将报告错误。"

#: ../../language/error-handling.md:155
msgid "Error Inference"
msgstr "错误推导"

#: ../../language/error-handling.md:157
msgid ""
"Within a `try` block, several different kinds of errors can be raised. "
"When that happens, the compiler will use the type `Error` as the common "
"error type. Accordingly, the handler must use the wildcard `_` to make "
"sure all errors are caught. For example,"
msgstr ""
"在 `try` 块中，可能引发多种不同类型的错误。当发生这种情况时，编译器将使用 `Error` 类型作为通用错误类型。因此，处理程序必须使用通配符 `_` "
"来确保捕获所有错误。例如："

#: ../../language/error-handling.md:162
msgid ""
"fn f1() -> Unit!E1 {\n"
"  ...\n"
"}\n"
"\n"
"fn f2() -> Unit!E2 {\n"
"  ...\n"
"}\n"
"\n"
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch {\n"
"  E1(_) => ...\n"
"  E2 => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:169
msgid ""
"You can also use `catch!` to rethrow the uncaught errors for convenience."
" This is useful when you only want to handle a specific error and rethrow"
" others. For example,"
msgstr ""
"您还可以使用 `catch!` 来重新抛出未捕获的错误，以方便处理。当您只想处理特定错误并重新抛出其他错误时，这很有用。例如："

#: ../../language/error-handling.md:173
msgid ""
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch! {\n"
"  E1(_) => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:180
msgid "Example: Division by Zero"
msgstr "示例：除零"

#: ../../language/error-handling.md:182
msgid ""
"We'll write a small example to demonstrate the basics of MoonBit's error "
"handling system. Consider the following `div` function which'll raise an "
"error on division by zero:"
msgstr "我们将编写一个小例子来演示 MoonBit 错误处理系统的基础知识。考虑以下 `div` 函数，它将在除零时引发错误："

#: ../../language/error-handling.md:186
msgid ""
"type! DivisionByZeroError String\n"
"fn div(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  if y == 0 {\n"
"    raise DivisionByZeroError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:196
msgid ""
"In before, we would typically use `type` to define a wrapper type which "
"wraps around some existing foreign type. Here however, we append `type` "
"with `!` to define a error type `DivisionByZeroError` which wraps around "
"`String`."
msgstr ""
"在以前，我们通常使用 `type` 来定义一个包装器类型，该类型包装了某些现有的外部类型。然而，在这里，我们使用 `!` 将 `type` 附加到"
" `DivisionByZeroError`，以定义一个错误类型，该类型包装了 `String`。"

#: ../../language/error-handling.md:200
msgid "`type! E S` construct a error type `E` from `S`"
msgstr "`type! E S` 从 `S` 构造一个错误类型 `E`"

#: ../../language/error-handling.md:202
msgid ""
"Just like `type`, `type!` may have a payload like the above "
"`DivisionByZeroError`, or may not, or may even have multiple constructors"
" like a normal `enum`:"
msgstr ""
"就像 `type` 一样，`type!` 可能有一个像上面的 `DivisionByZeroError` 那样的数据，也可能没有，甚至可能像普通的"
" `enum` 一样有多个构造器："

#: ../../language/error-handling.md:204
msgid ""
"type! ConnectionError {\n"
"  BrokenPipe(Int,String)\n"
"  ConnectionReset\n"
"  ConnectionAbort\n"
"  ConnectionRefused\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:213
msgid ""
"To utilize `DivisionByZeroError` type, we would usually define a function"
" which may raise error by denoting its return type like `T ! E` in the "
"signature, with `T` being the actual return type and `E` being the error "
"type. In this case, it's `Int!DivisionByZeroError`. The error can be "
"thrown using `raise e` where `e` is an instance of `E` which can be "
"constructed using the default constructor of `S`."
msgstr ""
"要使用 `DivisionByZeroError` 类型，我们通常会定义一个函数，该函数通过在签名中定义返回类型为 `T ! E` "
"来表示它会引发错误，其中 `T` 是实际的返回类型，`E` 是错误类型。在这个例子中，它是 "
"`Int!DivisionByZeroError`。错误可以使用 `raise e` 抛出，其中 `e` 是 `E` 的实例，可以使用 `S` "
"的默认构造函数构造。"

#: ../../language/error-handling.md:220
msgid ""
"Any instance of an error is a second class object. Meaning it may only "
"appear in the return value. And if it does appear, the function signature"
" has to be adjusted to match with the return type."
msgstr "任何错误的实例都是一个二等公民对象。这意味着它只能出现在返回值中。如果返回值包含错误，函数签名必须调整以匹配返回类型。"

#: ../../language/error-handling.md:224
msgid ""
"The `test` block in MoonBit may also be seen as a function, with a return"
" type of Unit!Error."
msgstr "MoonBit 中的 `test` 块也可以看作是一个函数，返回类型为 Unit!Error。"

#: ../../language/error-handling.md:227
msgid "Calling an error-able function"
msgstr "调用一个可出错的函数"

#: ../../language/error-handling.md:229
msgid ""
"an error-able function is usually called in 2 manners: `f!(...)` and "
"`f?(...)`."
msgstr "一个可出错的函数通常有两种调用方式：`f!(...)` 和 `f?(...)`。"

#: ../../language/error-handling.md:231
msgid "As-is calling"
msgstr "直接调用"

#: ../../language/error-handling.md:233
msgid ""
"`f!(...)` calls the function directly. The possible error must be dealt "
"in the function that calls `f`. We can either re-raising it without "
"actually dealing with the error:"
msgstr "`f!(...)` 直接调用函数。可能的错误必须在调用 `f` 的函数中处理。我们可以重新抛出它，而不实际处理错误："

#: ../../language/error-handling.md:237
msgid ""
"// We have to match the error type of `div2` with `div`\n"
"fn div2(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  div!(x,y)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:244
msgid "or use `try...catch` block like in many other languages:"
msgstr "或者像其他许多语言一样使用 `try...catch` 块："

#: ../../language/error-handling.md:246
msgid ""
"fn div3(x : Int, y : Int) -> Unit {\n"
"  try {\n"
"    div!(x, y)\n"
"  } catch { // `catch` and `except` works the same.\n"
"    DivisionByZeroError(e) => println(\"inf: \\{e}\")\n"
"  } else {\n"
"    v => println(v)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:258
msgid ""
"The `catch...` clause has similar semantics like pattern matching. We can"
" unwrap the error to retrieve the underlying `String` and print it. "
"Additionally, there's an `else` clause to handle the value of `try...` "
"block."
msgstr ""
"`catch...` 子句的语义类似于模式匹配。我们可以解包错误以检索底层的 `String` 并打印它。此外，还有一个 `else` 子句来处理"
" `try...` 块的值。"

#: ../../language/error-handling.md:262
msgid ""
"fn test_try() -> Result[Int, Error] {\n"
"  // compiler can figure out the type of a local error-able function.\n"
"  fn f() -> _!_ {\n"
"    raise Failure(\"err\")\n"
"  }\n"
"\n"
"  try Ok(f!()) { err => Err(err) }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:273
msgid ""
"Curly braces may be omitted if the body of try is a one-liner "
"(expression). The `catch` keyword can also be omitted as well. In the "
"case where a `try` body would raise different errors, the special "
"`catch!` can be used to catch some of the errors, while re-raising other "
"uncaught errors:"
msgstr ""
"如果 `try` 的主体是一行代码（表达式），则大括号可以省略。`catch` 关键字也可以省略。在 `try` "
"主体可能引发不同错误的情况下，可以使用特殊的 `catch!` 来捕获一些错误，同时重新抛出其他未捕获的错误："

#: ../../language/error-handling.md:277
msgid ""
"type! E1\n"
"type! E2\n"
"fn f1() -> Unit!E1 { raise E1 }\n"
"fn f2() -> Unit!E2 { raise E2 }\n"
"fn f() -> Unit! {\n"
"  try {\n"
"    f1!()\n"
"    f2!()\n"
"  } catch! {\n"
"    E1 => println(\"E1\")\n"
"    // E2 gets re-raised.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:293
msgid "Convert to Result"
msgstr "转换为 Result"

#: ../../language/error-handling.md:295
msgid "Extracting values"
msgstr "提取值"

#: ../../language/error-handling.md:297
msgid ""
"A object of type `Result` is a first class value in MoonBit. `Result` has"
" 2 constructors: `Ok(...)` and `Err(...)` where the former accept a first"
" class object and the latter accept a error object."
msgstr ""
"`Result` 类型的对象是 MoonBit 中的一等公民。`Result` 有 2 个构造器：`Ok(...)` 和 "
"`Err(...)`，前者接受一个一等公民对象，后者接受一个错误对象。"

#: ../../language/error-handling.md:299
msgid ""
"With `f?(...)`, the return type `T!E` is turned into `Result[T,E]`. We "
"may use pattern matching to extract value from it:"
msgstr "使用 `f?(...)`，返回类型 `T!E` 被转换为 `Result[T,E]`。我们可以使用模式匹配从中提取值："

#: ../../language/error-handling.md:301
msgid ""
"let res = div?(10, 0)\n"
"match res {\n"
"  Ok(x) => println(x)\n"
"  Err(DivisionByZeroError(e)) => println(e)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:309
msgid "the `f?()` is basically a syntactic sugar for"
msgstr "`f?()` 基本上是一个语法糖，等价于"

#: ../../language/error-handling.md:311
msgid ""
"let res = try {\n"
"  Ok(div!(10, 0))\n"
"} catch {\n"
"  s => Err(s)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:319
msgid ""
"Note the difference between `T?` and `f?(...)`: `T` is a type and `T?` is"
" equivalent to `Option[T]` whereas `f?(...)` is a call to an error-able "
"function `f`."
msgstr ""
"注意 `T?` 和 `f?(...)` 之间的区别：`T` 是一个类型，`T?` 等价于 `Option[T]`，而 `f?(...)` "
"是对可出错函数 `f` 的调用。"

#: ../../language/error-handling.md:323
msgid ""
"Besides pattern matching, `Result` provides some useful methods to deal "
"with possible error:"
msgstr "除了模式匹配，`Result` 还提供了一些有用的方法来处理可能的错误："

#: ../../language/error-handling.md:325
msgid ""
"let res1: Result[Int, String] = Err(\"error\")\n"
"let value = res1.or(0) // 0\n"
"\n"
"let res2: Result[Int, String] = Ok(42)\n"
"let value = res2.unwrap() // 42\n"
msgstr ""

#: ../../language/error-handling.md:333
msgid ""
"`or` returns the value if the result is `Ok` or a default value if it is "
"`Err`"
msgstr "`or` 如果结果是 `Ok`，则返回值，如果是 `Err`，则返回默认值"

#: ../../language/error-handling.md:334
msgid "`unwrap` panics if the result is `Err` and return the value if it is `Ok`"
msgstr "`unwrap` 如果结果是 `Err`，则会崩溃，如果是 `Ok`，则返回值"

#: ../../language/error-handling.md:336
msgid "Mapping values"
msgstr "映射值"

#: ../../language/error-handling.md:338
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let new_result = res1.map(fn(x) { x + 1 }) // Ok(43)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let new_result = res2.map_err(fn(x) { x + \"!\" }) // Err(\"error!\")\n"
msgstr ""

#: ../../language/error-handling.md:346
msgid ""
"`map` applies a function to the value within, except it doesn't nothing "
"if result is `Err`."
msgstr "`map` 将函数应用于内部的值；如果结果是 `Err`，则不执行任何操作。"

#: ../../language/error-handling.md:347
msgid "`map_error` does the opposite."
msgstr "`map_error` 则相反。"

#: ../../language/error-handling.md:349
msgid ""
"Unlike some languages, MoonBit treats error-able and nullable value "
"differently. Although one might treat them analogously, as an `Err` "
"result contains no value, only the error, which is like `null`. MoonBit "
"knows that."
msgstr ""
"与一些语言不同，MoonBit 对可出错值和可空值进行了区分。尽管有些人可能将它们类比对待，因为一个不包含值的 `Err` 对象就像 "
"`null`。MoonBit 知道这一点。"

#: ../../language/error-handling.md:351
msgid "`to_option` converts a `Result` to `Option`."
msgstr "`to_option` 将 `Result` 转换为 `Option`。"

#: ../../language/error-handling.md:353
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let option = res1.to_option() // Some(42)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let option1 = res2.to_option() // None\n"
msgstr ""

#: ../../language/error-handling.md:361
msgid "Built-in error type and functions"
msgstr "内置错误类型和相关函数"

#: ../../language/error-handling.md:363
msgid "In MoonBit, `Error` is a generalized error type:"
msgstr "在 MoonBit 中，`Error` 是一个通用的错误类型："

#: ../../language/error-handling.md:365
msgid ""
"// These signatures are equivalent. They all raise Error.\n"
"fn f() -> Unit! { .. }\n"
"fn f!() -> Unit { .. }\n"
"fn f() -> Unit!Error { .. }\n"
"\n"
"fn test_error() -> Result[Int, Error] {\n"
"  fn f() -> _!_ {\n"
"    raise DivisionByZeroError(\"err\")\n"
"  }\n"
"\n"
"  try {\n"
"    Ok(f!())\n"
"  } catch {\n"
"    err => Err(err)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:384
msgid ""
"Although the constructor `Err` expects a type of `Error`, we may still "
"pass an error of type `DivisionByZeroError` to it."
msgstr "尽管构造函数 `Err` 期望一个 `Error` 类型，我们仍然可以将 `DivisionByZeroError` 类型的错误传递给它。"

#: ../../language/error-handling.md:387
msgid ""
"But `Error` can't be constructed directly. It's meant to be passed "
"around, not used directly:"
msgstr "但是 `Error` 不能直接构造。它是用来传递的，而不是直接使用："

#: ../../language/error-handling.md:389
msgid ""
"type! ArithmeticError\n"
"\n"
"fn what_error_is_this(e : Error) -> Unit {\n"
"  match e {\n"
"    DivisionByZeroError(_) => println(\"DivisionByZeroError\")\n"
"    ArithmeticError => println(\"ArithmeticError\")\n"
"    ... => println(\"...\")\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:402
msgid ""
"`Error` is typically used where concrete error type is not needed, or "
"simply act as a catch-all for all kinds of sub-errors."
msgstr "`Error` 通常用于不需要具体错误类型的情况，或者简单地用来捕获所有的子错误。"

#: ../../language/error-handling.md:405
msgid ""
"As `Error` includes multiple error types, partial matching is not allowed"
" here. We have to do exhaustive matching by providing a catch-"
"all/wildcard case `_`."
msgstr "由于 `Error` 包含多种错误类型，这里不允许部分匹配。我们必须通过提供一个通配符 `_` 来进行兜底匹配。"

#: ../../language/error-handling.md:407
msgid ""
"We usually use the builtin `Failure` error type for a generalized error, "
"and by generalized we mean using it for trivial errors that doesn't need "
"a new error type."
msgstr "我们通常使用内置的 `Failure` 错误类型来表示通用错误：通用意味着它用于不值得单独定义类型的错误。"

#: ../../language/error-handling.md:410
msgid ""
"fn div_trivial(x : Int, y : Int) -> Int!Failure {\n"
"  if y == 0 {\n"
"    raise Failure(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:419
msgid ""
"Besides using the constructor directly, the function `fail!` provides a "
"shorthand to construct a `Failure`. And if we take a look at the source "
"code:"
msgstr "除了直接使用构造函数，函数 `fail!` 提供了一个快捷方式来构造 `Failure`。如果我们查看源代码："

#: ../../language/error-handling.md:422
msgid ""
"pub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {\n"
"  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:428
msgid ""
"We can see that `fail` is merely a constructor with a pre-defined output "
"template for showing both the error and the source location. In practice,"
" `fail!` is always preferred over `Failure`."
msgstr "我们可以看到 `fail` 只是一个带有预定义输出模板的构造函数，用于显示错误和源位置。在实践中，`fail!` 总是比 `Failure`更常用。"

#: ../../language/error-handling.md:432
msgid ""
"Other functions used to break control flow are `abort` and `panic`. They "
"are equivalent. An `panic` at any place will manually crash the program "
"at that place, and prints out stack trace."
msgstr ""
"其他用于打破控制流的函数有 `abort` 和 `panic`。它们是等效的。在任何地方的 `panic` "
"都会手动在那个地方崩溃程序，并打印出堆栈跟踪。"

#: ../../language/ffi-and-wasm-host.md:1
msgid "Foreign Function Interface(FFI)"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:3
msgid ""
"What we've introduced is about describing pure computation. In reality, "
"you'll need to interact with the real world. However, the \"world\" is "
"different for each backend (C, JS, Wasm, WasmGC) and is sometimes based "
"on runtime ([Wasmtime](https://wasmtime.dev/), Deno, Browser, etc.)."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:7
msgid ""
"You can use foreign function in MoonBit through FFI to interact with the "
"hosting runtime when embedded inside the browser or command line "
"applications through [Wasmtime](https://wasmtime.dev/) or similar "
"projects."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:9
msgid "Init function"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:11
msgid ""
"For WebAssembly backend, it is compiled as [start "
"function](https://webassembly.github.io/spec/core/syntax/modules.html"
"#start-function), meaning that it will be executed **before** the "
"instance is available, and the FFIs that relies on the instance's "
"exportations can not be used at this stage; for JavaScript backend, it "
"means that it will be executed during the importation stage."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:14
msgid "Declare Foreign Reference"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:16
msgid "You can declare a foreign reference type like this:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:18
msgid "type Canvas_ctx\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:22
msgid ""
"This will be a type that represents a reference to a foreign object, a "
"`CanvasRenderingContext2D` object held by the hosting JavaScript runtime "
"in this example."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:24
msgid "Declare Foreign Function"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:26
msgid ""
"You can either import a function with module name and function name or "
"writing an inline function."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:28
msgid "Import function"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:30
msgid "You can declare a foreign function like this:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:32
msgid "fn cos(d : Double) -> Double = \"Math\" \"cos\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:36
msgid ""
"It's similar to a normal function definition except that the function "
"body is replaced with two strings."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:38
msgid ""
"For Wasm(GC) backend, these two strings are used to identify the specific"
" function from a Wasm import object, the first string is the module name,"
" and the second string is the function name."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:40
msgid ""
"For JS backend, these two strings are used to call a static function in "
"the global namespace. The example above becomes similar to `const cos = "
"(d) => Math.cos(d)`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:42
msgid "Inline function"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:44
msgid ""
"You can also declare inline functions where the function body is replaced"
" with one string."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:46
msgid ""
"For Wasm(GC) backend, you may declare it as a Wasm function without name "
"(which will be generated afterwards):"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:48
msgid ""
"extern \"wasm\" fn abs(d : Double) -> Double =\n"
"  #|(func (param f64) (result f64))\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:53
msgid "and for JS backend, you may declare it as a lambda expression:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:55
msgid ""
"extern \"js\" fn abs(d : Double) -> Double =\n"
"  #|(d) => Math.abs(d)\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:60
msgid "After declaration, you can use foreign functions like regular functions."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:62
msgid ""
"For multi-backend project, you may implement backend specific code in the"
" files that ends with `.wasm.mbt` `.wasm-gc.mbt` and `.js.mbt`. Check out"
" [link options](</toolchain/moon/package.md#link-options>) for details."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:64
msgid ""
"You may also declare a foreign function that will be invoked upon a "
"foreign object by using the foreign reference type like this:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:66
msgid "fn begin_path(self: Canvas_ctx) = \"canvas\" \"begin_path\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:70
msgid ""
"and apply it to a previously owned reference normally such as "
"`context.begin_path()`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:72
msgid "Export functions"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:74
msgid ""
"Functions that are not methods nor polymorphic functions can be exported "
"if they are public and if the link configuration appears in the "
"`moon.pkg.json` of the package:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:76
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"js\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ],\n"
"      \"format\": \"esm\"\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:93
msgid ""
"Each backend has a separate definition. For JS backend, a `format` option"
" is used to specify whether the generated JavaScript file should be "
"released as an ES Module (`esm`), a CommonJS module (`cjs`), or an "
"immediately invoked function expression (`iife`)."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:95
msgid ""
"The example above will export function `add` and `fib`, and the function "
"`fib` will be exported with the name of `test`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:97
msgid "Use compiled Wasm"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:99
msgid ""
"To use the compiled Wasm, you need to initialize the Wasm module with the"
" host functions so as to meet the needs of the foreign functions, and "
"then use the exported functions provided by the Wasm module."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:101
msgid "Provide host functions"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:103
msgid ""
"To use the compiled Wasm, you must provide **All** declared foreign "
"functions in Wasm import object."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:105
msgid "For example, to use wasm compiled from above code snippet in JavaScript:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:107
msgid ""
"WebAssembly.instantiateStreaming(fetch(\"xxx.wasm\"), {\n"
"  Math: {\n"
"    cos: (d) => Math.cos(d),\n"
"  },\n"
"});\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:115
msgid ""
"Check out the documentation such as [MDN](https://developer.mozilla.org"
"/en-US/docs/WebAssembly) or the manual of runtime that you're using to "
"embed the Wasm."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:117
msgid "Example: Smiling face"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:119
msgid ""
"Let's walk through a full example to draw a smiling face using Canvas API"
" in MoonBit. Suppose you created a new project with `moon new draw`"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:121
msgid ""
"// We first declare a type representing the context of canvas\n"
"type Canvas_ctx\n"
"\n"
"// We then declare the foreign function interfaces\n"
"fn begin_path(self : Canvas_ctx) = \"canvas\" \"beginPath\"\n"
"fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : "
"Double,\n"
"    end_angle : Double, counterclockwise : Bool) = \"canvas\" \"arc\"\n"
"fn move_to(self : Canvas_ctx, x : Int, y : Int) = \"canvas\" \"moveTo\"\n"
"fn stroke(self : Canvas_ctx) = \"canvas\" \"stroke\"\n"
"\n"
"fn get_pi() -> Double = \"math\" \"PI\"\n"
"let pi : Double = get_pi()\n"
"\n"
"// We then apply these functions to define the drawing function upon the "
"context\n"
"pub fn draw(self : Canvas_ctx) -> Unit {\n"
"  self.begin_path()\n"
"  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle\n"
"  self.move_to(110, 75)\n"
"  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)\n"
"  self.move_to(65, 65)\n"
"  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye\n"
"  self.move_to(95, 65)\n"
"  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye\n"
"  self.stroke()\n"
"}\n"
"\n"
"// We also demonstrate the `println` functionality here\n"
"pub fn display_pi() -> Unit {\n"
"  println(\"PI: \\{pi}\")\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:154
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:167
msgid ""
"Build the project using `moon build`. We recommend using Wasm with GC "
"integration whenever possible (which is the default). If the environment "
"does not support the GC feature, use the `--target wasm` option instead."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:169
msgid "We now can use it from JavaScript."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:171
msgid ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // import object for defining the FFI\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // Always call _start to initialize the environment\n"
"          obj.instance.exports._start();\n"
"          // Pass the JS object as parameter to draw the smiling face\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // Display the value of PI\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:200
msgid ""
"For import object, we need to provide all the FFI used in the previously "
"defined program: the canvas rendering API, the math API and finally, an "
"API for printing to the console used by the `println` or `print` "
"function."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:202
msgid ""
"As of the canvas rendering API and the math API, we can use the following"
" code to convert the methods of objects into function calls that accept "
"the object as the first parameter, and convert the constant properties of"
" objects into functions that returns the value:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:204
msgid ""
"function prototype_to_ffi(prototype) {\n"
"  return Object.fromEntries(\n"
"    Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"      .filter(([_key, value]) => value.value)\n"
"      .map(([key, value]) => {\n"
"        if (typeof value.value == 'function')\n"
"          return [key, Function.prototype.call.bind(value.value)]\n"
"        // TODO: it is also possible to convert properties into getters "
"and setters\n"
"        else\n"
"          return [key, () => value.value]\n"
"      })\n"
"  );\n"
"}\n"
"\n"
"const importObject = {\n"
"  canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"  math: prototype_to_ffi(Math),\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:226
msgid ""
"As of the printing service, we can provide the following closure so that "
"it buffers the bytes of string until it needs to be logged to the "
"console:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:228
msgid ""
"const [log, flush] = (() => {\n"
"  var buffer = [];\n"
"  function flush() {\n"
"    if (buffer.length > 0) {\n"
"      console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"      buffer = [];\n"
"    }\n"
"  }\n"
"  function log(ch) {\n"
"    if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"    else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"    else { buffer.push(ch); }\n"
"  }\n"
"  return [log, flush]\n"
"})();\n"
"\n"
"const importObject = {\n"
"  // ...\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"}\n"
"\n"
"// ...\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    obj.instance.exports._start();\n"
"    // ...\n"
"    flush()\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:262
msgid "Now, we put them together, so this is our final complete `index.html`:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:264
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"\n"
"<head></head>\n"
"\n"
"<body>\n"
"  <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  <script>\n"
"    function prototype_to_ffi(prototype) {\n"
"      return Object.fromEntries(\n"
"        Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"          .filter(([_key, value]) => value.value)\n"
"          .map(([key, value]) => {\n"
"            if (typeof value.value == 'function')\n"
"              return [key, Function.prototype.call.bind(value.value)]\n"
"            else\n"
"              return [key, () => value.value]\n"
"          })\n"
"      );\n"
"    }\n"
"\n"
"    const [log, flush] = (() => {\n"
"      var buffer = [];\n"
"      function flush() {\n"
"        if (buffer.length > 0) {\n"
"          console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"          buffer = [];\n"
"        }\n"
"      }\n"
"      function log(ch) {\n"
"        if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"        else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"        else { buffer.push(ch); }\n"
"      }\n"
"      return [log, flush]\n"
"    })();\n"
"\n"
"\n"
"\n"
"    const importObject = {\n"
"      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"      math: prototype_to_ffi(Math),\n"
"      spectest: {\n"
"        print_char: log\n"
"      },\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          obj.instance.exports._start();\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"          flush()\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</body>\n"
"\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:330
msgid ""
"Make sure that `draw.wasm` and `index.html` are in the same folder, then "
"start a http server at this folder. For example, using Python:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:332
msgid "python3 -m http.server 8080\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:336
msgid ""
"Goto [http://localhost:8080](http://localhost:8080) in your browser, "
"there should be a smile face on the screen and an output on the console:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:338
msgid ""
"![A smile face webpage with browser devtools "
"open](../imgs/smile_face_with_log.png)"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:338
msgid "A smile face webpage with browser devtools open"
msgstr ""

#: ../../language/fundamentals.md:1
msgid "Fundamentals"
msgstr "基础"

#: ../../language/fundamentals.md:3
msgid "Built-in Data Structures"
msgstr "内置数据结构"

#: ../../language/fundamentals.md:5
msgid "Boolean"
msgstr "布尔值"

#: ../../language/fundamentals.md:7
msgid ""
"MoonBit has a built-in boolean type, which has two values: `true` and "
"`false`. The boolean type is used in conditional expressions and control "
"structures."
msgstr "MoonBit 有一个内置的布尔类型，它有两个值：`true` 和 `false`。布尔类型用于条件表达式和控制结构。"

#: ../../language/fundamentals.md:9
msgid ""
"let a = true\n"
"let b = false\n"
"let c = a && b\n"
"let d = a || b\n"
"let e = not(a)\n"
msgstr ""

#: ../../language/fundamentals.md:16
msgid "Number"
msgstr "数字"

#: ../../language/fundamentals.md:18
msgid "MoonBit have integer type and floating point type:"
msgstr "MoonBit 有整数类型和浮点类型："

#: ../../language/fundamentals.md:9
msgid "type"
msgstr "类型"

#: ../../language/fundamentals.md:9 ../../language/fundamentals.md:115
msgid "description"
msgstr "描述"

#: ../../language/fundamentals.md:9
msgid "example"
msgstr "示例"

#: ../../language/fundamentals.md:9
msgid "`Int`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit signed integer"
msgstr "32 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`42`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit signed integer"
msgstr "64 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`1000L`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit unsigned integer"
msgstr "32 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14U`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit unsigned integer"
msgstr "64 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14UL`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Double`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit floating point, defined by IEEE754"
msgstr "64 位浮点数，由 IEEE754 定义"

#: ../../language/fundamentals.md:9
msgid "`3.14`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Float`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit floating point"
msgstr "32 位浮点数"

#: ../../language/fundamentals.md:9
msgid "`(3.14 : Float)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`BigInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "represents numeric values larger than other types"
msgstr "表示比其他类型更大的数值"

#: ../../language/fundamentals.md:9
msgid "`10000000000000000000000N`"
msgstr ""

#: ../../language/fundamentals.md:30
msgid ""
"MoonBit also supports numeric literals, including decimal, binary, octal,"
" and hexadecimal numbers."
msgstr "MoonBit 还支持数字字面量，包括十进制、二进制、八进制和十六进制数字。"

#: ../../language/fundamentals.md:32
msgid ""
"To improve readability, you may place underscores in the middle of "
"numeric literals such as `1_000_000`. Note that underscores can be placed"
" anywhere within a number, not just every three digits."
msgstr "为了提高可读性，您可以在数字字面量中间放置下划线，例如 `1_000_000`。请注意，下划线可以放在数字中的任何位置，而不仅仅是每三位数字。"

#: ../../language/fundamentals.md:34
msgid "Decimal numbers can have underscore between the numbers."
msgstr "十进制数之间可以有下划线。"

#: ../../language/fundamentals.md:36
msgid ""
"By default, an int literal is signed 32-bit number. For unsigned numbers,"
" a postfix `U` is needed; for 64-bit numbers, a postfix `L` is needed."
msgstr "默认情况下，整数字面量是有符号的 32 位数字。对于无符号数字，需要后缀 `U`；对于 64 位数字，需要后缀 `L`。"

#: ../../language/fundamentals.md:38
msgid ""
"let a = 1234\n"
"let b : Int = 1_000_000 + a\n"
"let unsigned_num       : UInt   = 4_294_967_295U\n"
"let large_num          : Int64  = 9_223_372_036_854_775_807L\n"
"let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL\n"
msgstr ""

#: ../../language/fundamentals.md:45
msgid ""
"A binary number has a leading zero followed by a letter \"B\", i.e. "
"`0b`/`0B`. Note that the digits after `0b`/`0B` must be `0` or `1`."
msgstr "二进制数有一个前导零，后跟字母 \"B\"，即 `0b`/`0B`。请注意，`0b`/`0B` 后的数字必须是 `0` 或 `1`。"

#: ../../language/fundamentals.md:48
msgid ""
"let bin = 0b110010\n"
"let another_bin = 0B110010\n"
msgstr ""

#: ../../language/fundamentals.md:55
msgid ""
"An octal number has a leading zero followed by a letter \"O\", i.e. "
"`0o`/`0O`. Note that the digits after `0o`/`0O` must be in the range from"
" `0` through `7`:"
msgstr ""
"八进制数有一个前导零，后跟字母 \"O\"，即 `0o`/`0O`。请注意，`0o`/`0O` 后的数字必须在 `0` 到 `7` 的范围内："

#: ../../language/fundamentals.md:58
msgid ""
"let octal = 0o1234\n"
"let another_octal = 0O1234\n"
msgstr ""

#: ../../language/fundamentals.md:65
msgid ""
"A hexadecimal number has a leading zero followed by a letter \"X\", i.e. "
"`0x`/`0X`. Note that the digits after the `0x`/`0X` must be in the range "
"`0123456789ABCDEF`."
msgstr ""
"十六进制数有一个前导零，后跟字母 \"X\"，即 `0x`/`0X`。请注意，`0x`/`0X` 后的数字必须在 `0123456789ABCDEF` 范围内。"

#: ../../language/fundamentals.md:68
msgid ""
"let hex = 0XA\n"
"let another_hex = 0xA_B_C\n"
msgstr ""

#: ../../language/fundamentals.md:75
msgid ""
"A floating-point number literal is 64-bit floating-point number. To "
"define a float, type annotation is needed."
msgstr ""
"浮点数字面量是 64 位浮点数。要定义一个浮点数，需要类型注释。"

#: ../../language/fundamentals.md:77
msgid ""
"let double = 3.14 // Double\n"
"let float : Float = 3.14\n"
"let float2 = (3.14 : Float)\n"
msgstr ""

#: ../../language/fundamentals.md:84
msgid ""
"A 64-bit floating-point number can also be defined using hexadecimal "
"format:"
msgstr ""
"64 位浮点数也可以使用十六进制格式定义："

#: ../../language/fundamentals.md:86
msgid "let hex_double = 0x1.2P3 // (1.0 + 2 / 16) * 2^(+3) == 9\n"
msgstr ""

#: ../../language/fundamentals.md:93
msgid "Overloaded literal"
msgstr ""
"重载字面量"

#: ../../language/fundamentals.md:95
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"literal, and there is no need to specify the type of number via letter "
"postfix:"
msgstr ""
"当期望的类型已知时，MoonBit 可以自动重载字面量，无需通过字母后缀指定数字的类型："

#: ../../language/fundamentals.md:97
msgid ""
"let int : Int = 42\n"
"let uint : UInt = 42\n"
"let int64 : Int64 = 42\n"
"let double : Double = 42\n"
"let float : Float = 42\n"
"let bigint : BigInt = 42\n"
msgstr ""

#: ../../language/fundamentals.md:104
msgid "String"
msgstr "字符串"

#: ../../language/fundamentals.md:106
msgid ""
"`String` holds a sequence of UTF-16 code units. You can use double quotes"
" to create a string, or use `#|` to write a multi-line string."
msgstr "`String` 包含一系列 UTF-16 码点。您可以使用双引号创建字符串，或使用 `#|` 编写多行字符串。"

#: ../../language/fundamentals.md:108
msgid ""
"let a = \"兔rabbit\"\n"
"println(a[0])\n"
"println(a[1])\n"
"let b =\n"
"  #| Hello\n"
"  #| MoonBit\\n\n"
"  #|\n"
"println(b)\n"
msgstr ""

#: ../../language/fundamentals.md:115
msgid ""
"'兔'\n"
"'r'\n"
" Hello\n"
" MoonBit\\n\n"
"\n"
msgstr ""

#: ../../language/fundamentals.md:119
msgid ""
"In double quotes string, a backslash followed by certain special "
"characters forms an escape sequence:"
msgstr ""
"在双引号字符串中，反斜杠后跟某些特殊字符形成转义序列："

#: ../../language/fundamentals.md:115
msgid "escape sequences"
msgstr "转义序列"

#: ../../language/fundamentals.md:115
msgid "`\\n`,`\\r`,`\\t`,`\\b`"
msgstr ""

#: ../../language/fundamentals.md:115
msgid "New line, Carriage return, Horizontal tab, Backspace"
msgstr "换行，回车，水平制表符，退格"

#: ../../language/fundamentals.md:115
msgid "`\\\\`"
msgstr ""

#: ../../language/fundamentals.md:115
msgid "Backslash"
msgstr "反斜杠"

#: ../../language/fundamentals.md:115
msgid "`\\x41`"
msgstr ""

#: ../../language/fundamentals.md:115
msgid "Hexadecimal escape sequence"
msgstr "十六进制转义序列"

#: ../../language/fundamentals.md:115
msgid "`\\o102`"
msgstr ""

#: ../../language/fundamentals.md:115
msgid "Octal escape sequence"
msgstr "八进制转义序列"

#: ../../language/fundamentals.md:115
msgid "`\\u5154`,`\\u{1F600}`"
msgstr ""

#: ../../language/fundamentals.md:115
msgid "Unicode escape sequence"
msgstr "Unicode 转义序列"

#: ../../language/fundamentals.md:129
msgid ""
"MoonBit supports string interpolation. It enables you to substitute "
"variables within interpolated strings. This feature simplifies the "
"process of constructing dynamic strings by directly embedding variable "
"values into the text. Variables used for string interpolation must "
"support the `to_string` method."
msgstr ""
"MoonBit 支持字符串插值。它允许您在插值字符串中替换变量。此功能通过直接将变量值嵌入文本来简化构建动态字符串的过程。用于字符串插值的变量必须支持 `to_string` 方法。"

#: ../../language/fundamentals.md:131
msgid ""
"let x = 42\n"
"println(\"The answer is \\{x}\")\n"
msgstr ""

#: ../../language/fundamentals.md:138
msgid ""
"Multi-line strings do not support interpolation by default, but you can "
"enable interpolation for a specific line by changing the leading `#|` to "
"`$|`:"
msgstr ""
"多行字符串默认不支持插值，但您可以通过将前导 `#|` 更改为 `$|` 来为特定行启用插值："

#: ../../language/fundamentals.md:140
msgid ""
"let lang = \"MoonBit\"\n"
"let str =\n"
"  #| Hello\n"
"  #| ---\n"
"  $| \\{lang}\\n\n"
"  #| ---\n"
"println(str)\n"
msgstr ""

#: ../../language/fundamentals.md:147
msgid ""
" Hello\n"
" ---\n"
" MoonBit\n"
"\n"
" ---\n"
msgstr ""

#: ../../language/fundamentals.md:151
msgid "Char"
msgstr "字符"

#: ../../language/fundamentals.md:153
msgid "`Char` represents a Unicode code point."
msgstr "`Char` 表示一个 Unicode 码点。"

#: ../../language/fundamentals.md:155
msgid ""
"let a : Char = 'A'\n"
"let b = '\\x41'\n"
"let c = '兔'\n"
"let zero = '\\u{30}'\n"
"let zero = '\\u0030'\n"
msgstr ""

#: ../../language/fundamentals.md:162
msgid "Byte(s)"
msgstr "字节"

#: ../../language/fundamentals.md:164
msgid ""
"A byte literal in MoonBit is either a single ASCII character or a single "
"escape enclosed in single quotes `'`, and preceded by the character `b`. "
"Byte literals are of type `Byte`. For example:"
msgstr ""
"MoonBit 中的字节字面量是一个 ASCII 字符或一个转义字符，用单引号 `'` 括起来，并在前面加上字符 `b`。字节字面量的类型是 `Byte`。例如："

#: ../../language/fundamentals.md:166
msgid ""
"fn main {\n"
"  let b1 : Byte = b'a'\n"
"  println(b1.to_int())\n"
"  let b2 = b'\\xff'\n"
"  println(b2.to_int())\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:174
msgid ""
"97\n"
"255\n"
msgstr ""

#: ../../language/fundamentals.md:178
msgid ""
"A `Bytes` is a sequence of bytes. Similar to byte, bytes literals have "
"the form of `b\"...\"`. For example:"
msgstr ""
"`Bytes` 是一系列字节。与字节类似，字节字面量的形式是 `b\"...\"`。例如："

#: ../../language/fundamentals.md:180
msgid ""
"test {\n"
"  let b1 : Bytes = b\"abcd\"\n"
"  let b2 = b\"\\x61\\x62\\x63\\x64\"\n"
"  assert_eq!(b1, b2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:186
msgid "Tuple"
msgstr "元组"

#: ../../language/fundamentals.md:188
msgid ""
"A tuple is a collection of finite values constructed using round brackets"
" `()` with the elements separated by commas `,`. The order of elements "
"matters; for example, `(1,true)` and `(true,1)` have different types. "
"Here's an example:"
msgstr ""
"元组是使用圆括号 `()` 构造的有限值集合，元素之间用逗号 `,` 分隔。元素的顺序很重要；例如，`(1,true)` 和 `(true,1)` 有不同的类型。以下是一个示例："

#: ../../language/fundamentals.md:190
msgid ""
"fn main {\n"
"  fn pack(\n"
"    a : Bool,\n"
"    b : Int,\n"
"    c : String,\n"
"    d : Double\n"
"  ) -> (Bool, Int, String, Double) {\n"
"    (a, b, c, d)\n"
"  }\n"
"\n"
"  let quad = pack(false, 100, \"text\", 3.14)\n"
"  let (bool_val, int_val, str, float_val) = quad\n"
"  println(\"\\{bool_val} \\{int_val} \\{str} \\{float_val}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:198
msgid "false 100 text 3.14\n"
msgstr ""

#: ../../language/fundamentals.md:202
msgid "Tuples can be accessed via pattern matching or index:"
msgstr "元组可以通过模式匹配或索引访问："

#: ../../language/fundamentals.md:204
msgid ""
"test {\n"
"  let t = (1, 2)\n"
"  let (x1, y1) = t\n"
"  let x2 = t.0\n"
"  let y2 = t.1\n"
"  assert_eq!(x1, x2)\n"
"  assert_eq!(y1, y2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:210
msgid "Ref"
msgstr ""

#: ../../language/fundamentals.md:212
msgid "A `Ref[T]` is a mutable reference containing a value `val` of type `T`."
msgstr ""
"`Ref[T]` 是一个包含类型 `T` 的值 `val` 的可变引用。"

#: ../../language/fundamentals.md:214
msgid ""
"It can be constructed using `{ val : x }`, and can be accessed using "
"`ref.val`. See [struct](#struct) for detailed explanation."
msgstr ""
"可以使用 `{ val : x }` 构造它，并可以使用 `ref.val` 访问它。有关详细说明，请参见[结构体](#struct)。"

#: ../../language/fundamentals.md:216
msgid ""
"let a : Ref[Int] = { val : 100 }\n"
"\n"
"test {\n"
"  a.val = 200\n"
"  assert_eq!(a.val, 200)\n"
"  a.val += 1\n"
"  assert_eq!(a.val, 201)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:222
msgid "Option and Result"
msgstr "Option 和 Result"

#: ../../language/fundamentals.md:224
msgid ""
"`Option` and `Result` are the most common types to represent a possible "
"error or failure in MoonBit."
msgstr ""
"`Option` 和 `Result` 是 MoonBit 中表示可能的错误或失败的最常见类型。"

#: ../../language/fundamentals.md:226
msgid ""
"`Option[T]` represents a possibly missing value of type `T`. It can be "
"abbreviated as `T?`."
msgstr ""
"`Option[T]` 表示可能缺失的类型 `T` 的值。它可以缩写为 `T?`。"

#: ../../language/fundamentals.md:227
msgid ""
"`Result[T, E]` represents either a value of type `T` or an error of type "
"`E`."
msgstr ""
"`Result[T, E]` 表示类型 `T` 的值或类型 `E` 的错误。"

#: ../../language/fundamentals.md:229
msgid "See [enum](#enum) for detailed explanation."
msgstr ""
"有关详细说明，请参见[枚举](#enum)。"

#: ../../language/fundamentals.md:231
msgid ""
"test {\n"
"  let a : Option[Int] = None\n"
"  let b : Option[Int] = Some(42)\n"
"  let c : Result[Int, String] = Ok(42)\n"
"  let d : Result[Int, String] = Err(\"error\")\n"
"  match a {\n"
"    Some(_) => assert_true!(false)\n"
"    None => assert_true!(true)\n"
"  }\n"
"  match d {\n"
"    Ok(_) => assert_true!(false)\n"
"    Err(_) => assert_true!(true)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:237
msgid "Array"
msgstr "数组"

#: ../../language/fundamentals.md:239
msgid ""
"An array is a finite sequence of values constructed using square brackets"
" `[]`, with elements separated by commas `,`. For example:"
msgstr ""
"数组是使用方括号 `[]` 构造的有限值序列，元素之间用逗号 `,` 分隔。例如："

#: ../../language/fundamentals.md:241
msgid "let numbers = [1, 2, 3, 4]\n"
msgstr ""

#: ../../language/fundamentals.md:248
msgid ""
"You can use `numbers[x]` to refer to the xth element. The index starts "
"from zero."
msgstr ""
"您可以使用 `numbers[x]` 来引用第 x 个元素。索引从零开始。"

#: ../../language/fundamentals.md:250
msgid ""
"test {\n"
"  let numbers = [1, 2, 3, 4]\n"
"  let a = numbers[2]\n"
"  numbers[3] = 5\n"
"  let b = a + numbers[3]\n"
"  assert_eq!(b, 8)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:257
msgid "There are `Array[T]` and `FixedArray[T]`:"
msgstr ""
"有 `Array[T]` 和 `FixedArray[T]`："

#: ../../language/fundamentals.md:259
msgid "`Array[T]` can grow in size, while"
msgstr ""
"`Array[T]` 可以增长，而"

#: ../../language/fundamentals.md:260
msgid ""
"`FixedArray[T]` has a fixed size, thus it needs to be created with "
"initial value."
msgstr ""
"`FixedArray[T]` 有固定的大小，因此需要使用初始值创建。"

#: ../../language/fundamentals.md:263
msgid "A common pitfall is creating `FixedArray` with the same initial value:"
msgstr ""
"一个常见的陷阱是使用相同的初始值创建 `FixedArray`："

#: ../../language/fundamentals.md:265
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))"
"\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:272
msgid ""
"This is because all the cells reference to the same object (the "
"`FixedArray[Int]` in this case). One should use `FixedArray::makei()` "
"instead which creates an object for each index."
msgstr ""
"这是因为所有单元格引用相同的对象（在这种情况下是 `FixedArray[Int]`）。应该使用 `FixedArray::makei()`，它为每个索引创建一个对象。"

#: ../../language/fundamentals.md:274
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::makei(\n"
"    10, \n"
"    fn (_i) { FixedArray::make(10, 0) }\n"
"  )\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:282
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"array, otherwise `Array[T]` is created:"
msgstr ""
"当期望的类型已知时，MoonBit 可以自动重载数组，否则将创建 `Array[T]`："

#: ../../language/fundamentals.md:285
msgid ""
"let fixed_array_1 : FixedArray[Int] = [1, 2, 3]\n"
"let fixed_array_2 = ([1, 2, 3] : FixedArray[Int])\n"
"let array_3 = [1, 2, 3] // Array[Int]\n"
msgstr ""

#: ../../language/fundamentals.md:291
msgid "ArrayView"
msgstr ""

#: ../../language/fundamentals.md:293
msgid ""
"Analogous to `slice` in other languages, the view is a reference to a "
"specific segment of collections. You can use `data[start:end]` to create "
"a view of array `data`, referencing elements from `start` to `end` "
"(exclusive). Both `start` and `end` indices can be omitted."
msgstr ""
"类似于其他语言中的 `slice`，视图是对集合的特定段的引用。您可以使用 `data[start:end]` 创建数组 `data` 的视图，引用从 `start` 到 `end`（不包括）的元素。`start` 和 `end` 索引都可以省略。"

#: ../../language/fundamentals.md:298
msgid ""
"test {\n"
"  let xs = [0, 1, 2, 3, 4, 5]\n"
"  let s1 : ArrayView[Int] = xs[2:]\n"
"  inspect!(s1, content=\"[2, 3, 4, 5]\")\n"
"  inspect!(xs[:4], content=\"[0, 1, 2, 3]\")\n"
"  inspect!(xs[2:5], content=\"[2, 3, 4]\")\n"
"  inspect!(xs[:], content=\"[0, 1, 2, 3, 4, 5]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:304
msgid "Map"
msgstr "Map"

#: ../../language/fundamentals.md:306
msgid ""
"MoonBit provides a hash map data structure that preserves insertion order"
" called `Map` in its standard library. `Map`s can be created via a "
"convenient literal syntax:"
msgstr ""
"MoonBit 在其标准库中提供了一个保留插入顺序的哈希映射数据结构，称为 `Map`。`Map` 可以通过方便的字面量语法创建："

#: ../../language/fundamentals.md:309
msgid "let map : Map[String, Int] = { \"x\": 1, \"y\": 2, \"z\": 3 }\n"
msgstr ""

#: ../../language/fundamentals.md:315
msgid ""
"Currently keys in map literal syntax must be constant. `Map`s can also be"
" destructed elegantly with pattern matching, see [Map Pattern](#map-"
"pattern)."
msgstr ""
"目前，映射字面量语法中的键必须是常量。`Map` 也可以通过模式匹配优雅地解构，参见 [Map 模式](#map-pattern)。"

#: ../../language/fundamentals.md:317
msgid "Json literal"
msgstr ""
"Json 字面量"

#: ../../language/fundamentals.md:319
msgid ""
"MoonBit supports convenient json handling by overloading literals. When "
"the expected type of an expression is `Json`, number, string, array and "
"map literals can be directly used to create json data:"
msgstr ""
"MoonBit 通过重载字面量支持方便的 json 处理。当表达式的期望类型是 `Json` 时，数字、字符串、数组和映射字面量可以直接用于创建 json 数据："

#: ../../language/fundamentals.md:322
msgid ""
"let moon_pkg_json_example : Json = {\n"
"  \"import\": [\"moonbitlang/core/builtin\", "
"\"moonbitlang/core/coverage\"],\n"
"  \"test-import\": [\"moonbitlang/core/random\"],\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:328
msgid "Json values can be pattern matched too, see [Json Pattern](#json-pattern)."
msgstr ""
"Json 值也可以进行模式匹配，参见 [Json 模式](#json-pattern)。"

#: ../../language/fundamentals.md:330
msgid "Functions"
msgstr ""

#: ../../language/fundamentals.md:332
msgid ""
"Functions take arguments and produce a result. In MoonBit, functions are "
"first-class, which means that functions can be arguments or return values"
" of other functions. MoonBit's naming convention requires that function "
"names should not begin with uppercase letters (A-Z). Compare for "
"constructors in the `enum` section below."
msgstr ""

#: ../../language/fundamentals.md:334
msgid "Top-Level Functions"
msgstr ""

#: ../../language/fundamentals.md:336
msgid ""
"Functions can be defined as top-level or local. We can use the `fn` "
"keyword to define a top-level function that sums three integers and "
"returns the result, as follows:"
msgstr ""

#: ../../language/fundamentals.md:338
msgid ""
"fn add3(x : Int, y : Int, z : Int) -> Int {\n"
"  x + y + z\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:344
msgid ""
"Note that the arguments and return value of top-level functions require "
"**explicit** type annotations."
msgstr ""

#: ../../language/fundamentals.md:346
msgid "Local Functions"
msgstr ""

#: ../../language/fundamentals.md:348
msgid ""
"Local functions can be named or anonymous. Type annotations can be "
"omitted for local function definitions: they can be automatically "
"inferred in most cases. For example:"
msgstr ""

#: ../../language/fundamentals.md:350
msgid ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // named as `inc`\n"
"    x + 1\n"
"  }\n"
"  // anonymous, instantly applied to integer literal 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:356
msgid ""
"There's also a form called **matrix function** that make use of [pattern "
"matching](#pattern-matching):"
msgstr ""

#: ../../language/fundamentals.md:358
msgid ""
"let extract : (Int?, Int) -> Int = fn {\n"
"  Some(x), _ => x\n"
"  None, default => default\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:364
msgid ""
"Functions, whether named or anonymous, are _lexical closures_: any "
"identifiers without a local binding must refer to bindings from a "
"surrounding lexical scope. For example:"
msgstr ""

#: ../../language/fundamentals.md:366
msgid ""
"let global_y = 3\n"
"\n"
"fn local_2(x : Int) -> (Int, Int) {\n"
"  fn inc() {\n"
"    x + 1\n"
"  }\n"
"\n"
"  fn four() {\n"
"    global_y + 1\n"
"  }\n"
"\n"
"  (inc(), four())\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_2(3), (4, 4))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:372
msgid "Function Applications"
msgstr ""

#: ../../language/fundamentals.md:374
msgid "A function can be applied to a list of arguments in parentheses:"
msgstr ""

#: ../../language/fundamentals.md:376
msgid "add3(1, 2, 7)\n"
msgstr ""

#: ../../language/fundamentals.md:380
msgid ""
"This works whether `add3` is a function defined with a name (as in the "
"previous example), or a variable bound to a function value, as shown "
"below:"
msgstr ""

#: ../../language/fundamentals.md:382
msgid ""
"test {\n"
"  let add3 = fn(x, y, z) { x + y + z }\n"
"  assert_eq!(add3(1, 2, 7), 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:388
msgid ""
"The expression `add3(1, 2, 7)` returns `10`. Any expression that "
"evaluates to a function value is applicable:"
msgstr ""

#: ../../language/fundamentals.md:390
msgid ""
"test {\n"
"  let f = fn(x) { x + 1 }\n"
"  let g = fn(x) { x + 2 }\n"
"  let w = (if true { f } else { g })(3)\n"
"  assert_eq!(w, 4)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:397
msgid "Labelled arguments"
msgstr ""

#: ../../language/fundamentals.md:399
msgid ""
"**Top-level** functions can declare labelled argument with the syntax "
"`label~ : Type`. `label` will also serve as parameter name inside "
"function body:"
msgstr ""

#: ../../language/fundamentals.md:401
msgid ""
"fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {\n"
"  arg1 + arg2\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:407
msgid ""
"Labelled arguments can be supplied via the syntax `label=arg`. "
"`label=label` can be abbreviated as `label~`:"
msgstr ""

#: ../../language/fundamentals.md:409
msgid ""
"test {\n"
"  let arg1 = 1\n"
"  assert_eq!(labelled_1(arg2=2, arg1~), 3)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:415
msgid ""
"Labelled function can be supplied in any order. The evaluation order of "
"arguments is the same as the order of parameters in function declaration."
msgstr ""

#: ../../language/fundamentals.md:417
msgid "Optional arguments"
msgstr ""

#: ../../language/fundamentals.md:419
msgid ""
"A labelled argument can be made optional by supplying a default "
"expression with the syntax `label~ : Type = default_expr`. If this "
"argument is not supplied at call site, the default expression will be "
"used:"
msgstr ""

#: ../../language/fundamentals.md:421
msgid ""
"fn optional(opt~ : Int = 42) -> Int {\n"
"  opt\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(optional(), 42)\n"
"  assert_eq!(optional(opt=0), 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:427
msgid ""
"The default expression will be evaluated every time it is used. And the "
"side effect in the default expression, if any, will also be triggered. "
"For example:"
msgstr ""

#: ../../language/fundamentals.md:429
msgid ""
"fn incr(counter~ : Ref[Int] = { val: 0 }) -> Ref[Int] {\n"
"  counter.val = counter.val + 1\n"
"  counter\n"
"}\n"
"\n"
"test {\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  let counter : Ref[Int] = { val: 0 }\n"
"  inspect!(incr(counter~), content=\"{val: 1}\")\n"
"  inspect!(incr(counter~), content=\"{val: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:435
msgid ""
"If you want to share the result of default expression between different "
"function calls, you can lift the default expression to a toplevel `let` "
"declaration:"
msgstr ""

#: ../../language/fundamentals.md:437
msgid ""
"let default_counter : Ref[Int] = { val: 0 }\n"
"\n"
"fn incr_2(counter~ : Ref[Int] = default_counter) -> Int {\n"
"  counter.val = counter.val + 1\n"
"  counter.val\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(incr_2(), 1)\n"
"  assert_eq!(incr_2(), 2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:443
msgid ""
"Default expression can depend on the value of previous arguments. For "
"example:"
msgstr ""

#: ../../language/fundamentals.md:445
msgid ""
"fn sub_array[X](\n"
"  xs : Array[X],\n"
"  offset~ : Int,\n"
"  len~ : Int = xs.length() - offset\n"
") -> Array[X] {\n"
"  xs[offset:offset + len].iter().to_array()\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1), [2, 3])\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1, len=1), [2])\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:452
msgid "Automatically insert `Some` when supplying optional arguments"
msgstr ""

#: ../../language/fundamentals.md:454
msgid ""
"It is quite often optional arguments have type `T?` with `None` as "
"default value. In this case, passing the argument explicitly requires "
"wrapping a `Some`, which is ugly:"
msgstr ""

#: ../../language/fundamentals.md:458
msgid ""
"fn ugly_constructor(width~ : Int? = None, height~ : Int? = None) -> Image"
" {\n"
"  ...\n"
"}\n"
"\n"
"let img : Image = ugly_constructor(width=Some(1920), height=Some(1080))\n"
msgstr ""

#: ../../language/fundamentals.md:464
msgid ""
"Fortunately, MoonBit provides a special kind of optional arguments to "
"solve this problem. Optional arguments declared with `label? : T` has "
"type `T?` and `None` as default value. When supplying this kind of "
"optional argument directly, MoonBit will automatically insert a `Some`:"
msgstr ""

#: ../../language/fundamentals.md:468
msgid ""
"fn nice_constructor(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"let img2 : Image = nice_constructor(width=1920, height=1080)\n"
msgstr ""

#: ../../language/fundamentals.md:474
msgid ""
"Sometimes, it is also useful to pass a value of type `T?` directly, for "
"example when forwarding optional argument. MoonBit provides a syntax "
"`label?=value` for this, with `label?` being an abbreviation of "
"`label?=label`:"
msgstr ""

#: ../../language/fundamentals.md:478
msgid ""
"fn image(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"fn fixed_width_image(height? : Int) -> Image {\n"
"  image(width=1920, height?)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:484
msgid "Autofill arguments"
msgstr ""

#: ../../language/fundamentals.md:486
msgid ""
"MoonBit supports filling specific types of arguments automatically at "
"different call site, such as the source location of a function call. To "
"declare an autofill argument, simply declare an optional argument with "
"`_` as default value. Now if the argument is not explicitly supplied, "
"MoonBit will automatically fill it at the call site."
msgstr ""

#: ../../language/fundamentals.md:490
msgid ""
"Currently MoonBit supports two types of autofill arguments, `SourceLoc`, "
"which is the source location of the whole function call, and `ArgsLoc`, "
"which is a array containing the source location of each argument, if any:"
msgstr ""

#: ../../language/fundamentals.md:493
msgid ""
"fn f(_x : Int, loc~ : SourceLoc = _, args_loc~ : ArgsLoc = _) -> String {"
"\n"
"  $|loc of whole function call: \\{loc}\n"
"  $|loc of arguments: \\{args_loc}\n"
"  // loc of whole function call: <filename>:7:3-7:10\n"
"  // loc of arguments: [Some(<filename>:7:5-7:6), "
"Some(<filename>:7:8-7:9), None, None]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:499
msgid ""
"Autofill arguments are very useful for writing debugging and testing "
"utilities."
msgstr ""

#: ../../language/fundamentals.md:501
msgid "Control Structures"
msgstr ""

#: ../../language/fundamentals.md:503
msgid "Conditional Expressions"
msgstr ""

#: ../../language/fundamentals.md:505
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional `else` clause or `else if` clause."
msgstr ""

#: ../../language/fundamentals.md:507
msgid ""
"if x == y {\n"
"  expr1\n"
"} else if x == z {\n"
"  expr2\n"
"} else {\n"
"  expr3\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:514
msgid "The curly brackets around the consequent are required."
msgstr ""

#: ../../language/fundamentals.md:516
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and"
" the return values of the consequent and the else clause must be of the "
"same type. Here is an example:"
msgstr ""

#: ../../language/fundamentals.md:518
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/fundamentals.md:525
msgid "The `else` clause can only be omitted if the return value has type `Unit`."
msgstr ""

#: ../../language/fundamentals.md:527
msgid "Match Expression"
msgstr ""

#: ../../language/fundamentals.md:529
msgid ""
"The `match` expression is similar to conditional expression, but it uses "
"[pattern matching](#pattern-matching) to decide which consequent to "
"evaluate and extracting variables at the same time."
msgstr ""

#: ../../language/fundamentals.md:531
msgid ""
"fn decide_sport(weather : String, humidity : Int) -> String {\n"
"  match weather {\n"
"    \"sunny\" => \"tennis\"\n"
"    \"rainy\" => if humidity > 80 { \"swimming\" } else { \"football\" }\n"
"    _ => \"unknown\"\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(decide_sport(\"sunny\", 0), \"tennis\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:538
msgid ""
"If a possible condition is omitted, the compiler will issue a warning, "
"and the program will terminate if that case were reached."
msgstr ""

#: ../../language/fundamentals.md:540
msgid "Guard Statement"
msgstr ""

#: ../../language/fundamentals.md:542
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing "
"the subsequent statements and returns. If the condition is not satisfied "
"(i.e., false), the code in the `else` block is executed and its "
"evaluation result is returned (the subsequent statements are skipped)."
msgstr ""

#: ../../language/fundamentals.md:547
msgid ""
"fn guarded_get(array : Array[Int], index : Int) -> Int? {\n"
"  guard index >= 0 && index < array.length() else { None }\n"
"  Some(array[index])\n"
"}\n"
"\n"
"test {\n"
"  inspect!(guarded_get([1, 2, 3], -1), content=\"None\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:554
msgid "Guarded Let"
msgstr ""

#: ../../language/fundamentals.md:556
msgid ""
"The `let` statement can be used with [pattern matching](#pattern-"
"matching). However, `let` statement can only handle one case. And `guard "
"let` can solve this issue."
msgstr ""

#: ../../language/fundamentals.md:558
msgid ""
"In the following example, `getProcessedText` assumes that the input "
"`path` points to resources that are all plain text, and it uses the "
"`guard` statement to ensure this invariant. Compared to using a `match` "
"statement, the subsequent processing of `text` can have one less level of"
" indentation."
msgstr ""

#: ../../language/fundamentals.md:562
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String\n"
") -> String!Error {\n"
"  guard let Some(PlainText(text)) = resources[path] else {\n"
"    None => fail!(\"\\{path} not found\")\n"
"    Some(Folder(_)) => fail!(\"\\{path} is a folder\")\n"
"    Some(JsonConfig(_)) => fail!(\"\\{path} is a json config\")\n"
"  }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:568
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr ""

#: ../../language/fundamentals.md:571
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard let Some(x) = expr\n"
"// <=> guard let Some(x) = expr else { _ => panic() }\n"
msgstr ""

#: ../../language/fundamentals.md:578
msgid "While loop"
msgstr ""

#: ../../language/fundamentals.md:580
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code "
"repeatedly as long as a condition is true. The condition is evaluated "
"before executing the block of code. The `while` loop is defined using the"
" `while` keyword, followed by a condition and the loop body. The loop "
"body is a sequence of statements. The loop body is executed as long as "
"the condition is true."
msgstr ""

#: ../../language/fundamentals.md:582
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:590
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/fundamentals.md:594
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you "
"to exit the current loop, while using `continue` skips the remaining part"
" of the current iteration and proceeds to the next iteration."
msgstr ""

#: ../../language/fundamentals.md:596
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:604
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/fundamentals.md:608
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the"
" loop will end."
msgstr ""

#: ../../language/fundamentals.md:610
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:618
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:622
msgid ""
"When there is an `else` clause, the `while` loop can also return a value."
" The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value"
" of the `else` clause."
msgstr ""

#: ../../language/fundamentals.md:624
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:632
msgid "5\n"
msgstr ""

#: ../../language/fundamentals.md:636
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:644
msgid "7\n"
msgstr ""

#: ../../language/fundamentals.md:648
msgid "For Loop"
msgstr ""

#: ../../language/fundamentals.md:650
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by"
" variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. "
"For example, the code below creates a new variable binding `i`, which has"
" a scope throughout the entire loop and is immutable. This makes it "
"easier to write clear code and reason about it:"
msgstr ""

#: ../../language/fundamentals.md:653
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:661
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/fundamentals.md:665
msgid "The variable initialization clause can create multiple bindings:"
msgstr ""

#: ../../language/fundamentals.md:667
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:674
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In "
"other words, in the example above, the update clause does not execute `i "
"= i + 1`, `j = j + 1` sequentially, but rather increments `i` and `j` at "
"the same time. Therefore, when reading the values of the binding "
"variables in the update clause, you will always get the values updated in"
" the previous iteration."
msgstr ""

#: ../../language/fundamentals.md:676
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are "
"all optional. For example, the following two are infinite loops:"
msgstr ""

#: ../../language/fundamentals.md:678
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:685
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. "
"Like the `while` loop, the `for` loop can also return a value using the "
"`break` and `else` clauses."
msgstr ""

#: ../../language/fundamentals.md:687
msgid ""
"The `continue` statement skips the remaining part of the current "
"iteration of the `for` loop (including the update clause) and proceeds to"
" the next iteration. The `continue` statement can also update the binding"
" variables of the `for` loop, as long as it is followed by expressions "
"that match the number of binding variables, separated by commas."
msgstr ""

#: ../../language/fundamentals.md:689
msgid ""
"For example, the following program calculates the sum of even numbers "
"from 1 to 6:"
msgstr ""

#: ../../language/fundamentals.md:691
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:699
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/fundamentals.md:703
msgid "`for .. in` loop"
msgstr ""

#: ../../language/fundamentals.md:705
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr ""

#: ../../language/fundamentals.md:707
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:714
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard"
" library. Any type with a method `.iter() : Iter[T]` can be traversed "
"using `for .. in`. For more information of the `Iter` type, see "
"[Iterator](#iterator) below."
msgstr ""

#: ../../language/fundamentals.md:717
msgid ""
"`for .. in` loop also supports iterating through a sequence of integers, "
"such as:"
msgstr ""

#: ../../language/fundamentals.md:719
msgid ""
"test {\n"
"  let mut i = 0\n"
"  for j in 0..<10 {\n"
"    i += j\n"
"  }\n"
"  assert_eq!(i, 45)\n"
"\n"
"  let mut k = 0\n"
"  for l in 0..=10 {\n"
"    k += l\n"
"  }\n"
"  assert_eq!(k, 55)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:726
msgid ""
"In addition to sequences of a single value, MoonBit also supports "
"traversing sequences of two values, such as `Map`, via the `Iter2` type "
"in MoonBit's standard library. Any type with method `.iter2() : Iter2[A, "
"B]` can be traversed using `for .. in` with two loop variables:"
msgstr ""

#: ../../language/fundamentals.md:729
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:736
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr ""

#: ../../language/fundamentals.md:738
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:746
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/fundamentals.md:750
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr ""

#: ../../language/fundamentals.md:752
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:760
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/fundamentals.md:764
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr ""

#: ../../language/fundamentals.md:766
msgid "Functional loop"
msgstr ""

#: ../../language/fundamentals.md:768
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to "
"write loops in a functional style."
msgstr ""

#: ../../language/fundamentals.md:770
msgid ""
"A functional loop consumes arguments and returns a value. It is defined "
"using the `loop` keyword, followed by its arguments and the loop body. "
"The loop body is a sequence of clauses, each of which consists of a "
"pattern and an expression. The clause whose pattern matches the input "
"will be executed, and the loop will return the value of the expression. "
"If no pattern matches, the loop will panic. Use the `continue` keyword "
"with arguments to start the next iteration of the loop. Use the `break` "
"keyword with arguments to return a value from the loop. The `break` "
"keyword can be omitted if the value is the last expression in the loop "
"body."
msgstr ""

#: ../../language/fundamentals.md:772
msgid ""
"test {\n"
"  fn sum(xs : @immut/list.T[Int]) -> Int {\n"
"    loop xs, 0 {\n"
"      Nil, acc => break acc // <=> Nil, acc => acc\n"
"      Cons(x, rest), acc => continue rest, x + acc\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq!(sum(Cons(1, Cons(2, Cons(3, Nil)))), 6)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:779
msgid ""
"Currently in `loop exprs { ... }`, `exprs` is nonempty list, while `for {"
" ... }` is accepted for infinite loop."
msgstr ""

#: ../../language/fundamentals.md:782
msgid "Iterator"
msgstr ""

#: ../../language/fundamentals.md:784
msgid ""
"An iterator is an object that traverse through a sequence while providing"
" access to its elements. Traditional OO languages like Java's "
"`Iterator<T>` use `next()` `hasNext()` to step through the iteration "
"process, whereas functional languages (JavaScript's `forEach`, Lisp's "
"`mapcar`) provides a high-order function which takes an operation and a "
"sequence then consumes the sequence with that operation being applied to "
"the sequence. The former is called _external iterator_ (visible to user) "
"and the latter is called _internal iterator_ (invisible to user)."
msgstr ""

#: ../../language/fundamentals.md:792
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator "
"implementation. Almost all built-in sequential data structures have "
"implemented `Iter`:"
msgstr ""

#: ../../language/fundamentals.md:795
msgid ""
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(fn { x => (x & 1) == 0 }).collect()\n"
"}\n"
"\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::op_mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:801
msgid "Commonly used methods include:"
msgstr ""

#: ../../language/fundamentals.md:803
msgid ""
"`each`: Iterates over each element in the iterator, applying some "
"function to each element."
msgstr ""

#: ../../language/fundamentals.md:804
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr ""

#: ../../language/fundamentals.md:805
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr ""

#: ../../language/fundamentals.md:807
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a "
"predicate function."
msgstr ""

#: ../../language/fundamentals.md:808
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr ""

#: ../../language/fundamentals.md:809
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the "
"elements of the second iterator to the first."
msgstr ""

#: ../../language/fundamentals.md:811
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. "
"Array. But what makes `Iter` special is that any method that constructs a"
" new `Iter` is _lazy_ (i.e. iteration doesn't start on call because it's "
"wrapped inside a function), as a result of no allocation for intermediate"
" value. That's what makes `Iter` superior for traversing through "
"sequence: no extra cost. MoonBit encourages user to pass an `Iter` across"
" functions instead of the sequence object itself."
msgstr ""

#: ../../language/fundamentals.md:819
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement "
"`Iter`, namely, a function that returns an `Iter[S]`. Take `Bytes` as an "
"example:"
msgstr ""

#: ../../language/fundamentals.md:824
msgid ""
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(\n"
"    fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"      for byte in data {\n"
"        if visit(byte) == IterEnd {\n"
"          break IterEnd\n"
"        }\n"
"      } else {\n"
"        IterContinue\n"
"      }\n"
"    },\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:830
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the "
"only main difference being the code block that actually does the "
"iteration."
msgstr ""

#: ../../language/fundamentals.md:833
msgid "Implementation details"
msgstr ""

#: ../../language/fundamentals.md:835
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration"
" which consists any of the 2 states:"
msgstr ""

#: ../../language/fundamentals.md:840
msgid "`IterEnd`: marking the end of an iteration"
msgstr ""

#: ../../language/fundamentals.md:841
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr ""

#: ../../language/fundamentals.md:843
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use "
"it to transform `Iter[T]` itself to a new state of type `IterResult`. "
"Whether that state being `IterEnd` `IterContinue` depends on the "
"function."
msgstr ""

#: ../../language/fundamentals.md:847
msgid ""
"Iterator provides a unified way to iterate through data structures, and "
"they can be constructed at basically no cost: as long as `fn(yield)` "
"doesn't execute, the iteration process doesn't start."
msgstr ""

#: ../../language/fundamentals.md:851
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all"
" sorts of `Iter` methods might be visually pleasing, but do notice the "
"heavy work underneath the abstraction."
msgstr ""

#: ../../language/fundamentals.md:855
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no "
"way to stop unless the end is reached. Methods such as `count()` which "
"counts the number of elements in a iterator looks like an `O(1)` "
"operation but actually has linear time complexity. Carefully use "
"iterators or performance issue might occur."
msgstr ""

#: ../../language/fundamentals.md:861
msgid "Custom Data Types"
msgstr ""

#: ../../language/fundamentals.md:863
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr ""

#: ../../language/fundamentals.md:865
msgid "Struct"
msgstr ""

#: ../../language/fundamentals.md:867
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed "
"by field names. A struct can be constructed using a struct literal, which"
" is composed of a set of labeled values and delimited with curly "
"brackets. The type of a struct literal can be automatically inferred if "
"its fields exactly match the type definition. A field can be accessed "
"using the dot syntax `s.f`. If a field is marked as mutable using the "
"keyword `mut`, it can be assigned a new value."
msgstr ""

#: ../../language/fundamentals.md:869
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:875
msgid ""
"fn main {\n"
"  let u = User::{ id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  //! u.id = 10\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:883
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/fundamentals.md:887
msgid "Constructing Struct with Shorthand"
msgstr ""

#: ../../language/fundamentals.md:889
msgid ""
"If you already have some variable like `name` and `email`, it's redundant"
" to repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr ""

#: ../../language/fundamentals.md:891
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = User::{ id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:898
msgid ""
"If there's no other struct that has the same fields, it's redundant to "
"add the struct's name when constructing it:"
msgstr ""

#: ../../language/fundamentals.md:900
msgid "let u2 = { id : 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:907
msgid "Struct Update Syntax"
msgstr ""

#: ../../language/fundamentals.md:909
msgid ""
"It's useful to create a new struct based on an existing one, but with "
"some fields updated."
msgstr ""

#: ../../language/fundamentals.md:911
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"    $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:919
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/fundamentals.md:923
msgid "Enum"
msgstr ""

#: ../../language/fundamentals.md:925
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr ""

#: ../../language/fundamentals.md:927
msgid ""
"An enum can have a set of cases (constructors). Constructor names must "
"start with capitalized letter. You can use these names to construct "
"corresponding cases of an enum, or checking which branch an enum value "
"belongs to in pattern matching:"
msgstr ""

#: ../../language/fundamentals.md:929
msgid ""
"/// An enum type that represents the ordering relation between two "
"values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:935
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:942
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:950
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/fundamentals.md:954
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr ""

#: ../../language/fundamentals.md:956
msgid ""
"enum List {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of "
"the list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, List)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:962
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:969
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:977
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/fundamentals.md:981
msgid "Constructor with labelled arguments"
msgstr ""

#: ../../language/fundamentals.md:983
msgid "Enum constructors can have labelled argument:"
msgstr ""

#: ../../language/fundamentals.md:985
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:991
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:998
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1006
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:1010
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr ""

#: ../../language/fundamentals.md:1012
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc."
"\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1018
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with!(p2))\n"
"    println(p1.distance_with!(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1026
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/fundamentals.md:1030
msgid "Constructor with mutable fields"
msgstr ""

#: ../../language/fundamentals.md:1032
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr ""

#: ../../language/fundamentals.md:1034
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree"
"\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1040
msgid "Newtype"
msgstr ""

#: ../../language/fundamentals.md:1042
msgid "MoonBit supports a special kind of enum called newtype:"
msgstr ""

#: ../../language/fundamentals.md:1044
msgid ""
"// `UserId` is a fresh new type different from `Int`, \n"
"// and you can define new methods for `UserId`, etc.\n"
"// But at the same time, the internal representation of `UserId` \n"
"// is exactly the same as `Int`\n"
"type UserId Int\n"
"\n"
"type UserName String\n"
msgstr ""

#: ../../language/fundamentals.md:1050
msgid ""
"Newtypes are similar to enums with only one constructor (with the same "
"name as the newtype itself). So, you can use the constructor to create "
"values of newtype, or use pattern matching to extract the underlying "
"representation of a newtype:"
msgstr ""

#: ../../language/fundamentals.md:1052
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserName = UserName(\"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserName(uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1060
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/fundamentals.md:1064
msgid ""
"Besides pattern matching, you can also use `._` to extract the internal "
"representation of newtypes:"
msgstr ""

#: ../../language/fundamentals.md:1066
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let uid : Int = id._\n"
"  println(uid)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1074
msgid "1\n"
msgstr ""

#: ../../language/fundamentals.md:1078
msgid "Type alias"
msgstr ""

#: ../../language/fundamentals.md:1079
msgid "MoonBit supports type alias via the syntax `typealias Name = TargetType`:"
msgstr ""

#: ../../language/fundamentals.md:1081
msgid ""
"pub typealias Index = Int\n"
"\n"
"// type alias are private by default\n"
"typealias MapString[X] = Map[String, X]\n"
msgstr ""

#: ../../language/fundamentals.md:1087
msgid ""
"Unlike all other kinds of type declaration above, type alias does not "
"define a new type, it is merely a type macro that behaves exactly the "
"same as its definition. So for example one cannot define new methods or "
"implement traits for a type alias."
msgstr ""

#: ../../language/fundamentals.md:1092
msgid "Type alias can be used to perform incremental code refactor."
msgstr ""

#: ../../language/fundamentals.md:1094
msgid ""
"For example, if you want to move a type `T` from `@pkgA` to `@pkgB`, you "
"can leave a type alias `typealias T = @pkgB.T` in `@pkgA`, and "
"**incrementally** port uses of `@pkgA.T` to `@pkgB.T`. The type alias can"
" be removed after all uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr ""

#: ../../language/fundamentals.md:1099
msgid "Local types"
msgstr ""

#: ../../language/fundamentals.md:1101
msgid ""
"Moonbit supports declaring structs/enums/newtypes at the top of a "
"toplevel function, which are only visible within the current toplevel "
"function. These local types can use the generic parameters of the "
"toplevel function but cannot introduce additional generic parameters "
"themselves. Local types can derive methods using derive, but no "
"additional methods can be defined manually. For  example:"
msgstr ""

#: ../../language/fundamentals.md:1108
msgid ""
"fn toplevel[T: Show](x: T) -> Unit {\n"
"  enum LocalEnum {\n"
"    A(T)\n"
"    B(Int)\n"
"  } derive(Show)\n"
"  struct LocalStruct {\n"
"    a: (String, T)\n"
"  } derive(Show)\n"
"  type LocalNewtype T derive(Show)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1114
msgid "Currently, local types do not support being declared as error types."
msgstr ""

#: ../../language/fundamentals.md:1116
msgid "Pattern Matching"
msgstr ""

#: ../../language/fundamentals.md:1118
msgid ""
"Pattern matching allows us to match on specific pattern and bind data "
"from data structures."
msgstr ""

#: ../../language/fundamentals.md:1120
msgid "Simple Patterns"
msgstr ""

#: ../../language/fundamentals.md:1122
msgid "We can pattern match expressions against"
msgstr ""

#: ../../language/fundamentals.md:1124
msgid "literals, such as boolean values, numbers, chars, strings, etc"
msgstr ""

#: ../../language/fundamentals.md:1125
msgid "constants"
msgstr ""

#: ../../language/fundamentals.md:1126
msgid "structs"
msgstr ""

#: ../../language/fundamentals.md:1127
msgid "enums"
msgstr ""

#: ../../language/fundamentals.md:1128
msgid "arrays"
msgstr ""

#: ../../language/fundamentals.md:1129
msgid "maps"
msgstr ""

#: ../../language/fundamentals.md:1130
msgid "JSONs"
msgstr ""

#: ../../language/fundamentals.md:1132
msgid ""
"and so on. We can define identifiers to bind the matched values so that "
"they can be used later."
msgstr ""

#: ../../language/fundamentals.md:1134
msgid ""
"const ONE = 1\n"
"\n"
"fn match_int(x : Int) -> Unit {\n"
"  match x {\n"
"    0 => println(\"zero\")\n"
"    ONE => println(\"one\")\n"
"    value => println(value)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1141
msgid ""
"We can use `_` as wildcards for the values we don't care about, and use "
"`..` to ignore remaining fields of struct or enum, or array (see [array "
"pattern](#array-pattern))."
msgstr ""

#: ../../language/fundamentals.md:1143
msgid ""
"struct Point3D {\n"
"  x : Int\n"
"  y : Int\n"
"  z : Int\n"
"}\n"
"\n"
"fn match_point3D(p : Point3D) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"on yz-plane\")\n"
"    _ => println(\"not on yz-plane\")\n"
"  }\n"
"}\n"
"\n"
"enum Point[T] {\n"
"  Point2D(Int, Int, name~: String, payload~ : T)\n"
"}\n"
"\n"
"fn match_point[T](p : Point[T]) -> Unit {\n"
"  match p {\n"
"    //! Point2D(0, 0) => println(\"2D origin\")\n"
"    Point2D(0, 0, ..) => println(\"2D origin\")\n"
"    Point2D(_) => println(\"2D point\")\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1150
msgid ""
"We can use `as` to give a name to some pattern, and we can use `|` to "
"match several cases at once. A variable name can only be bound once in a "
"single pattern, and the same set of variables should be bound on both "
"sides of `|` patterns."
msgstr ""

#: ../../language/fundamentals.md:1152
msgid ""
"match expr {\n"
"  //! Add(e1, e2) | Lit(e1) => ...\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1159
msgid "Array Pattern"
msgstr ""

#: ../../language/fundamentals.md:1161
msgid ""
"For `Array`, `FixedArray` and `ArrayView`, MoonBit allows using array "
"pattern."
msgstr ""

#: ../../language/fundamentals.md:1163
msgid "Array pattern have the following forms:"
msgstr ""

#: ../../language/fundamentals.md:1165
msgid "`[]` : matching for an empty data structure"
msgstr ""

#: ../../language/fundamentals.md:1166
msgid "`[pa, pb, pc]` : matching for known number of elements, 3 in this example"
msgstr ""

#: ../../language/fundamentals.md:1167
msgid ""
"`[pa, ..]` : matching for known number of elements, followed by unknown "
"number of elements"
msgstr ""

#: ../../language/fundamentals.md:1168
msgid ""
"`[.., pa]` : matching for known number of elements, preceded by unknown "
"number of elements"
msgstr ""

#: ../../language/fundamentals.md:1170
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  let [a, b, ..] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  let [.., a, b] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1176
msgid "Range Pattern"
msgstr ""

#: ../../language/fundamentals.md:1177
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the"
" value falls in a specific range."
msgstr ""

#: ../../language/fundamentals.md:1179
msgid ""
"Range patterns have the form `a..<b` or `a..=b`, where `..<` means the "
"upper bound is exclusive, and `..=` means inclusive upper bound. `a` and "
"`b` can be one of:"
msgstr ""

#: ../../language/fundamentals.md:1182
msgid "literal"
msgstr ""

#: ../../language/fundamentals.md:1183
msgid "named constant declared with `const`"
msgstr ""

#: ../../language/fundamentals.md:1184
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr ""

#: ../../language/fundamentals.md:1186
msgid "Here are some examples:"
msgstr ""

#: ../../language/fundamentals.md:1188
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1195
msgid "Map Pattern"
msgstr ""

#: ../../language/fundamentals.md:1197
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a "
"map pattern, the `key : value` syntax will match if `key` exists in the "
"map, and match the value of `key` with pattern `value`. The `key? : "
"value` syntax will match no matter `key` exists or not, and `value` will "
"be matched against `map[key]` (an optional)."
msgstr ""

#: ../../language/fundamentals.md:1201
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _ } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" "
"exists in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1208
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and"
" trait](./methods.md))."
msgstr ""

#: ../../language/fundamentals.md:1209
msgid "Currently, the key part of map pattern must be a literal or constant"
msgstr ""

#: ../../language/fundamentals.md:1210
msgid "Map patterns are always open: unmatched keys are silently ignored"
msgstr ""

#: ../../language/fundamentals.md:1211
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched"
" at most once"
msgstr ""

#: ../../language/fundamentals.md:1213
msgid "Json Pattern"
msgstr ""

#: ../../language/fundamentals.md:1215
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly, together with constructors:"
msgstr ""

#: ../../language/fundamentals.md:1217
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports } => ...\n"
"  { \"version\": Number(i), \"import\": Array(imports)} => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1224
msgid "Generics"
msgstr ""

#: ../../language/fundamentals.md:1226
msgid ""
"Generics are supported in top-level function and data type definitions. "
"Type parameters can be introduced within square brackets. We can rewrite "
"the aforementioned data type `List` to add a type parameter `T` to obtain"
" a generic version of lists. We can then define generic functions over "
"lists like `map` and `reduce`."
msgstr ""

#: ../../language/fundamentals.md:1228
msgid ""
"enum List[T] {\n"
"  Nil\n"
"  Cons(T, List[T])\n"
"}\n"
"\n"
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1232
msgid "Special Syntax"
msgstr ""

#: ../../language/fundamentals.md:1234
msgid "Pipe operator"
msgstr ""

#: ../../language/fundamentals.md:1236
msgid ""
"MoonBit provides a convenient pipe operator `|>`, which can be used to "
"chain regular function calls:"
msgstr ""

#: ../../language/fundamentals.md:1238
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> push(5) // <=> push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/fundamentals.md:1245
msgid "Cascade Operator"
msgstr ""

#: ../../language/fundamentals.md:1247
msgid ""
"The cascade operator `..` is used to perform a series of mutable "
"operations on the same value consecutively. The syntax is as follows:"
msgstr ""

#: ../../language/fundamentals.md:1250
msgid "x..f()\n"
msgstr ""

#: ../../language/fundamentals.md:1257
msgid "`x..f()..g()` is equivalent to `{x.f(); x.g(); x}`."
msgstr ""

#: ../../language/fundamentals.md:1259
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has "
"methods like `write_string`, `write_char`, `write_object`, etc., we often"
" need to perform a series of operations on the same `StringBuilder` "
"value:"
msgstr ""

#: ../../language/fundamentals.md:1263
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1270
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed "
"to return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used"
" for consecutive operations without the need to modify the return type of"
" the methods."
msgstr ""

#: ../../language/fundamentals.md:1276
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1283
msgid "TODO syntax"
msgstr ""

#: ../../language/fundamentals.md:1285
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of"
" code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr ""

#: ../../language/fundamentals.md:1287
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/index.md:1
msgid "MoonBit Language"
msgstr ""

#: ../../language/index.md:3
msgid ""
"MoonBit is an end-to-end programming language toolchain for cloud and "
"edge computing using WebAssembly. The IDE environment is available at "
"[https://try.moonbitlang.com](https://try.moonbitlang.com) without any "
"installation; it does not rely on any server either."
msgstr ""

#: ../../language/index.md:5
msgid "**Status and aimed timeline**"
msgstr ""

#: ../../language/index.md:7
msgid "MoonBit is currently in beta-preview. We expect to reach 1.0 in 2025."
msgstr ""

#: ../../language/index.md:9
msgid ""
"When MoonBit reaches beta, it means any backwards-incompatible changes "
"will be seriously evaluated and MoonBit _can_ be used in production(very "
"rare compiler bugs). MoonBit is developed by a talented full time team "
"who had extensive experience in building language toolchains, so we will "
"grow much faster than the typical language ecosystem, you won't wait long"
" to use MoonBit in your production."
msgstr ""

#: ../../language/index.md:11
msgid "**Main advantages**"
msgstr ""

#: ../../language/index.md:13
msgid "Generate significantly smaller WASM output than any existing solutions."
msgstr ""

#: ../../language/index.md:14
msgid "Much faster runtime performance."
msgstr ""

#: ../../language/index.md:15
msgid "State of the art compile-time performance."
msgstr ""

#: ../../language/index.md:16
msgid "Simple but practical, data-oriented language design."
msgstr ""

#: ../../language/introduction.md:1
msgid "Introduction"
msgstr ""

#: ../../language/introduction.md:3
msgid "A MoonBit program consists of top-level definitions including:"
msgstr ""

#: ../../language/introduction.md:5
msgid "type definitions"
msgstr ""

#: ../../language/introduction.md:6
msgid "function definitions"
msgstr ""

#: ../../language/introduction.md:7
msgid "constant definitions and variable bindings"
msgstr ""

#: ../../language/introduction.md:8
msgid "`init` functions, `main` function and/or `test` blocks."
msgstr ""

#: ../../language/introduction.md:10
msgid "Expressions and Statements"
msgstr ""

#: ../../language/introduction.md:12
msgid ""
"MoonBit distinguishes between statements and expressions. In a function "
"body, only the last clause should be an expression, which serves as a "
"return value. For example:"
msgstr ""

#: ../../language/introduction.md:14
msgid ""
"fn foo() -> Int {\n"
"  let x = 1\n"
"  x + 1\n"
"}\n"
"\n"
"fn bar() -> Int {\n"
"  let x = 1\n"
"  //! x + 1\n"
"  x + 2\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:20
msgid "Expressions include:"
msgstr ""

#: ../../language/introduction.md:22
msgid ""
"Value literals (e.g. Boolean values, numbers, characters, strings, "
"arrays, tuples, structs)"
msgstr ""

#: ../../language/introduction.md:23
msgid "Arithmetical, logical, or comparison operations"
msgstr ""

#: ../../language/introduction.md:24
msgid ""
"Accesses to array elements (e.g. `a[0]`), struct fields (e.g `r.x`), "
"tuple components (e.g. `t.0`), etc."
msgstr ""

#: ../../language/introduction.md:25
msgid "Variables and (capitalized) enum constructors"
msgstr ""

#: ../../language/introduction.md:26
msgid "Anonymous local function definitions"
msgstr ""

#: ../../language/introduction.md:27
msgid "`match`, `if`, `loop` expressions, etc."
msgstr ""

#: ../../language/introduction.md:29
msgid "Statements include:"
msgstr ""

#: ../../language/introduction.md:31
msgid "Named local function definitions"
msgstr ""

#: ../../language/introduction.md:32
msgid "Local variable bindings"
msgstr ""

#: ../../language/introduction.md:33
msgid "Assignments"
msgstr ""

#: ../../language/introduction.md:34
msgid "`return` statements"
msgstr ""

#: ../../language/introduction.md:35
msgid "Any expression whose return type is `Unit`, (e.g. `ignore`)"
msgstr ""

#: ../../language/introduction.md:37
msgid ""
"A code block can contain multiple statements and one expression, and the "
"value of the expression is the value of the code block."
msgstr ""

#: ../../language/introduction.md:39
msgid "Variable Binding"
msgstr ""

#: ../../language/introduction.md:41
msgid ""
"A variable can be declared as mutable or immutable using `let mut` or "
"`let`, respectively. A mutable variable can be reassigned to a new value,"
" while an immutable one cannot."
msgstr ""

#: ../../language/introduction.md:43
msgid "A constant can only be declared at top level and cannot be changed."
msgstr ""

#: ../../language/introduction.md:45
msgid ""
"let zero = 0\n"
"\n"
"const ZERO = 0\n"
"\n"
"fn main {\n"
"  //! const ZERO = 0 \n"
"  let mut i = 10\n"
"  i = 20\n"
"  println(i + zero + ZERO)\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:50
msgid "A top level variable binding"
msgstr ""

#: ../../language/introduction.md:51
msgid ""
"requires **explicit** type annotation (unless defined using literals such"
" as string, byte or numbers)"
msgstr ""

#: ../../language/introduction.md:52
msgid "can't be mutable (use `Ref` instead)"
msgstr ""

#: ../../language/introduction.md:56
msgid "Naming conventions"
msgstr ""

#: ../../language/introduction.md:58
msgid ""
"Variables, functions should start with lowercase letters `a-z` and can "
"contain letters, numbers, and other non-ascii unicode chars. It is "
"recommended to name them with snake_case."
msgstr ""

#: ../../language/introduction.md:61
msgid ""
"Constants, types should start with uppercase letters `A-Z` and can "
"contain letters, numbers, and other non-ascii unicode chars. It is "
"recommended to name them with PascalCase or SCREAMING_SNAKE_CASE."
msgstr ""

#: ../../language/introduction.md:64
msgid "Program entrance"
msgstr ""

#: ../../language/introduction.md:66
msgid "`init` and `main`"
msgstr ""

#: ../../language/introduction.md:67
msgid ""
"There is a specialized function called `init` function. The `init` "
"function is special:"
msgstr ""

#: ../../language/introduction.md:69
msgid "It has no parameter list nor return type."
msgstr ""

#: ../../language/introduction.md:70
msgid "There can be multiple `init` functions in the same package."
msgstr ""

#: ../../language/introduction.md:71
msgid ""
"An `init` function can't be explicitly called or referred to by other "
"functions.  Instead, all `init` functions will be implicitly called when "
"initializing a package. Therefore, `init` functions should only consist "
"of statements."
msgstr ""

#: ../../language/introduction.md:74
msgid ""
"fn init {\n"
"  let x = 1\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:80
msgid ""
"There is another specialized function called `main` function. The `main` "
"function is the main entrance of the program, and it will be executed "
"after the initialization stage."
msgstr ""

#: ../../language/introduction.md:82
msgid "Same as the `init` function, it has no parameter list nor return type."
msgstr ""

#: ../../language/introduction.md:84
msgid ""
"fn main {\n"
"  let x = 2\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:90
msgid "The previous two code snippets will print the following at runtime:"
msgstr ""

#: ../../language/introduction.md:92
msgid ""
"1\n"
"2\n"
msgstr ""

#: ../../language/introduction.md:97
msgid ""
"Only packages that are `main` packages can define such `main` function. "
"Check out [build system tutorial](/toolchain/moon/tutorial) for detail."
msgstr ""

#: ../../language/introduction.md:99
msgid "moon.pkg.json"
msgstr ""

#: ../../language/introduction.md:99
msgid ""
"{\n"
"  \"is-main\": true\n"
"}"
msgstr ""

#: ../../language/introduction.md:104
msgid "`test`"
msgstr ""

#: ../../language/introduction.md:106
msgid ""
"There's also a top-level structure called `test` block. A `test` block "
"defines inline tests, such as:"
msgstr ""

#: ../../language/introduction.md:108 ../../language/tests.md:11
msgid ""
"test \"test_name\" {\n"
"  assert_eq!(1 + 1, 2)\n"
"  assert_eq!(2 + 2, 4)\n"
"  inspect!([1, 2, 3], content=\"[1, 2, 3]\")\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:114
msgid ""
"The following contents will use `test` block and `main` function to "
"demonstrate the execution result, and we assume that all the `test` "
"blocks pass unless stated otherwise."
msgstr ""

#: ../../language/methods.md:1
msgid "Method and Trait"
msgstr ""

#: ../../language/methods.md:3
msgid "Method system"
msgstr ""

#: ../../language/methods.md:5
msgid ""
"MoonBit supports methods in a different way from traditional object-"
"oriented languages. A method in MoonBit is just a toplevel function "
"associated with a type constructor. Methods can be defined using the "
"syntax `fn TypeName::method_name(...) -> ...`:"
msgstr ""

#: ../../language/methods.md:7
msgid ""
"enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"fn List::concat[X](xs : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:13
msgid ""
"As a convenient shorthand, when the first parameter of a function is "
"named `self`, MoonBit automatically defines the function as a method of "
"the type of `self`:"
msgstr ""

#: ../../language/methods.md:15
msgid ""
"fn List::map[X, Y](xs : List[X], f : (X) -> Y) -> List[Y] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:21
msgid "is equivalent to:"
msgstr ""

#: ../../language/methods.md:23
msgid ""
"fn map[X, Y](self : List[X], f : (X) -> Y) -> List[Y] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:29
msgid ""
"Methods are just regular functions owned by a type constructor. So when "
"there is no ambiguity, methods can be called using regular function call "
"syntax directly:"
msgstr ""

#: ../../language/methods.md:31
msgid ""
"let xs : List[List[_]] = { ... }\n"
"let ys = concat(xs)\n"
msgstr ""

#: ../../language/methods.md:38
msgid ""
"Unlike regular functions, methods support overloading: different types "
"can define methods of the same name. If there are multiple methods of the"
" same name (but for different types) in scope, one can still call them by"
" explicitly adding a `TypeName::` prefix:"
msgstr ""

#: ../../language/methods.md:40
msgid ""
"struct T1 {\n"
"  x1 : Int\n"
"}\n"
"\n"
"fn T1::default() -> T1 {\n"
"  { x1: 0 }\n"
"}\n"
"\n"
"struct T2 {\n"
"  x2 : Int\n"
"}\n"
"\n"
"fn T2::default() -> T2 {\n"
"  { x2: 0 }\n"
"}\n"
"\n"
"test {\n"
"  // default() : T1::default() ? T2::default()?\n"
"  let t1 = T1::default()\n"
"  let t2 = T2::default()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:47
msgid ""
"When the first parameter of a method is also the type it belongs to, "
"methods can be called using dot syntax `x.method(...)`. MoonBit "
"automatically finds the correct method based on the type of `x`, there is"
" no need to write the type name and even the package name of the method:"
msgstr ""

#: ../../language/methods.md:49
msgid ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn List::concat[X](xs : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/methods.md:55
msgid "using package with alias list"
msgstr ""

#: ../../language/methods.md:55
msgid ""
"fn f() -> Unit {\n"
"  let xs : @list.List[@list.List[Unit]] = Nil\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:63
msgid ""
"The highlighted line is only possible when there is no ambiguity in "
"`@list`."
msgstr ""

#: ../../language/methods.md:65
msgid "Operator Overloading"
msgstr ""

#: ../../language/methods.md:67
msgid ""
"MoonBit supports operator overloading of builtin operators via methods. "
"The method name corresponding to a operator `<op>` is `op_<op>`. For "
"example:"
msgstr ""

#: ../../language/methods.md:69
msgid ""
"struct T {\n"
"  x : Int\n"
"}\n"
"\n"
"fn op_add(self : T, other : T) -> T {\n"
"  { x: self.x + other.x }\n"
"}\n"
"\n"
"test {\n"
"  let a = { x: 0 }\n"
"  let b = { x: 2 }\n"
"  assert_eq!((a + b).x, 2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:75
msgid "Another example about `op_get` and `op_set`:"
msgstr ""

#: ../../language/methods.md:77
msgid ""
"struct Coord {\n"
"  mut x : Int\n"
"  mut y : Int\n"
"} derive(Show)\n"
"\n"
"fn op_get(self : Coord, key : String) -> Int {\n"
"  match key {\n"
"    \"x\" => self.x\n"
"    \"y\" => self.y\n"
"  }\n"
"}\n"
"\n"
"fn op_set(self : Coord, key : String, val : Int) -> Unit {\n"
"  match key {\n"
"    \"x\" => self.x = val\n"
"    \"y\" => self.y = val\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/methods.md:83
msgid ""
"fn main {\n"
"  let c = { x: 1, y: 2 }\n"
"  println(c)\n"
"  println(c[\"y\"])\n"
"  c[\"x\"] = 23\n"
"  println(c)\n"
"  println(c[\"x\"])\n"
"}\n"
msgstr ""

#: ../../language/methods.md:91
msgid ""
"{x: 1, y: 2}\n"
"2\n"
"{x: 23, y: 2}\n"
"23\n"
msgstr ""

#: ../../language/methods.md:95
msgid "Currently, the following operators can be overloaded:"
msgstr ""

#: ../../language/methods.md:91
msgid "Operator Name"
msgstr ""

#: ../../language/methods.md:91
msgid "Method Name"
msgstr ""

#: ../../language/methods.md:91
msgid "`+`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_add`"
msgstr ""

#: ../../language/methods.md:91
msgid "`-`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_sub`"
msgstr ""

#: ../../language/methods.md:91
msgid "`*`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_mul`"
msgstr ""

#: ../../language/methods.md:91
msgid "`/`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_div`"
msgstr ""

#: ../../language/methods.md:91
msgid "`%`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_mod`"
msgstr ""

#: ../../language/methods.md:91
msgid "`=`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_equal`"
msgstr ""

#: ../../language/methods.md:91
msgid "`<<`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_shl`"
msgstr ""

#: ../../language/methods.md:91
msgid "`>>`"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_shr`"
msgstr ""

#: ../../language/methods.md:91
msgid "`-` (unary)"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_neg`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_]` (get item)"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_get`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_] = _` (set item)"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_set`"
msgstr ""

#: ../../language/methods.md:91
msgid "`_[_:_]` (view)"
msgstr ""

#: ../../language/methods.md:91
msgid "`op_as_view`"
msgstr ""

#: ../../language/methods.md:91
msgid "`&`"
msgstr ""

#: ../../language/methods.md:91
msgid "`land`"
msgstr ""

#: ../../language/methods.md:91
msgid "`|`"
msgstr ""

#: ../../language/methods.md:91
msgid "`lor`"
msgstr ""

#: ../../language/methods.md:91
msgid "`^`"
msgstr ""

#: ../../language/methods.md:91
msgid "`lxor`"
msgstr ""

#: ../../language/methods.md:118
msgid ""
"By implementing `op_as_view` method, you can create a view for a user-"
"defined type. Here is an example:"
msgstr ""

#: ../../language/methods.md:120
msgid ""
"type DataView String\n"
"\n"
"struct Data {}\n"
"\n"
"fn Data::op_as_view(_self : Data, start~ : Int = 0, end? : Int) -> "
"DataView {\n"
"  \"[\\{start}, \\{end.or(100)})\"\n"
"}\n"
"\n"
"test {\n"
"  let data = Data::{  }\n"
"  inspect!(data[:]._, content=\"[0, 100)\")\n"
"  inspect!(data[2:]._, content=\"[2, 100)\")\n"
"  inspect!(data[:5]._, content=\"[0, 5)\")\n"
"  inspect!(data[2:5]._, content=\"[2, 5)\")\n"
"}\n"
msgstr ""

#: ../../language/methods.md:126
msgid "Trait system"
msgstr ""

#: ../../language/methods.md:128
msgid ""
"MoonBit features a structural trait system for overloading/ad-hoc "
"polymorphism. Traits declare a list of operations, which must be supplied"
" when a type wants to implement the trait. Traits can be declared as "
"follows:"
msgstr ""

#: ../../language/methods.md:130
msgid ""
"trait I {\n"
"  method_(Int) -> Int\n"
"  method_with_label(Int, label~: Int) -> Int\n"
"  //! method_with_label(Int, label?: Int) -> Int\n"
"}\n"
msgstr ""

#: ../../language/methods.md:136
msgid ""
"In the body of a trait definition, a special type `Self` is used to refer"
" to the type that implements the trait."
msgstr ""

#: ../../language/methods.md:138
msgid "Extending traits"
msgstr ""

#: ../../language/methods.md:140
msgid "A trait can depend on other traits, for example:"
msgstr ""

#: ../../language/methods.md:142
msgid ""
"trait Position {\n"
"  pos(Self) -> (Int, Int)\n"
"}\n"
"trait Draw {\n"
"  draw(Self) -> Unit\n"
"}\n"
"\n"
"trait Object : Position + Draw {}\n"
msgstr ""

#: ../../language/methods.md:148
msgid ""
"To implement the super trait, one will have to implement the sub traits,"
"  and the methods defined in the super trait."
msgstr ""

#: ../../language/methods.md:151
msgid "Implementing traits"
msgstr ""

#: ../../language/methods.md:153
msgid ""
"To implement a trait, a type must provide all the methods required by the"
" trait."
msgstr ""

#: ../../language/methods.md:155
msgid ""
"This allows types to implement a trait implicitly, hence allowing "
"different packages to work together without seeing or depending on each "
"other. For example, the following trait is automatically implemented for "
"builtin number types such as `Int` and `Double`:"
msgstr ""

#: ../../language/methods.md:158
msgid ""
"trait Number {\n"
"  op_add(Self, Self) -> Self\n"
"  op_mul(Self, Self) -> Self\n"
"}\n"
msgstr ""

#: ../../language/methods.md:164
msgid ""
"**Explicit implementation** for trait methods can be provided via the "
"syntax `impl Trait for Type with method_name(...) { ... }`, for example:"
msgstr ""

#: ../../language/methods.md:166
msgid ""
"trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// trait implementation with type parameters.\n"
"// `[X : Show]` means the type parameter `X` must implement `Show`,\n"
"// this will be covered later.\n"
"impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"
msgstr ""

#: ../../language/methods.md:172
msgid ""
"Type annotation can be omitted for trait `impl`: MoonBit will "
"automatically infer the type based on the signature of `Trait::method` "
"and the self type."
msgstr ""

#: ../../language/methods.md:174
msgid ""
"The author of the trait can also define **default implementations** for "
"some methods in the trait, for example:"
msgstr ""

#: ../../language/methods.md:176
msgid ""
"trait J {\n"
"  f(Self) -> Unit\n"
"  f_twice(Self) -> Unit\n"
"}\n"
"\n"
"impl J with f_twice(self) {\n"
"  self.f()\n"
"  self.f()\n"
"}\n"
msgstr ""

#: ../../language/methods.md:182
msgid ""
"Implementers of trait `I` don't have to provide an implementation for "
"`f_twice`: to implement `I`, only `f` is necessary. They can always "
"override the default implementation with an explicit `impl I for Type "
"with f_twice`, if desired, though."
msgstr ""

#: ../../language/methods.md:185
msgid ""
"If an explicit `impl` or default implementation is not found, trait "
"method resolution falls back to regular methods."
msgstr ""

#: ../../language/methods.md:187
msgid "Using traits"
msgstr ""

#: ../../language/methods.md:189
msgid ""
"When declaring a generic function, the type parameters can be annotated "
"with the traits they should implement, allowing the definition of "
"constrained generic functions. For example:"
msgstr ""

#: ../../language/methods.md:191
msgid ""
"fn square[N : Number](x : N) -> N {\n"
"  x * x // <=> x.op_mul(x)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:197
msgid ""
"Without the `Number` requirement, the expression `x * x` in `square` will"
" result in a method/operator not found error. Now, the function `square` "
"can be called with any type that implements `Number`, for example:"
msgstr ""

#: ../../language/methods.md:199
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Show)\n"
"\n"
"impl Number for Point with op_add(self, other) {\n"
"  { x: self.x + other.x, y: self.y + other.y }\n"
"}\n"
"\n"
"impl Number for Point with op_mul(self, other) {\n"
"  { x: self.x * other.x, y: self.y * other.y }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(square(2), 4)\n"
"  assert_eq!(square(1.5), 2.25)\n"
"  assert_eq!(square(Point::{ x: 2, y: 3 }), { x: 4, y: 9 })\n"
"}\n"
msgstr ""

#: ../../language/methods.md:205
msgid "Invoke trait methods directly"
msgstr ""

#: ../../language/methods.md:207
msgid ""
"Methods of a trait can be called directly via `Trait::method`. MoonBit "
"will infer the type of `Self` and check if `Self` indeed implements "
"`Trait`, for example:"
msgstr ""

#: ../../language/methods.md:209
msgid ""
"test {\n"
"  assert_eq!(Show::to_string(42), \"42\")\n"
"  assert_eq!(Compare::compare(1.0, 2.5), -1)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:215
msgid ""
"Trait implementations can also be invoked via dot syntax, with the "
"following restrictions:"
msgstr ""

#: ../../language/methods.md:217
msgid ""
"if a regular method is present, the regular method is always favored when"
" using dot syntax"
msgstr ""

#: ../../language/methods.md:218
msgid ""
"only trait implementations that are located in the package of the self "
"type can be invoked via dot syntax"
msgstr ""

#: ../../language/methods.md:219
msgid ""
"if there are multiple trait methods (from different traits) with the same"
" name available, an ambiguity error is reported"
msgstr ""

#: ../../language/methods.md:220
msgid ""
"if neither of the above two rules apply, trait `impl`s in current package"
" will also be searched for dot syntax. This allows extending a foreign "
"type locally."
msgstr ""

#: ../../language/methods.md:222
msgid ""
"these `impl`s can only be called via dot syntax locally, even if they are"
" public."
msgstr ""

#: ../../language/methods.md:224
msgid ""
"The above rules ensures that MoonBit's dot syntax enjoys good property "
"while being flexible. For example, adding a new dependency never break "
"existing code with dot syntax due to ambiguity. These rules also make "
"name resolution of MoonBit extremely simple: the method called via dot "
"syntax must always come from current package or the package of the type!"
msgstr ""

#: ../../language/methods.md:229
msgid "Here's an example of calling trait `impl` with dot syntax:"
msgstr ""

#: ../../language/methods.md:231
msgid ""
"struct MyCustomType {}\n"
"\n"
"impl Show for MyCustomType with output(self, logger) { ... }\n"
"\n"
"fn f() -> Unit {\n"
"  let x = MyCustomType::{  }\n"
"  let _ = x.to_string()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:237
msgid "Trait objects"
msgstr ""

#: ../../language/methods.md:239
msgid ""
"MoonBit supports runtime polymorphism via trait objects. If `t` is of "
"type `T`, which implements trait `I`, one can pack the methods of `T` "
"that implements `I`, together with `t`, into a runtime object via `t as "
"&I`. Trait object erases the concrete type of a value, so objects created"
" from different concrete types can be put in the same data structure and "
"handled uniformly:"
msgstr ""

#: ../../language/methods.md:246
msgid ""
"trait Animal {\n"
"  speak(Self) -> String\n"
"}\n"
"\n"
"type Duck String\n"
"\n"
"fn Duck::make(name : String) -> Duck {\n"
"  Duck(name)\n"
"}\n"
"\n"
"fn speak(self : Duck) -> String {\n"
"  \"\\{self._}: quack!\"\n"
"}\n"
"\n"
"type Fox String\n"
"\n"
"fn Fox::make(name : String) -> Fox {\n"
"  Fox(name)\n"
"}\n"
"\n"
"fn Fox::speak(_self : Fox) -> String {\n"
"  \"What does the fox say?\"\n"
"}\n"
"\n"
"test {\n"
"  let duck1 = Duck::make(\"duck1\")\n"
"  let duck2 = Duck::make(\"duck2\")\n"
"  let fox1 = Fox::make(\"fox1\")\n"
"  let animals : Array[&Animal] = [\n"
"    duck1 as &Animal,\n"
"    duck2 as &Animal,\n"
"    fox1 as &Animal,\n"
"  ]\n"
"  inspect!(\n"
"    animals.map(fn(animal) { animal.speak() }),\n"
"    content=\n"
"      #|[\"duck1: quack!\", \"duck2: quack!\", \"What does the fox "
"say?\"]\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/methods.md:252
msgid ""
"Not all traits can be used to create objects. \"object-safe\" traits' "
"methods must satisfy the following conditions:"
msgstr ""

#: ../../language/methods.md:255
msgid "`Self` must be the first parameter of a method"
msgstr ""

#: ../../language/methods.md:256
msgid ""
"There must be only one occurrence of `Self` in the type of the method "
"(i.e. the first parameter)"
msgstr ""

#: ../../language/methods.md:258
msgid ""
"Users can define new methods for trait objects, just like defining new "
"methods for structs and enums:"
msgstr ""

#: ../../language/methods.md:260
msgid ""
"trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// use the new method to simplify code\n"
"impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"
msgstr ""

#: ../../language/methods.md:266
msgid "Builtin traits"
msgstr ""

#: ../../language/methods.md:268
msgid "MoonBit provides the following useful builtin traits:"
msgstr ""

#: ../../language/methods.md:272
msgid ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` for equal, `-1` for smaller, `1` for greater\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // to be implemented\n"
"  hash(Self) -> Int // has default implementation\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // to be implemented\n"
"  to_string(Self) -> String // has default implementation\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"
msgstr ""

#: ../../language/methods.md:297
msgid "Deriving builtin traits"
msgstr ""

#: ../../language/methods.md:299
msgid "MoonBit can automatically derive implementations for some builtin traits:"
msgstr ""

#: ../../language/methods.md:301
msgid ""
"struct T {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare, Show, Default)\n"
"\n"
"test {\n"
"  let t1 = T::default()\n"
"  let t2 = T::{ x: 1, y: 1 }\n"
"  inspect!(t1, content=\"{x: 0, y: 0}\")\n"
"  inspect!(t2, content=\"{x: 1, y: 1}\")\n"
"  assert_not_eq!(t1, t2)\n"
"  assert_true!(t1 < t2)\n"
"}\n"
msgstr ""

#: ../../language/packages.md:1
msgid "Managing Projects with Packages"
msgstr ""

#: ../../language/packages.md:3
msgid ""
"When developing projects at large scale, the project usually needs to be "
"divided into smaller modular unit that depends on each other.  More "
"often, it involves using other people's work: most noticeably is the "
"[core](https://github.com/moonbitlang/core), the standard library of "
"MoonBit."
msgstr ""

#: ../../language/packages.md:6
msgid "Packages and modules"
msgstr ""

#: ../../language/packages.md:8
msgid ""
"In MoonBit, the most important unit for code organization is a package, "
"which consists of a number of source code files and a single "
"`moon.pkg.json` configuration file. A package can either be a `main` "
"package, consisting a `main` function, or a package that serves as a "
"library."
msgstr ""

#: ../../language/packages.md:11
msgid ""
"A project, corresponding to a module, consists of multiple packages and a"
" single `moon.mod.json` configuration file."
msgstr ""

#: ../../language/packages.md:13
msgid ""
"When using things from another package, the dependency between modules "
"should first be declared inside the `moon.mod.json`. The dependency "
"between packages should then be declared inside the `moon.pkg.json`. Then"
" it is possible to use `@pkg` to access the imported entities, where "
"`pkg` is the last part of the imported package's path or the declared "
"alias in `moon.pkg.json`:"
msgstr ""

#: ../../language/packages.md:17
msgid "pkgB/moon.pkg.json"
msgstr ""

#: ../../language/packages.md:17
msgid ""
"{\n"
"    \"import\": [\n"
"        \"moonbit-community/language/packages/pkgA\"\n"
"    ]\n"
"}"
msgstr ""

#: ../../language/packages.md:22
msgid "pkgB/top.mbt"
msgstr ""

#: ../../language/packages.md:22
msgid ""
"pub fn add1(x : Int) -> Int {\n"
"  @pkgA.incr(x)\n"
"}"
msgstr ""

#: ../../language/packages.md:27
msgid "Access Control"
msgstr ""

#: ../../language/packages.md:29
msgid ""
"By default, all function definitions and variable bindings are "
"_invisible_ to other packages. You can use the `pub` modifier before "
"toplevel `let`/`fn` to make them public."
msgstr ""

#: ../../language/packages.md:32
msgid "There are four different kinds of visibility for types in MoonBit:"
msgstr ""

#: ../../language/packages.md:34
msgid ""
"private type, declared with `priv`, completely invisible to the outside "
"world"
msgstr ""

#: ../../language/packages.md:35
msgid ""
"abstract type, which is the default visibility for types. Only the name "
"of an abstract type is visible outside, the internal representation of "
"the type is hidden"
msgstr ""

#: ../../language/packages.md:36
msgid ""
"readonly types, declared with `pub(readonly)`. The internal "
"representation of readonly types are visible outside, but users can only "
"read the values of these types from outside, construction and mutation "
"are not allowed"
msgstr ""

#: ../../language/packages.md:38
msgid ""
"fully public types, declared with `pub(all)`. The outside world can "
"freely construct, modify and read values of these types"
msgstr ""

#: ../../language/packages.md:41
msgid ""
"Currently, the semantic of `pub` is `pub(all)`. But in the future, the "
"meaning of `pub` will be ported to `pub(readonly)`."
msgstr ""

#: ../../language/packages.md:44
msgid ""
"In addition to the visibility of the type itself, the fields of a public "
"`struct` can be annotated with `priv`, which will hide the field from the"
" outside world completely. Note that `struct`s with private fields cannot"
" be constructed directly outside, but you can update the public fields "
"using the functional struct update syntax."
msgstr ""

#: ../../language/packages.md:49
msgid ""
"Readonly types is a very useful feature, inspired by [private "
"types](https://v2.ocaml.org/manual/privatetypes.html) in OCaml. In short,"
" values of `pub(readonly)` types can be destructed by pattern matching "
"and the dot syntax, but cannot be constructed or mutated in other "
"packages. Note that there is no restriction within the same package where"
" `pub(readonly)` types are defined."
msgstr ""

#: ../../language/packages.md:53
msgid ""
"// Package A\n"
"pub(readonly) struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // OK\n"
"  let r = { ..r, field: 8 }  // OK\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // OK\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public"
" read-only type RO!\n"
"  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only "
"field!\n"
"}\n"
msgstr ""

#: ../../language/packages.md:75
msgid ""
"Access control in MoonBit adheres to the principle that a `pub` type, "
"function, or variable cannot be defined in terms of a private type. This "
"is because the private type may not be accessible everywhere that the "
"`pub` entity is used. MoonBit incorporates sanity checks to prevent the "
"occurrence of use cases that violate this principle."
msgstr ""

#: ../../language/packages.md:78
msgid ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // OK\n"
"  y: T2  // OK\n"
"  z: T3  // ERROR: public field has private type `T3`!\n"
"}\n"
"\n"
"// ERROR: public function has private parameter type `T3`!\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// ERROR: public function has private return type `T3`!\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// OK\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // ERROR: public variable has private type `T3`!\n"
msgstr ""

#: ../../language/packages.md:99
msgid "Access control of methods and trait implementations"
msgstr ""

#: ../../language/packages.md:101
msgid ""
"To make the trait system coherent (i.e. there is a globally unique "
"implementation for every `Type: Trait` pair), and prevent third-party "
"packages from modifying behavior of existing programs by accident, "
"MoonBit employs the following restrictions on who can define "
"methods/implement traits for types:"
msgstr ""

#: ../../language/packages.md:105
msgid ""
"_only the package that defines a type can define methods for it_. So one "
"cannot define new methods or override old methods for builtin and foreign"
" types."
msgstr ""

#: ../../language/packages.md:106
msgid ""
"_only the package of the type or the package of the trait can define an "
"implementation_. For example, only `@pkg1` and `@pkg2` are allowed to "
"write `impl @pkg1.Trait for @pkg2.Type`."
msgstr ""

#: ../../language/packages.md:109
msgid ""
"The second rule above allows one to add new functionality to a foreign "
"type by defining a new trait and implementing it. This makes MoonBit's "
"trait & method system flexible while enjoying good coherence property."
msgstr ""

#: ../../language/packages.md:112
msgid "Visibility of traits and sealed traits"
msgstr ""

#: ../../language/packages.md:113
msgid ""
"There are four visibility for traits, just like `struct` and `enum`: "
"private, abstract, readonly and fully public. Private traits are declared"
" with `priv trait`, and they are completely invisible from outside. "
"Abstract trait is the default visibility. Only the name of the trait is "
"visible from outside, and the methods in the trait are not exposed. "
"Readonly traits are declared with `pub(readonly) trait`, their methods "
"can be involked from outside, but only the current package can add new "
"implementation for readonly traits. Finally, fully public traits are "
"declared with `pub(open) trait`, they are open to new implementations "
"outside current package, and their methods can be freely used."
msgstr ""

#: ../../language/packages.md:120
msgid ""
"Currently, `pub trait` defaults to `pub(open) trait`. But in the future, "
"the semantic of `pub trait` will be ported to `pub(readonly)`."
msgstr ""

#: ../../language/packages.md:123
msgid ""
"Abstract and readonly traits are sealed, because only the package "
"defining the trait can implement them. Implementing a sealed (abstract or"
" readonly) trait outside its package result in compiler error. If you are"
" the owner of a sealed trait, and you want to make some implementation "
"available to users of your package, make sure there is at least one "
"declaration of the form `impl Trait for Type with ...` in your package. "
"Implementations with only regular method and default implementations will"
" not be available outside."
msgstr ""

#: ../../language/packages.md:129
msgid "Here's an example of abstract trait:"
msgstr ""

#: ../../language/packages.md:132
msgid ""
"trait Number {\n"
" op_add(Self, Self) -> Self\n"
" op_sub(Self, Self) -> Self\n"
"}\n"
"\n"
"fn add[N : Number](x : N, y: N) -> N {\n"
"  Number::op_add(x, y)\n"
"}\n"
"\n"
"fn sub[N : Number](x : N, y: N) -> N {\n"
"  Number::op_sub(x, y)\n"
"}\n"
"\n"
"impl Number for Int with op_add(x, y) { x + y }\n"
"impl Number for Int with op_sub(x, y) { x - y }\n"
"\n"
"impl Number for Double with op_add(x, y) { x + y }\n"
"impl Number for Double with op_sub(x, y) { x - y }\n"
msgstr ""

#: ../../language/packages.md:153
msgid "From outside this package, users can only see the following:"
msgstr ""

#: ../../language/packages.md:155
msgid ""
"trait Number\n"
"\n"
"fn op_add[N : Number](x : N, y : N) -> N\n"
"fn op_sub[N : Number](x : N, y : N) -> N\n"
"\n"
"impl Number for Int\n"
"impl Number for Double\n"
msgstr ""

#: ../../language/packages.md:165
msgid ""
"The author of `Number` can make use of the fact that only `Int` and "
"`Double` can ever implement `Number`, because new implementations are not"
" allowed outside."
msgstr ""

#: ../../language/tests.md:1
msgid "Writing Tests"
msgstr ""

#: ../../language/tests.md:3
msgid ""
"Tests are important for improving quality and maintainability of a "
"program. They verify the behavior of a program and also serves as a "
"specification to avoid regressions over time."
msgstr ""

#: ../../language/tests.md:5
msgid "MoonBit comes with test support to make the writing easier and simpler."
msgstr ""

#: ../../language/tests.md:7
msgid "Test Blocks"
msgstr ""

#: ../../language/tests.md:9
msgid ""
"MoonBit provides the test code block for writing inline test cases. For "
"example:"
msgstr ""

#: ../../language/tests.md:17
msgid ""
"A test code block is essentially a function that returns a `Unit` but may"
" throws a `String` on error, or `Unit!String` as one would see in its "
"signature at the position of return type. It is called during the "
"execution of `moon test` and outputs a test report through the build "
"system. The `assert_eq` function is from the standard library; if the "
"assertion fails, it prints an error message and terminates the test. The "
"string `\"test_name\"` is used to identify the test case and is optional."
msgstr ""

#: ../../language/tests.md:19
msgid ""
"If a test name starts with `\"panic\"`, it indicates that the expected "
"behavior of the test is to trigger a panic, and the test will only pass "
"if the panic is triggered. For example:"
msgstr ""

#: ../../language/tests.md:21
msgid ""
"test \"panic_test\" {\n"
"  let _ : Int = Option::None.unwrap()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/tests.md:27
msgid "Snapshot Tests"
msgstr ""

#: ../../language/tests.md:29
msgid ""
"Writing tests can be tedious when specifying the expected values. Thus, "
"MoonBit provides three kinds of snapshot tests. All of which can be "
"inserted or updated automatically using `moon test --update`."
msgstr ""

#: ../../language/tests.md:32
msgid "Snapshotting `Show`"
msgstr ""

#: ../../language/tests.md:34
msgid ""
"We can use `inspect!(x, content=\"x\")` to inspect anything that "
"implements `Show` trait.  As we mentioned before, `Show` is a builtin "
"trait that can be derived, providing `to_string` that will print the "
"content of the data structures.  The labelled argument `content` can be "
"omitted as `moon test --update` will insert it for you:"
msgstr ""

#: ../../language/tests.md:38
msgid ""
"struct X { x : Int } derive(Show)\n"
"\n"
"test \"show snapshot test\" {\n"
"  inspect!({x: 10}, content=\"{x: 10}\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:44
msgid "Snapshotting `JSON`"
msgstr ""

#: ../../language/tests.md:46
msgid ""
"The problem with the derived `Show` trait is that it does not perform "
"pretty printing, resulting in extremely long output."
msgstr ""

#: ../../language/tests.md:48
msgid ""
"The solution is to use `@json.inspect!(x, content=x)`. The benefit is "
"that the resulting content is a JSON structure, which can be more "
"readable after being formatted."
msgstr ""

#: ../../language/tests.md:50
msgid ""
"enum Rec {\n"
"  End\n"
"  Really_long_name_that_is_difficult_to_read(Rec)\n"
"} derive(Show, ToJson)\n"
"\n"
"test \"json snapshot test\" {\n"
"  let r = Really_long_name_that_is_difficult_to_read(\n"
"    Really_long_name_that_is_difficult_to_read(\n"
"      Really_long_name_that_is_difficult_to_read(End),\n"
"    ),\n"
"  )\n"
"  inspect!(\n"
"    r,\n"
"    "
"content=\"Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(End)))\","
"\n"
"  )\n"
"  @json.inspect!(\n"
"    r,\n"
"    content={\n"
"      \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"      \"0\": {\n"
"        \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"        \"0\": {\n"
"          \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"          \"0\": { \"$tag\": \"End\" },\n"
"        },\n"
"      },\n"
"    },\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/tests.md:56
msgid ""
"One can also implement a custom `ToJson` to keep only the essential "
"information."
msgstr ""

#: ../../language/tests.md:58
msgid "Snapshotting Anything"
msgstr ""

#: ../../language/tests.md:60
msgid ""
"Still, sometimes we want to not only record one data structure but the "
"output of a whole process."
msgstr ""

#: ../../language/tests.md:62
msgid ""
"A full snapshot test can be used to record anything using "
"`@test.T::write` and `@test.T::writeln`:"
msgstr ""

#: ../../language/tests.md:64
msgid ""
"test \"record anything\" (t : @test.T) {\n"
"  t.write(\"Hello, world!\")\n"
"  t.writeln(\" And hello, MoonBit!\")\n"
"  t.snapshot!(filename=\"record_anything.txt\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:70
msgid ""
"This will create a file under `__snapshot__` of that package with the "
"given filename:"
msgstr ""

#: ../../language/tests.md:72
msgid "Hello, world! And hello, MoonBit!\n"
msgstr ""

#: ../../language/tests.md:75
msgid ""
"This can also be used for applications to test the generated output, "
"whether it were creating an image, a video or some custom data."
msgstr ""

#: ../../language/tests.md:77
msgid "BlackBox Tests and WhiteBox Tests"
msgstr ""

#: ../../language/tests.md:79
msgid ""
"When developing libraries, it is important to verify if the user can use "
"it correctly. For example, one may forget to make a type or a function "
"public. That's why MoonBit provides BlackBox tests, allowing developers "
"to have a grasp of how others are feeling."
msgstr ""

#: ../../language/tests.md:81
msgid ""
"A test that has access to all the members in a package is called a "
"WhiteBox tests as we can see everything. Such tests can be defined inline"
" or defined in a file whose name ends with `_wbtest.mbt`."
msgstr ""

#: ../../language/tests.md:83
msgid ""
"A test that has access only to the public members in a package is called "
"a BlackBox tests. Such tests need to be defined in a file whose name ends"
" with `_test.mbt`."
msgstr ""

#: ../../language/tests.md:85
msgid ""
"The WhiteBox test files (`_wbtest.mbt`) imports the packages defined in "
"the `import` and `wbtest-import` sections of the package configuration "
"(`moon.pkg.json`).  The BlackBox test files (`_test.mbt`) imports the "
"current package and the packages defined in the `import` and `test-"
"import` sections of the package configuration (`moon.pkg.json`)."
msgstr ""
