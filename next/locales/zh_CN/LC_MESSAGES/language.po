# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit Document
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
msgid ""
msgstr ""
"Project-Id-Version: MoonBit Document \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-18 17:03+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/async-experimental.md:1
msgid "Experimental async programming support"
msgstr "实验性的异步编程支持"

#: ../../language/async-experimental.md:3
msgid ""
"MoonBit is providing experimental support for async programming. But the "
"design and API is still highly unstable, and may receive big breaking "
"change in the future. This page documents the current design, and we "
"highly appreciate any feedback or experiment with current design."
msgstr ""
"MoonBit 目前提供了实验性的异步编程支持。但异步相关功能的设计和 API 非常不稳定，未来可能会有大的破坏性改动。本文档页面将介绍 "
"MoonBit 异步编程目前的设计，我们欢迎及感谢任何对目前设计的反馈与使用体验分享。"

#: ../../language/async-experimental.md:7
msgid "Async function"
msgstr "异步函数"

#: ../../language/async-experimental.md:8
msgid "Async functions can be declared with the `async` keyword:"
msgstr "异步函数可以用 `async` 关键字声明："

#: ../../language/async-experimental.md:10
msgid ""
"async fn my_async_function() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"// anonymous/local function\n"
"test {\n"
"  let async_lambda = async fn () {\n"
"    ...\n"
"  }\n"
"  async fn local_async_function() {\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""
"async fn my_async_function() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"// 匿名/本地函数\n"
"test {\n"
"  let async_lambda = async fn () {\n"
"    ...\n"
"  }\n"
"  async fn local_async_function() {\n"
"    ...\n"
"  }\n"
"}\n"

#: ../../language/async-experimental.md:16
msgid "Async functions must be called with the `!!` operator:"
msgstr "调用异步函数时，必须用 `!!` 操作符来标记这是一次异步函数调用："

#: ../../language/async-experimental.md:18
msgid ""
"async fn some_async_function() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"async fn another_async_function() -> Unit! {\n"
"  // error will be rethrowed by `!!`\n"
"  some_async_function!!()\n"
"}\n"
msgstr ""
"async fn some_async_function() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"async fn another_async_function() -> Unit! {\n"
"  // 异步函数中的错误也会被 `!!` 转发\n"
"  some_async_function!!()\n"
"}\n"

#: ../../language/async-experimental.md:24
msgid "If the async function may throw error, `!!` will also rethrow the error."
msgstr "如果异步函数会抛出错误，`!!` 也会把错误一并转发。"

#: ../../language/async-experimental.md:26
msgid ""
"Async functions can only be called in async functions. Currently, async "
"functions cannot be called in the body of `for .. in` loops."
msgstr "异步函数只能在其他异步函数中被调用。目前，在 `for .. in` 循环中不能使用异步函数。"

#: ../../language/async-experimental.md:28
msgid "Async primitives for suspension"
msgstr "用于中断异步函数的原语"

#: ../../language/async-experimental.md:29
msgid ""
"MoonBit provides two core primitives for `%async.suspend` and "
"`%async.run`:"
msgstr "MoonBit 提供了两个用于异步编程的原语：`%async.suspend` 和 `%async.run`："

#: ../../language/async-experimental.md:31
msgid ""
"\n"
"// `run_async` spawn a new coroutine and execute an async function in it\n"
"fn run_async(f : async () -> Unit) -> Unit = \"%async.run\"\n"
"\n"
"// `suspend` will suspend the execution of the current coroutine.\n"
"// The suspension will be handled by a callback passed to `suspend`\n"
"async fn suspend[T, E : Error](\n"
"  // `f` is a callback for handling suspension\n"
"  f : (\n"
"    // the first parameter of `f` is used to resume the execution of the "
"coroutine normally\n"
"    (T) -> Unit,\n"
"    // the second parameter of `f` is used to cancel the execution of the"
" current coroutine\n"
"    // by throwing an error at suspension point\n"
"    (E) -> Unit\n"
"  ) -> Unit\n"
") -> T!E = \"%async.suspend\"\n"
msgstr ""
"\n"
"// `run_async` 会创建一个新的协程，并在其中运行一个异步函数\n"
"fn run_async(f : async () -> Unit) -> Unit = \"%async.run\"\n"
"\n"
"// `suspend` 会中断当前协程的运行。\n"
"// `suspend` 会接受一个回调函数，并让这个回调函数来操作中断的协程\n"
"async fn suspend[T, E : Error](\n"
"  // `f` 是负责操作中断的协程的回调函数\n"
"  f : (\n"
"    // `f` 的第一个参数用于继续运行被中断的协程\n"
"    (T) -> Unit,\n"
"    // `f` 的第二个参数用于取消被中断的协程。\n"
"    // 取消会被表示为在中断处抛出错误\n"
"    (E) -> Unit\n"
"  ) -> Unit\n"
") -> T!E = \"%async.suspend\"\n"

#: ../../language/async-experimental.md:37
msgid ""
"There two primitives are not intended for direct use by end users. "
"However, since MoonBit's standard library for async programming is still "
"under development, currently users need to bind these two primitives "
"manually to do async programming."
msgstr "这两个原语不应该让终端用户直接调用。但由于 MoonBit 的异步标准库仍在开发中，目前，用户需要手动绑定这两个原语，才能编写异步程序。"

#: ../../language/async-experimental.md:41
msgid "There are two ways of reading these primitives:"
msgstr "可以用两种不同的方式来理解这两个原语："

#: ../../language/async-experimental.md:43
msgid ""
"the coroutine reading: `%async.run` spawn a new coroutine, and "
"`%async.suspend` suspend current coroutine. The main difference with "
"other languages here is: instead of yielding all the way to the caller of"
" `%async.run`, resumption of the coroutine is handled by the callback "
"passed to `%async.suspend`"
msgstr ""
"理解为协程：`%async.run` 创建一个新的协程，`%async.suspend` "
"中断当前协程。和其他语言的协程的主要区别是：中断协程时，不是由创建协程的地方来负责恢复执行，而是在中断的地方通过一个回调函数就地处理中断后的协程"

#: ../../language/async-experimental.md:48
msgid ""
"the delimited continuation reading: `%async.run` is the `reset` operator "
"in delimited continuation, and `%async.suspend` is the `shift` operator "
"in delimited continuation"
msgstr ""
"理解为 delimited continuation：`%async.run` 是 delimited continuation 中的 "
"`reset` 操作符，`%async.suspend` 是 delimited continuation `shift` 操作符"

#: ../../language/async-experimental.md:51
msgid "Here's an example of how these two primitives work:"
msgstr "以下是使用这两个原语的示例："

#: ../../language/async-experimental.md:53
msgid ""
"type! MyError derive(Show)\n"
"\n"
"async fn async_worker(throw_error~ : Bool) -> Unit!MyError {\n"
"  suspend!!(fn (resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      println(\"the end of the coroutine\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"// the program below should print:\n"
"//\n"
"//   the worker finishes\n"
"//   the end of the coroutine\n"
"//   after the first coroutine finishes\n"
"//   caught MyError\n"
"test {\n"
"  // when supplying an anonymous function\n"
"  // to a higher order function that expects async parameter,\n"
"  // the `async` keyword can be omitted\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=false)\n"
"      println(\"the worker finishes\")\n"
"    } catch {\n"
"      err => println(\"caught: \\{err}\")\n"
"    }\n"
"  })\n"
"  println(\"after the first coroutine finishes\")\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=true)\n"
"      println(\"the worker finishes\")\n"
"    } catch {\n"
"      err => println(\"caught: \\{err}\")\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""
"type! MyError derive(Show)\n"
"\n"
"async fn async_worker(throw_error~ : Bool) -> Unit!MyError {\n"
"  suspend!!(fn (resume_ok, resume_err) {\n"
"    if throw_error {\n"
"      resume_err(MyError)\n"
"    } else {\n"
"      resume_ok(())\n"
"      println(\"协程结束运行\")\n"
"    }\n"
"  })\n"
"}\n"
"\n"
"// 下面这段程序应当输出：\n"
"//\n"
"//   worker 函数返回了\n"
"//   协程结束运行\n"
"//   协程结束之后\n"
"//   捕获到了 MyError\n"
"test {\n"
"  // 在调用一个需要异步参数的高阶函数时，\n"
"  // 如果参数是一个匿名函数，可以省略 `async` 关键字\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=false)\n"
"      println(\"worker 函数返回了\")\n"
"    } catch {\n"
"      err => println(\"捕获到了 \\{err}\")\n"
"    }\n"
"  })\n"
"  println(\"第一个协程结束之后\")\n"
"  run_async(fn () {\n"
"    try {\n"
"      async_worker!!(throw_error=true)\n"
"      println(\"worker 函数返回了\")\n"
"    } catch {\n"
"      err => println(\"捕获到了 \\{err}\")\n"
"    }\n"
"  })\n"
"}\n"

#: ../../language/async-experimental.md:59
msgid ""
"In `async_worker`, `suspend` will capture the rest of the current "
"coroutine as two \"continuation\" functions, and pass them to a callback."
" In the callback, calling `resume_ok` will resume execution at the point "
"of `suspend!!(...)`, all the way until the `run_async` call that start "
"this coroutine. calling `resume_err` will also resume execution of "
"current coroutine, but it will make `suspend!!(...)` throw an error "
"instead of returning normally."
msgstr ""
"在 `async_worker` 里，`suspend` 会捕获当前协程剩下的部分，并将它们表示成两个函数，传递给 `suspend` 的参数。在"
" `suspend` 的参数里，调用 `resume_ok` 会让 `suspend!!(...)` "
"正常返回，恢复协程的运行，一直运行到创建这个协程的 `run_async(...)` 为止。调用 `resume_err` "
"也会恢复协程的运行，但它会在 `suspend!!(...)` 的位置抛出一个错误。"

#: ../../language/async-experimental.md:65
msgid ""
"Notice that `suspend` type may throw error, even if `suspend` itself "
"never throw an error directly. This design makes coroutines cancellable "
"at every `suspend` call: just call the corresponding `resume_err` "
"callback."
msgstr ""
"`suspend` 的类型表明它可能抛出错误。但 `suspend` "
"自身不会直接产生任何错误。这一设计保证了协程在每一个的中断点都是可以取消的：调用对应的 `resume_err` 函数即可。"

#: ../../language/async-experimental.md:68
msgid "Integrating with JS Promise/callback based API"
msgstr "和 JS 的 Promise/回调 API 整合"

#: ../../language/async-experimental.md:69
msgid ""
"Since MoonBit's standard async library is still under development, so "
"there is no ready-to-use implementation for event loop and IO operations "
"yet. So the easiest way to write some async program is to use MoonBit's "
"Javascript backend, and reuse the event loop and IO operations of "
"Javascript. Here's an example of integrating MoonBit's async programming "
"support with JS's callback based API:"
msgstr ""
"MoonBit 的异步标准库仍在开发中，因此，目前没有直接可用的事件循环和输入输出原语实现。目前，要使用 MoonBit "
"编写异步程序最简单的办法是使用 JS 后端，并复用 JavaScript 的事件循环和输入输出 API。下面是一个整合 MoonBit "
"的异步编程支持和 JS 的回调 API 的例子："

#: ../../language/async-experimental.md:75
msgid ""
"type JSTimer\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration : Int) -> "
"JSTimer =\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"async fn sleep(duration : Int) -> Unit! {\n"
"  suspend!!(fn (resume_ok, _resume_err) {\n"
"    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)\n"
"  })\n"
"}\n"
"\n"
"test {\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"}\n"
msgstr ""
"type JSTimer\n"
"extern \"js\" fn js_set_timeout(f : () -> Unit, duration : Int) -> "
"JSTimer =\n"
"  #| (f, duration) => setTimeout(f, duration)\n"
"\n"
"async fn sleep(duration : Int) -> Unit! {\n"
"  suspend!!(fn (resume_ok, _resume_err) {\n"
"    let _ = js_set_timeout(fn () { resume_ok(()) }, duration)\n"
"  })\n"
"}\n"
"\n"
"test {\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(500)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1000)\n"
"      println(\"timer 1 tick\")\n"
"      sleep!!(1500)\n"
"      println(\"timer 1 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"  run_async(fn () {\n"
"    try {\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"      sleep!!(600)\n"
"      println(\"timer 2 tick\")\n"
"    } catch { _ => panic() }\n"
"  })\n"
"}\n"

#: ../../language/async-experimental.md:81
msgid ""
"Integrating with JS Promise is easy too: just pass `resume_ok` as the "
"`resolve` callback and `resume_err` as the `reject` callback to a JS "
"promise."
msgstr ""
"和 JS Promise 也非常简单：只需要把 `resume_ok` 函数用作 `Promise` 的 `resolve` 把 "
"`resume_err` 用作 Promise 的 `reject` 回调即可。"

#: ../../language/derive.md:1
msgid "Deriving traits"
msgstr "派生内建特征"

#: ../../language/derive.md:3
msgid ""
"MoonBit supports deriving a number of builtin traits automatically from "
"the type definition."
msgstr "MoonBit 支持从类型定义中自动派生一些内建特征。"

#: ../../language/derive.md:5
msgid ""
"To derive a trait `T`, it is required that all fields used in the type "
"implements `T`. For example, deriving `Show` for a struct `struct A { x: "
"T1; y: T2 }` requires both `T1: Show` and `T2: Show`"
msgstr ""
"要派生特征 `T`，需要类型中使用的所有字段都实现了 `T`。例如，为结构体 `struct A { x: T1; y: T2 }` 派生 "
"`Show` 需要 `T1: Show` 和 `T2: Show`。"

#: ../../language/derive.md:8
msgid "Show"
msgstr "输出"

#: ../../language/derive.md:10
msgid ""
"`derive(Show)` will generate a pretty-printing method for the type. The "
"derived format is similar to how the type can be constructed in code."
msgstr "`derive(Show)` 将为类型生成一个漂亮的打印方法。派生的格式类似于代码中构造类型的方式。"

#: ../../language/derive.md:13
msgid ""
"struct MyStruct {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Show)\n"
"\n"
"test \"derive show struct\" {\n"
"  let p = MyStruct::{ x: 1, y: 2 }\n"
"  assert_eq!(Show::to_string(p), \"{x: 1, y: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/derive.md:19
msgid ""
"enum MyEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Show)\n"
"\n"
"test \"derive show enum\" {\n"
"  assert_eq!(Show::to_string(MyEnum::Case1(42)), \"Case1(42)\")\n"
"  assert_eq!(Show::to_string(MyEnum::Case2(label=\"hello\")), "
"\"Case2(label=\\\"hello\\\")\")\n"
"  assert_eq!(Show::to_string(MyEnum::Case3), \"Case3\")\n"
"}\n"
msgstr ""

#: ../../language/derive.md:25
msgid "Eq and Compare"
msgstr "相等和比较"

#: ../../language/derive.md:27
msgid ""
"`derive(Eq)` and `derive(Compare)` will generate the corresponding method"
" for testing equality and comparison. Fields are compared in the same "
"order as their definitions. For enums, the order between cases ascends in"
" the order of definition."
msgstr ""
"`derive(Eq)` 和 `derive(Compare)` "
"将为测试相等性和比较生成相应的方法。字段按照它们的定义顺序进行比较。对于枚举，构造器的顺序按照定义的顺序升序。"

#: ../../language/derive.md:31
msgid ""
"struct DeriveEqCompare {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare)\n"
"\n"
"test \"derive eq_compare struct\" {\n"
"  let p1 = DeriveEqCompare::{ x: 1, y: 2 }\n"
"  let p2 = DeriveEqCompare::{ x: 2, y: 1 }\n"
"  let p3 = DeriveEqCompare::{ x: 1, y: 2 }\n"
"  let p4 = DeriveEqCompare::{ x: 1, y: 3 }\n"
"\n"
"  // Eq\n"
"  assert_eq!(p1 == p2, false)\n"
"  assert_eq!(p1 == p3, true)\n"
"  assert_eq!(p1 == p4, false)\n"
"\n"
"  assert_eq!(p1 != p2, true)\n"
"  assert_eq!(p1 != p3, false)\n"
"  assert_eq!(p1 != p4, true)\n"
"  \n"
"  // Compare\n"
"  assert_eq!(p1 < p2, true)\n"
"  assert_eq!(p1 < p3, false)\n"
"  assert_eq!(p1 < p4, true)\n"
"  assert_eq!(p1 > p2, false)\n"
"  assert_eq!(p1 > p3, false)\n"
"  assert_eq!(p1 > p4, false)\n"
"  assert_eq!(p1 <= p2, true)\n"
"  assert_eq!(p1 >= p2, false)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:37
msgid ""
"enum DeriveEqCompareEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Eq, Compare)\n"
"\n"
"test \"derive eq_compare enum\" {\n"
"  let p1 = DeriveEqCompareEnum::Case1(42)\n"
"  let p2 = DeriveEqCompareEnum::Case1(43)\n"
"  let p3 = DeriveEqCompareEnum::Case1(42)\n"
"  let p4 = DeriveEqCompareEnum::Case2(label=\"hello\")\n"
"  let p5 = DeriveEqCompareEnum::Case2(label=\"world\")\n"
"  let p6 = DeriveEqCompareEnum::Case2(label=\"hello\")\n"
"  let p7 = DeriveEqCompareEnum::Case3\n"
"\n"
"  // Eq\n"
"  assert_eq!(p1 == p2, false)\n"
"  assert_eq!(p1 == p3, true)\n"
"  assert_eq!(p1 == p4, false)\n"
"\n"
"  assert_eq!(p1 != p2, true)\n"
"  assert_eq!(p1 != p3, false)\n"
"  assert_eq!(p1 != p4, true)\n"
"\n"
"  // Compare\n"
"  assert_eq!(p1 < p2, true) // 42 < 43\n"
"  assert_eq!(p1 < p3, false)\n"
"  assert_eq!(p1 < p4, true) // Case1 < Case2\n"
"  assert_eq!(p4 < p5, true)\n"
"  assert_eq!(p4 < p6, false)\n"
"  assert_eq!(p4 < p7, true) // Case2 < Case3\n"
"}\n"
msgstr ""

#: ../../language/derive.md:43
msgid "Default"
msgstr "默认值"

#: ../../language/derive.md:45
msgid ""
"`derive(Default)` will generate a method that returns the default value "
"of the type."
msgstr "`derive(Default)` 将生成一个返回类型的默认值的方法。"

#: ../../language/derive.md:47
msgid ""
"For structs, the default value is the struct with all fields set as their"
" default value."
msgstr "对于结构体，默认值是所有字段设置为它们的默认值的结构体。"

#: ../../language/derive.md:49
msgid ""
"struct DeriveDefault {\n"
"  x : Int\n"
"  y : Option[String]\n"
"} derive(Default, Eq, Show)\n"
"\n"
"test \"derive default struct\" {\n"
"  let p = DeriveDefault::default()\n"
"  assert_eq!(p, DeriveDefault::{ x: 0, y: None })\n"
"}\n"
msgstr ""

#: ../../language/derive.md:55
msgid "For enums, the default value is the only case that has no parameters."
msgstr "对于枚举，默认值是唯一没有参数的构造器。"

#: ../../language/derive.md:57
msgid ""
"enum DeriveDefaultEnum {\n"
"  Case1(Int)\n"
"  Case2(label~ : String)\n"
"  Case3\n"
"} derive(Default, Eq, Show)\n"
"\n"
"test \"derive default enum\" {\n"
"  assert_eq!(DeriveDefaultEnum::default(), DeriveDefaultEnum::Case3)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:63
msgid ""
"Enums that has no cases or more than one cases without parameters cannot "
"derive `Default`."
msgstr "没有构造器或有多个没有参数的构造器的枚举不能派生 `Default`。"

#: ../../language/derive.md:67
msgid ""
"enum CannotDerive1 {\n"
"    Case1(String)\n"
"    Case2(Int)\n"
"} derive(Default) // cannot find a constant constructor as default\n"
"\n"
"enum CannotDerive2 {\n"
"    Case1\n"
"    Case2\n"
"} derive(Default) // Case1 and Case2 are both candidates as default "
"constructor\n"
msgstr ""

#: ../../language/derive.md:79
msgid "Hash"
msgstr "哈希值"

#: ../../language/derive.md:81
msgid ""
"`derive(Hash)` will generate a hash implementation for the type. This "
"will allow the type to be used in places that expects a `Hash` "
"implementation, for example `HashMap`s and `HashSet`s."
msgstr ""
"`derive(Hash)` 将为类型生成一个哈希实现。这将允许类型在期望 `Hash` 实现的地方使用，例如 `HashMap` 和 "
"`HashSet`。"

#: ../../language/derive.md:85
msgid ""
"struct DeriveHash {\n"
"  x : Int\n"
"  y : Option[String]\n"
"} derive(Hash, Eq, Show)\n"
"\n"
"test \"derive hash struct\" {\n"
"  let hs = @hashset.new()\n"
"  hs.add(DeriveHash::{x: 123, y: None})\n"
"  hs.add(DeriveHash::{x: 123, y: None})\n"
"  assert_eq!(hs.size(), 1)\n"
"  hs.add(DeriveHash::{x: 123, y: Some(\"456\")})\n"
"  assert_eq!(hs.size(), 2)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:91
msgid "Arbitrary"
msgstr "任意值"

#: ../../language/derive.md:93
msgid "`derive(Arbitrary)` will generate random values of the given type."
msgstr "`derive(Arbitrary)` 将生成给定类型的随机值。"

#: ../../language/derive.md:95
msgid "FromJson and ToJson"
msgstr "从/到 Json"

#: ../../language/derive.md:97
msgid ""
"`derive(FromJson)` and `derive(ToJson)` will generate methods that "
"deserializes/serializes the given type from/to JSON files "
"correspondingly."
msgstr "`derive(FromJson)` 和 `derive(ToJson)` 将分别生成从/到 JSON 文件反序列化/序列化给定类型的方法。"

#: ../../language/derive.md:100
msgid ""
"struct JsonTest1 {\n"
"  x: Int\n"
"  y: Int\n"
"} derive(FromJson, ToJson, Eq, Show)\n"
"\n"
"enum JsonTest2 {\n"
"  A(x~: Int)\n"
"  B(x~: Int, y~: Int)\n"
"} derive(FromJson, ToJson, Eq, Show)\n"
"\n"
"test \"json basic\"{\n"
"  let input = JsonTest1::{ x: 123, y: 456 }\n"
"  let expected: Json = { \"x\": 123, \"y\": 456 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"\n"
"  let input = JsonTest2::A(x=123)\n"
"  let expected: Json = { \"$tag\": \"A\", \"x\": 123 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:106
msgid ""
"Both derive directives accept a number of arguments to configure the "
"exact behavior of serialization and deserialization."
msgstr "这两个派生指令都接受一些参数来配置序列化和反序列化的确切行为。"

#: ../../language/derive.md:109
msgid "The actual behavior of JSON serialization arguments is unstable."
msgstr "JSON 序列化参数的实际行为是不稳定的。"

#: ../../language/derive.md:112
msgid ""
"struct JsonTest3 {\n"
"  x: Int\n"
"  y: Int\n"
"} derive(\n"
"  FromJson(fields(x(rename = \"renamedX\"))), \n"
"  ToJson(fields(x(rename = \"renamedX\"))),\n"
"  Eq, Show\n"
")\n"
"\n"
"enum JsonTest4 {\n"
"  A(x~: Int)\n"
"  B(x~: Int, y~: Int)\n"
"} derive(\n"
"  FromJson(rename_fields = \"SCREAMING_SNAKE_CASE\", repr(ext_tagged)),\n"
"  ToJson(rename_fields = \"SCREAMING_SNAKE_CASE\", repr(ext_tagged)),\n"
"  Eq, Show\n"
")\n"
"\n"
"test \"json args\"{\n"
"  let input = JsonTest3::{ x: 123, y: 456 }\n"
"  let expected: Json = { \"renamedX\": 123, \"y\": 456 }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"\n"
"  let input = JsonTest4::A(x=123)\n"
"  let expected: Json = { \"A\": { \"X\": 123 } }\n"
"  assert_eq!(input.to_json(), expected)\n"
"  assert_eq!(@json.from_json!(expected), input)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:118
msgid "Enum representations"
msgstr "枚举表示"

#: ../../language/derive.md:120
msgid ""
"Enums can be represented in JSON in a number of styles. There are two "
"aspects of the representation:"
msgstr "枚举表示为 JSON 有多种风格。表示有两个方面："

#: ../../language/derive.md:123
msgid ""
"**Tag position** determines where the name of the enum tag (i.e. case or "
"constructor name) is stored."
msgstr "**标签位置** 决定枚举标签（即构造器名称）的名称存储在哪里。"

#: ../../language/derive.md:124
msgid ""
"**Case representation** determines how to represent the payload of the "
"enum."
msgstr "**构造器表示** 决定如何表示枚举的负载。"

#: ../../language/derive.md:126
msgid "Let's consider the following enum definition:"
msgstr "让我们考虑以下枚举定义："

#: ../../language/derive.md:128
msgid ""
"enum E {\n"
"    Uniform(Int)\n"
"    Axes(x~: Int, y~: Int)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:135
msgid "For tag position, there are 4 variants:"
msgstr "对于标签位置，有 4 个变体："

#: ../../language/derive.md:137
msgid "**Internally tagged** puts the tag alongside the payload values:"
msgstr "**内部标记** 将标签与负载值一起放置："

#: ../../language/derive.md:139
msgid ""
"`{ \"$tag\": \"Uniform\", \"0\": 1 }`, `{ \"$tag\": \"Axes\", \"x\": 2, "
"\"y\": 3 }`"
msgstr ""

#: ../../language/derive.md:141
msgid ""
"**Externally tagged** puts the tag as the JSON object key outside the "
"payload values:"
msgstr "**外部标记** 将标签作为 JSON 对象键放置在负载值之外："

#: ../../language/derive.md:143
msgid "`{ \"Uniform\": { \"0\": 1 } }`, `{ \"Axes\": { \"x\": 2, \"y\": 3 } }`"
msgstr ""

#: ../../language/derive.md:145
msgid ""
"**Adjacently tagged** puts the tag payload in two adjacent keys in a JSON"
" object:"
msgstr "**相邻标记** 将标签负载放置在 JSON 对象中的两个相邻键中："

#: ../../language/derive.md:147
msgid ""
"`{ \"t\": \"Uniform\", \"c\": { \"0\": 1 } }`, `{ \"t\": \"Axes\", \"c\":"
" { \"x\": 2, \"y\": 3 } }`"
msgstr ""

#: ../../language/derive.md:149
msgid "**Untagged** has no explicit tag identifying which case the data is:"
msgstr "**无标记** 没有明确的标记标识数据属于哪个构造器："

#: ../../language/derive.md:151
msgid "`{ \"0\": 1 }`, `{ \"x\": 2, \"y\": 3 }`."
msgstr ""

#: ../../language/derive.md:153
msgid ""
"The JSON deserializer will try to deserialize each case in order and "
"return the first one succeeding."
msgstr "JSON 反序列化器将尝试按顺序反序列化每个构造器，并返回第一个成功的构造器。"

#: ../../language/derive.md:155
msgid "For case representation, there are 2 variants:"
msgstr "对于构造器表示，有 2 个变体："

#: ../../language/derive.md:157
msgid ""
"**Object-like** representation serializes enum payloads into a JSON "
"object, whose key is either the tag name or the string of the positional "
"index within the struct."
msgstr "**对象式** 表示将枚举负载序列化为 JSON 对象，其键是标签名称或结构体中的位置索引的字符串。"

#: ../../language/derive.md:160
msgid "`{ \"0\": 1 }`, `{ \"x\": 2, \"y\": 3 }`"
msgstr ""

#: ../../language/derive.md:162
msgid ""
"**Tuple-like** representation serializes enum payloads into a tuple (jSON"
" array), in the same order as the type declaration. Labels are omitted in"
" tuple-like representations."
msgstr "**元组式** 表示将枚举负载序列化为元组（JSON 数组），顺序与类型声明相同。标签在元组式表示中被省略。"

#: ../../language/derive.md:166
msgid "`[1]`, `[2, 3]`"
msgstr ""

#: ../../language/derive.md:168
msgid ""
"The two aspects can be combined freely, except one case: _internally "
"tagged_ enums cannot use _tuple-like_ representation."
msgstr "这两个方面可以自由组合，除了一个情况：_内部标记_ 枚举不能使用 _元组式_ 表示。"

#: ../../language/derive.md:171
msgid "Container arguments"
msgstr "容器参数"

#: ../../language/derive.md:173
msgid ""
"`repr(...)` configures the representation of the container. This controls"
" the tag position of enums. For structs, the tag is assumed to be the "
"type of the type."
msgstr "`repr(...)` 配置容器的表示。这控制枚举的标签位置。对于结构体，假定标签是类型的类型。"

#: ../../language/derive.md:177
msgid "There are 4 representations available for selection:"
msgstr "有 4 种可供选择的表示："

#: ../../language/derive.md:179
msgid ""
"`repr(tag = \"tag\")` – Use internally tagged representation, with the "
"tag's object key name as specified."
msgstr "`repr(tag = \"tag\")` – 使用内部标记表示，标记的对象键名称如指定。"

#: ../../language/derive.md:182
msgid "`repr(untagged)` – Use untagged representation."
msgstr "`repr(untagged)` – 使用无标记表示。"

#: ../../language/derive.md:184
msgid "`repr(ext_tagged)` – Use externally tagged representation."
msgstr "`repr(ext_tagged)` – 使用外部标记表示。"

#: ../../language/derive.md:186
msgid ""
"`repr(tag = \"tag\", contents = \"contents\")` – Use adjacently tagged "
"representation, with the tag and contents key names as specified."
msgstr "`repr(tag = \"tag\", contents = \"contents\")` – 使用相邻标记表示，标记和内容键名称如指定。"

#: ../../language/derive.md:190
msgid "The default representation for struct is `repr(untagged)`."
msgstr "结构体的默认表示为 `repr(untagged)`。"

#: ../../language/derive.md:192
msgid "The default representation for enums is `repr(tag = \"$tag\")`"
msgstr "枚举的默认表示为 `repr(tag = \"$tag\")`"

#: ../../language/derive.md:194
msgid ""
"`case_repr(...)` (enum only) configures the case representation of the "
"container. This option is only available on enums."
msgstr "`case_repr(...)`（仅枚举）配置容器的构造器表示。此选项仅适用于枚举。"

#: ../../language/derive.md:197
msgid "`case_repr(struct)` – Use struct-like representation of enums."
msgstr "`case_repr(struct)` – 使用结构体式表示的枚举。"

#: ../../language/derive.md:200
msgid "`case_repr(tuple)` – Use tuple-like representation of enums."
msgstr "`case_repr(tuple)` – 使用元组式表示的枚举。"

#: ../../language/derive.md:203
msgid ""
"`rename_fields`, `rename_cases` (enum only), `rename_struct` (struct "
"only), `rename_all` renames fields, case names, struct name and all names"
" correspondingly, into a specific style."
msgstr ""
"`rename_fields`、`rename_cases`（仅枚举）、`rename_struct`（仅结构体）、`rename_all` "
"分别将字段、构造器名称、结构体名称和所有名称重命名为特定风格。"

#: ../../language/derive.md:207
msgid "Available parameters are:"
msgstr "可选的参数有："

#: ../../language/derive.md:209
msgid "`lowercase`"
msgstr ""

#: ../../language/derive.md:210
msgid "`UPPERCASE`"
msgstr ""

#: ../../language/derive.md:211
msgid "`camelCase`"
msgstr ""

#: ../../language/derive.md:212
msgid "`PascalCase`"
msgstr ""

#: ../../language/derive.md:213
msgid "`snake_case`"
msgstr ""

#: ../../language/derive.md:214
msgid "`SCREAMING_SNAKE_CASE`"
msgstr ""

#: ../../language/derive.md:215
msgid "`kebab-case`"
msgstr ""

#: ../../language/derive.md:216
msgid "`SCREAMING-KEBAB-CASE`"
msgstr ""

#: ../../language/derive.md:218
msgid ""
"Example: `rename_fields = \"PascalCase\"` for a field named "
"`my_long_field_name` results in `MyLongFieldName`."
msgstr ""
"例如：`rename_fields = \"PascalCase\"` 用于名为 `my_long_field_name` 的字段将得到 "
"`MyLongFieldName`。"

#: ../../language/derive.md:222
msgid ""
"Renaming assumes the name of fields in `snake_case` and the name of "
"structs/enum cases in `PascalCase`."
msgstr "重命名假定字段的名称为 `snake_case`，结构体/枚举构造器的名称为 `PascalCase`。"

#: ../../language/derive.md:225
msgid "`cases(...)` (enum only) controls the layout of enum cases."
msgstr "`cases(...)`（仅枚举）控制枚举构造器的布局。"

#: ../../language/derive.md:227
msgid "For example, for an enum"
msgstr "例如，对于一个枚举"

#: ../../language/derive.md:229
msgid ""
"enum E {\n"
"  A(...)\n"
"  B(...)\n"
"}\n"
msgstr ""

#: ../../language/derive.md:236
msgid "you are able to control each case using `cases(A(...), B(...))`."
msgstr "您可以使用 `cases(A(...), B(...))` 控制每个构造器。"

#: ../../language/derive.md:238
msgid "See [Case arguments](#case-arguments) below for details."
msgstr "有关详细信息，请参见下面的[构造器参数](#case-arguments)。"

#: ../../language/derive.md:240
msgid "`fields(...)` (struct only) controls the layout of struct fields."
msgstr "`fields(...)`（仅结构体）控制结构体字段的布局。"

#: ../../language/derive.md:242
msgid "For example, for a struct"
msgstr "例如，对于一个结构体"

#: ../../language/derive.md:244
msgid ""
"struct S {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/derive.md:251
msgid "you are able to control each field using `fields(x(...), y(...))`"
msgstr "您可以使用 `fields(x(...), y(...))` 控制每个字段。"

#: ../../language/derive.md:253 ../../language/derive.md:263
msgid "See [Field arguments](#field-arguments) below for details."
msgstr "有关详细信息，请参见下面的[字段参数](#field-arguments)。"

#: ../../language/derive.md:255
msgid "Case arguments"
msgstr "构造器参数"

#: ../../language/derive.md:257
msgid ""
"`rename = \"...\"` renames this specific case, overriding existing "
"container-wide rename directive if any."
msgstr "`rename = \"...\"` 重命名此特定构造器，覆盖现有的容器范围重命名指令（如果有的话）。"

#: ../../language/derive.md:260
msgid ""
"`fields(...)` controls the layout of the payload of this case. Note that "
"renaming positional fields are not possible currently."
msgstr "`fields(...)` 控制此构造器的负载布局。请注意，目前无法重命名位置字段。"

#: ../../language/derive.md:265
msgid "Field arguments"
msgstr "字段参数"

#: ../../language/derive.md:267
msgid ""
"`rename = \"...\"` renames this specific field, overriding existing "
"container-wide rename directives if any."
msgstr "`rename = \"...\"` 重命名此特定字段，覆盖现有的容器范围重命名指令（如果有的话）。"

#: ../../language/docs.md:1
msgid "Documentation"
msgstr "文档"

#: ../../language/docs.md:3
msgid "Doc Comments"
msgstr "文档注释"

#: ../../language/docs.md:5
msgid ""
"Doc comments are comments prefix with `///` in each line in the leading "
"of toplevel structure like `fn`,`let`,`enum`,`struct`,`type`. The doc "
"comments contains a markdown text and several pragmas."
msgstr ""
"文档注释是在顶层结构（如 `fn`、`let`、`enum`、`struct`、`type`）的每一行前面加上 `///` "
"的注释。文档注释包含一个 markdown 文本和几个注解。"

#: ../../language/docs.md:7
msgid ""
"/// Return a new array with reversed elements.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"
msgstr ""
"/// 返回一个新数组，其中元素被反转。\n"
"///\n"
"/// # 示例\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"

#: ../../language/docs.md:13
msgid "Pragmas"
msgstr "注解"

#: ../../language/docs.md:15
msgid ""
"Pragmas are annotations inside doc comments. They all take the form `/// "
"@word ...`. The _word_ indicates the type of pragma and is followed "
"optionally by several _word_ or string literals. Pragmas do not normally "
"affect the meaning of programs. Unrecognized pragmas will be reported as "
"warnings."
msgstr ""
"注解是文档注释中的标记。它们都采用 `/// @word ...` 的形式。_word_ 表示注解的类型，后面可以跟几个 _word_ "
"或字符串文字。注解通常不会影响程序的含义。未识别的注解将被报告为警告。"

#: ../../language/docs.md:17
msgid "Alert Pragmas"
msgstr "警告注解"

#: ../../language/docs.md:19
msgid ""
"Alert pragmas in doc comments of functions will be reported when those "
"functions are referenced. This mechanism is a generalized way to mark "
"functions as `deprecated` or `unsafe`."
msgstr "函数文档注释中的警告注解将在引用这些函数时报告。这种机制是一种通用的方法，用于将函数标记为 `deprecated` 或 `unsafe`。"

#: ../../language/docs.md:21
msgid "It takes the form `@alert category \"alert message...\"`."
msgstr "它采用 `@alert category \"alert message...\"` 的形式。"

#: ../../language/docs.md:23
msgid ""
"The category can be an arbitrary identifier. It allows configuration to "
"decide which alerts are enabled or turned into errors."
msgstr "类别可以是任意标识符。它允许配置决定哪些警告是启用的或转换为错误。"

#: ../../language/docs.md:26
msgid ""
"/// @alert deprecated \"Use foo2 instead\"\n"
"pub fn foo() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"/// @alert unsafe \"Div will cause an error when y is zero\"\n"
"pub fn div(x : Int, y : Int) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"test {\n"
"  // Warning (Alert deprecated): Use foo2 instead\n"
"  foo()\n"
"  // Warning (Alert unsafe): Div will cause an error when y is zero\n"
"  div(1, 2) |> ignore\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:1
msgid "Error handling"
msgstr "错误处理"

#: ../../language/error-handling.md:3
msgid ""
"Error handling has always been at core of our language design. In the "
"following we'll be explaining how error handling is done in MoonBit. We "
"assume you have some prior knowledge of MoonBit, if not, please checkout "
"[A tour of MoonBit](../tutorial/tour.md)."
msgstr ""
"错误处理一直是我们语言设计的核心。接下来我们将解释 MoonBit 中的错误处理。我们假设您对 MoonBit 有一些了解，如果没有，请查看 "
"[MoonBit 之旅](../tutorial/tour.md)。"

#: ../../language/error-handling.md:7
msgid "Error types"
msgstr "错误类型"

#: ../../language/error-handling.md:9
msgid ""
"The error values used in MoonBit must have an error type. An error type "
"can be defined in the following forms:"
msgstr "MoonBit 中使用的错误值必须具有错误类型。错误类型可以用以下形式定义："

#: ../../language/error-handling.md:12
msgid ""
"type! E1 Int // error type E1 has one constructor E1 with an Int payload\n"
"\n"
"type! E2  // error type E2 has one constructor E2 with no payload\n"
"\n"
"type! E3 { // error type E3 has three constructors like a normal enum "
"type\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"
msgstr ""
"type! E1 Int  // 错误类型 E1 具有一个构造器 E1，并带有一个 Int 负载\n"
"type! E2      // 错误类型 E2 具有一个没有负载的构造器 E2\n"
"type! E3 {    // 错误类型 E3 类似于普通的枚举类型，有三个构造器\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"

#: ../../language/error-handling.md:19
msgid ""
"The return type of a function can include an error type to indicate that "
"the function might return an error. For example, the following function "
"`div` might return an error of type `DivError`:"
msgstr "函数的返回类型可以包含错误类型，以表明函数可能返回一个错误。例如，以下函数 `div` 可能返回一个类型为 `DivError` 的错误："

#: ../../language/error-handling.md:23
msgid ""
"type! DivError String\n"
"\n"
"fn div(x : Int, y : Int) -> Int!DivError {\n"
"  if y == 0 {\n"
"    raise DivError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:30
msgid ""
"Here, the keyword `raise` is used to interrupt the function execution and"
" return an error."
msgstr "这里使用了关键字 `raise` 来中断函数执行并返回一个错误。"

#: ../../language/error-handling.md:33
msgid "The Default Error Type"
msgstr "默认错误类型"

#: ../../language/error-handling.md:35
msgid ""
"MoonBit provides a default error type `Error` that can be used when the "
"concrete error type is not important. For convenience, you can annotate "
"the function name or the return type with the suffix `!` to indicate that"
" the `Error` type is used. For example, the following function signatures"
" are equivalent:"
msgstr ""
"MoonBit 提供了一个默认错误类型 `Error`，当具体的错误类型不重要时可以使用它。为了方便起见，您可以在函数名或返回类型后面加上后缀 "
"`!`，以表示使用了 `Error` 类型。例如，以下函数签名是等价的："

#: ../../language/error-handling.md:40
msgid ""
"fn f() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"fn g!() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn h() -> Unit!Error {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:47
msgid ""
"For anonymous function and matrix function, you can annotate the keyword "
"`fn` with the `!` suffix to achieve that. For example,"
msgstr "对于匿名函数和矩阵函数，您可以在关键字 `fn` 后面加上 `!` 后缀来实现这一点。例如："

#: ../../language/error-handling.md:50
msgid ""
"type! IntError Int\n"
"\n"
"fn h(f : (Int) -> Int!, x : Int) -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn g() -> Unit {\n"
"  let _ = h(fn! { x => raise IntError(x) }, 0)\n"
"  let _ = h(fn!(x) { raise IntError(x) }, 0)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:56
msgid ""
"As shown in the above example, the error types defined by `type!` can be "
"used as value of the type `Error` when the error is raised."
msgstr "如上例所示，`type!` 定义的错误类型可以在引发错误时作为 `Error` 类型的值使用。"

#: ../../language/error-handling.md:59
msgid ""
"Note that only error types or the type `Error` can be used as errors. For"
" functions that are generic in the error type, you can use the `Error` "
"bound to do that. For example,"
msgstr "请注意，只有错误类型或 `Error` 类型可以用作错误。对于在错误类型上是泛型的函数，您可以使用 `Error` 约束来实现。例如："

#: ../../language/error-handling.md:63
msgid ""
"// Result::unwrap_or_error\n"
"fn unwrap_or_error[T, E : Error](result : Result[T, E]) -> T!E {\n"
"  match result {\n"
"    Ok(x) => x\n"
"    Err(e) => raise e\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:69
msgid ""
"Since the type `Error` can include multiple error types, pattern matching"
" on the `Error` type must use the wildcard `_` to match all error types. "
"For example,"
msgstr "由于 `Error` 类型可以包含多个错误类型，对 `Error` 类型进行模式匹配必须使用通配符 `_` 来匹配所有错误类型。例如："

#: ../../language/error-handling.md:72
msgid ""
"type! E4\n"
"\n"
"type! E5\n"
"\n"
"fn f(e : Error) -> Unit {\n"
"  match e {\n"
"    E4 => println(\"E1\")\n"
"    E5 => println(\"E2\")\n"
"    _ => println(\"unknown error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:78
msgid "Handling Errors"
msgstr "处理错误"

#: ../../language/error-handling.md:80
msgid "There are three ways to handle errors:"
msgstr "有三种方式可以处理错误："

#: ../../language/error-handling.md:82
msgid ""
"Append `!` after the function name in a function application to rethrow "
"the error directly in case of an error, for example:"
msgstr "在函数应用中的函数名后面附加 `!`，以便在出现错误时直接重新抛出错误，例如："

#: ../../language/error-handling.md:85
msgid ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // Rethrow the error if `div` raised an error\n"
"}\n"
msgstr ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // 如果 `div` 引发错误，则重新抛出错误\n"
"}\n"

#: ../../language/error-handling.md:91
msgid ""
"Append `?` after the function name to convert the result into a first-"
"class value of the `Result` type, for example:"
msgstr "在函数名后面附加 `?`，将结果转换为 `Result` 类型的值，例如："

#: ../../language/error-handling.md:94
msgid ""
"test {\n"
"  let res = div?(6, 3)\n"
"  inspect!(res, content=\"Ok(2)\")\n"
"  let res = div?(6, 0)\n"
"  inspect!(\n"
"    res,\n"
"    content=\n"
"      #|Err(\"division by zero\")\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:100
msgid "Use `try` and `catch` to catch and handle errors, for example:"
msgstr ""

#: ../../language/error-handling.md:102
msgid ""
"fn main {\n"
"try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  DivError(s) => println(s)\n"
"} else {\n"
"  v => println(v)\n"
"}\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:111 ../../language/fundamentals.md:117
#: ../../language/fundamentals.md:149 ../../language/fundamentals.md:176
#: ../../language/fundamentals.md:208 ../../language/fundamentals.md:600
#: ../../language/fundamentals.md:614 ../../language/fundamentals.md:628
#: ../../language/fundamentals.md:642 ../../language/fundamentals.md:654
#: ../../language/fundamentals.md:671 ../../language/fundamentals.md:709
#: ../../language/fundamentals.md:756 ../../language/fundamentals.md:770
#: ../../language/fundamentals.md:904 ../../language/fundamentals.md:940
#: ../../language/fundamentals.md:971 ../../language/fundamentals.md:998
#: ../../language/fundamentals.md:1027 ../../language/fundamentals.md:1047
#: ../../language/fundamentals.md:1081 ../../language/fundamentals.md:1095
#: ../../language/methods.md:90
msgid "Output"
msgstr "输出"

#: ../../language/error-handling.md:111
msgid "division by zero\n"
msgstr "除零"

#: ../../language/error-handling.md:115
msgid ""
"Here, `try` is used to call a function that might throw an error, and "
"`catch` is used to match and handle the caught error. If no error is "
"caught, the catch block will not be executed and the `else` block will be"
" executed instead."
msgstr ""
"这里，`try` 用于调用可能引发错误的函数，`catch` 用于匹配和处理捕获的错误。如果没有捕获到错误，`catch` 块将不会执行，而是执行"
" `else` 块。"

#: ../../language/error-handling.md:119
msgid ""
"The `else` block can be omitted if no action is needed when no error is "
"caught. For example:"
msgstr "如果不需要在没有捕获到错误时执行任何操作，则可以省略 `else` 块。例如："

#: ../../language/error-handling.md:122
msgid ""
"try {\n"
"  println(div!(42, 0))\n"
"} catch {\n"
"  _ => println(\"Error\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:129
msgid ""
"The `catch` keyword is optional, and when the body of `try` is a simple "
"expression, the curly braces can be omitted. For example:"
msgstr "`catch` 关键字是可选的，当 `try` 的主体是一个简单表达式时，大括号可以省略。例如："

#: ../../language/error-handling.md:132
msgid ""
"let a = try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  _ => 0\n"
"}\n"
"println(a)\n"
msgstr ""

#: ../../language/error-handling.md:139
msgid ""
"The `!` and `?` attributes can also be used on method invocation and pipe"
" operator. For example:"
msgstr "`!` 和 `?` 符号也可以用于方法调用和管道运算符。例如："

#: ../../language/error-handling.md:142
msgid ""
"type T Int\n"
"\n"
"type! E Int derive(Show)\n"
"\n"
"fn k(self : T) -> Unit!E {\n"
"  ...\n"
"}\n"
"\n"
"fn l() -> Unit!E {\n"
"  let x = T(42)\n"
"  k!(x)\n"
"  x.k!()\n"
"  x |> k!()\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:148
msgid ""
"However for infix operators such as `+` `*` that may raise an error, the "
"original form has to be used, e.g. `x.op_add!(y)`, `x.op_mul!(y)`."
msgstr "然而对于可能引发错误的中缀运算符，如 `+` `*`，必须使用原始形式，例如 `x.op_add!(y)`，`x.op_mul!(y)`。"

#: ../../language/error-handling.md:151
msgid ""
"Additionally, if the return type of a function includes an error type, "
"the function call must use `!` or `?` for error handling, otherwise the "
"compiler will report an error."
msgstr "此外，如果函数的返回类型包含错误类型，则函数调用必须使用 `!` 或 `?` 进行错误处理，否则编译器将报告错误。"

#: ../../language/error-handling.md:155
msgid "Error Inference"
msgstr "错误推导"

#: ../../language/error-handling.md:157
msgid ""
"Within a `try` block, several different kinds of errors can be raised. "
"When that happens, the compiler will use the type `Error` as the common "
"error type. Accordingly, the handler must use the wildcard `_` to make "
"sure all errors are caught. For example,"
msgstr ""
"在 `try` 块中，可能引发多种不同类型的错误。当发生这种情况时，编译器将使用 `Error` "
"类型作为通用错误类型。因此，处理程序必须使用通配符 `_` 来确保捕获所有错误。例如："

#: ../../language/error-handling.md:162
msgid ""
"fn f1() -> Unit!E1 {\n"
"  ...\n"
"}\n"
"\n"
"fn f2() -> Unit!E2 {\n"
"  ...\n"
"}\n"
"\n"
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch {\n"
"  E1(_) => ...\n"
"  E2 => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:169
msgid ""
"You can also use `catch!` to rethrow the uncaught errors for convenience."
" This is useful when you only want to handle a specific error and rethrow"
" others. For example,"
msgstr "您还可以使用 `catch!` 来重新抛出未捕获的错误，以方便处理。当您只想处理特定错误并重新抛出其他错误时，这很有用。例如："

#: ../../language/error-handling.md:173
msgid ""
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch! {\n"
"  E1(_) => ...\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:180
msgid "Example: Division by Zero"
msgstr "示例：除零"

#: ../../language/error-handling.md:182
msgid ""
"We'll write a small example to demonstrate the basics of MoonBit's error "
"handling system. Consider the following `div` function which'll raise an "
"error on division by zero:"
msgstr "我们将编写一个小例子来演示 MoonBit 错误处理系统的基础知识。考虑以下 `div` 函数，它将在除零时引发错误："

#: ../../language/error-handling.md:186
msgid ""
"type! DivisionByZeroError String\n"
"fn div(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  if y == 0 {\n"
"    raise DivisionByZeroError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:196
msgid ""
"In before, we would typically use `type` to define a wrapper type which "
"wraps around some existing foreign type. Here however, we append `type` "
"with `!` to define a error type `DivisionByZeroError` which wraps around "
"`String`."
msgstr ""
"在以前，我们通常使用 `type` 来定义一个包装器类型，该类型包装了某些现有的外部类型。然而，在这里，我们使用 `!` 将 `type` 附加到"
" `DivisionByZeroError`，以定义一个错误类型，该类型包装了 `String`。"

#: ../../language/error-handling.md:200
msgid "`type! E S` construct a error type `E` from `S`"
msgstr "`type! E S` 从 `S` 构造一个错误类型 `E`"

#: ../../language/error-handling.md:202
msgid ""
"Just like `type`, `type!` may have a payload like the above "
"`DivisionByZeroError`, or may not, or may even have multiple constructors"
" like a normal `enum`:"
msgstr ""
"就像 `type` 一样，`type!` 可能有一个像上面的 `DivisionByZeroError` 那样的数据，也可能没有，甚至可能像普通的"
" `enum` 一样有多个构造器："

#: ../../language/error-handling.md:204
msgid ""
"type! ConnectionError {\n"
"  BrokenPipe(Int,String)\n"
"  ConnectionReset\n"
"  ConnectionAbort\n"
"  ConnectionRefused\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:213
msgid ""
"To utilize `DivisionByZeroError` type, we would usually define a function"
" which may raise error by denoting its return type like `T ! E` in the "
"signature, with `T` being the actual return type and `E` being the error "
"type. In this case, it's `Int!DivisionByZeroError`. The error can be "
"thrown using `raise e` where `e` is an instance of `E` which can be "
"constructed using the default constructor of `S`."
msgstr ""
"要使用 `DivisionByZeroError` 类型，我们通常会定义一个函数，该函数通过在签名中定义返回类型为 `T ! E` "
"来表示它会引发错误，其中 `T` 是实际的返回类型，`E` 是错误类型。在这个例子中，它是 "
"`Int!DivisionByZeroError`。错误可以使用 `raise e` 抛出，其中 `e` 是 `E` 的实例，可以使用 `S` "
"的默认构造器构造。"

#: ../../language/error-handling.md:220
msgid ""
"Any instance of an error is a second class object. Meaning it may only "
"appear in the return value. And if it does appear, the function signature"
" has to be adjusted to match with the return type."
msgstr "任何错误的实例都是一个二等公民对象。这意味着它只能出现在返回值中。如果返回值包含错误，函数签名必须调整以匹配返回类型。"

#: ../../language/error-handling.md:224
msgid ""
"The `test` block in MoonBit may also be seen as a function, with a return"
" type of Unit!Error."
msgstr "MoonBit 中的 `test` 块也可以看作是一个函数，返回类型为 Unit!Error。"

#: ../../language/error-handling.md:227
msgid "Calling an error-able function"
msgstr "调用一个可出错的函数"

#: ../../language/error-handling.md:229
msgid ""
"an error-able function is usually called in 2 manners: `f!(...)` and "
"`f?(...)`."
msgstr "一个可出错的函数通常有两种调用方式：`f!(...)` 和 `f?(...)`。"

#: ../../language/error-handling.md:231
msgid "As-is calling"
msgstr "直接调用"

#: ../../language/error-handling.md:233
msgid ""
"`f!(...)` calls the function directly. The possible error must be dealt "
"in the function that calls `f`. We can either re-raising it without "
"actually dealing with the error:"
msgstr "`f!(...)` 直接调用函数。可能的错误必须在调用 `f` 的函数中处理。我们可以重新抛出它，而不实际处理错误："

#: ../../language/error-handling.md:237
msgid ""
"// We have to match the error type of `div2` with `div`\n"
"fn div2(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  div!(x,y)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:244
msgid "or use `try...catch` block like in many other languages:"
msgstr "或者像其他许多语言一样使用 `try...catch` 块："

#: ../../language/error-handling.md:246
msgid ""
"fn div3(x : Int, y : Int) -> Unit {\n"
"  try {\n"
"    div!(x, y)\n"
"  } catch { // `catch` and `except` works the same.\n"
"    DivisionByZeroError(e) => println(\"inf: \\{e}\")\n"
"  } else {\n"
"    v => println(v)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:258
msgid ""
"The `catch...` clause has similar semantics like pattern matching. We can"
" unwrap the error to retrieve the underlying `String` and print it. "
"Additionally, there's an `else` clause to handle the value of `try...` "
"block."
msgstr ""
"`catch...` 子句的语义类似于模式匹配。我们可以解包错误以检索底层的 `String` 并打印它。此外，还有一个 `else` 子句来处理"
" `try...` 块的值。"

#: ../../language/error-handling.md:262
msgid ""
"fn test_try() -> Result[Int, Error] {\n"
"  // compiler can figure out the type of a local error-able function.\n"
"  fn f() -> _!_ {\n"
"    raise Failure(\"err\")\n"
"  }\n"
"\n"
"  try Ok(f!()) { err => Err(err) }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:273
msgid ""
"Curly braces may be omitted if the body of try is a one-liner "
"(expression). The `catch` keyword can also be omitted as well. In the "
"case where a `try` body would raise different errors, the special "
"`catch!` can be used to catch some of the errors, while re-raising other "
"uncaught errors:"
msgstr ""
"如果 `try` 的主体是一行代码（表达式），则大括号可以省略。`catch` 关键字也可以省略。在 `try` "
"主体可能引发不同错误的情况下，可以使用特殊的 `catch!` 来捕获一些错误，同时重新抛出其他未捕获的错误："

#: ../../language/error-handling.md:277
msgid ""
"type! E1\n"
"type! E2\n"
"fn f1() -> Unit!E1 { raise E1 }\n"
"fn f2() -> Unit!E2 { raise E2 }\n"
"fn f() -> Unit! {\n"
"  try {\n"
"    f1!()\n"
"    f2!()\n"
"  } catch! {\n"
"    E1 => println(\"E1\")\n"
"    // E2 gets re-raised.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:293
msgid "Convert to Result"
msgstr "转换为 Result"

#: ../../language/error-handling.md:295
msgid "Extracting values"
msgstr "提取值"

#: ../../language/error-handling.md:297
msgid ""
"A object of type `Result` is a first class value in MoonBit. `Result` has"
" 2 constructors: `Ok(...)` and `Err(...)` where the former accept a first"
" class object and the latter accept a error object."
msgstr ""
"`Result` 类型的对象是 MoonBit 中的一等公民。`Result` 有 2 个构造器：`Ok(...)` 和 "
"`Err(...)`，前者接受一个一等公民对象，后者接受一个错误对象。"

#: ../../language/error-handling.md:299
msgid ""
"With `f?(...)`, the return type `T!E` is turned into `Result[T,E]`. We "
"may use pattern matching to extract value from it:"
msgstr "使用 `f?(...)`，返回类型 `T!E` 被转换为 `Result[T,E]`。我们可以使用模式匹配从中提取值："

#: ../../language/error-handling.md:301
msgid ""
"let res = div?(10, 0)\n"
"match res {\n"
"  Ok(x) => println(x)\n"
"  Err(DivisionByZeroError(e)) => println(e)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:309
msgid "the `f?()` is basically a syntactic sugar for"
msgstr "`f?()` 基本上是一个语法糖，等价于"

#: ../../language/error-handling.md:311
msgid ""
"let res = try {\n"
"  Ok(div!(10, 0))\n"
"} catch {\n"
"  s => Err(s)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:319
msgid ""
"Note the difference between `T?` and `f?(...)`: `T` is a type and `T?` is"
" equivalent to `Option[T]` whereas `f?(...)` is a call to an error-able "
"function `f`."
msgstr ""
"注意 `T?` 和 `f?(...)` 之间的区别：`T` 是一个类型，`T?` 等价于 `Option[T]`，而 `f?(...)` "
"是对可出错函数 `f` 的调用。"

#: ../../language/error-handling.md:323
msgid ""
"Besides pattern matching, `Result` provides some useful methods to deal "
"with possible error:"
msgstr "除了模式匹配，`Result` 还提供了一些有用的方法来处理可能的错误："

#: ../../language/error-handling.md:325
msgid ""
"let res1: Result[Int, String] = Err(\"error\")\n"
"let value = res1.or(0) // 0\n"
"\n"
"let res2: Result[Int, String] = Ok(42)\n"
"let value = res2.unwrap() // 42\n"
msgstr ""

#: ../../language/error-handling.md:333
msgid ""
"`or` returns the value if the result is `Ok` or a default value if it is "
"`Err`"
msgstr "`or` 如果结果是 `Ok`，则返回值，如果是 `Err`，则返回默认值"

#: ../../language/error-handling.md:334
msgid "`unwrap` panics if the result is `Err` and return the value if it is `Ok`"
msgstr "`unwrap` 如果结果是 `Err`，则会崩溃，如果是 `Ok`，则返回值"

#: ../../language/error-handling.md:336
msgid "Mapping values"
msgstr "映射值"

#: ../../language/error-handling.md:338
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let new_result = res1.map(fn(x) { x + 1 }) // Ok(43)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let new_result = res2.map_err(fn(x) { x + \"!\" }) // Err(\"error!\")\n"
msgstr ""

#: ../../language/error-handling.md:346
msgid ""
"`map` applies a function to the value within, except it doesn't nothing "
"if result is `Err`."
msgstr "`map` 将函数应用于内部的值；如果结果是 `Err`，则不执行任何操作。"

#: ../../language/error-handling.md:347
msgid "`map_err` does the opposite."
msgstr "`map_err` 则相反。"

#: ../../language/error-handling.md:349
msgid ""
"Unlike some languages, MoonBit treats error-able and nullable value "
"differently. Although one might treat them analogously, as an `Err` "
"result contains no value, only the error, which is like `null`. MoonBit "
"knows that."
msgstr ""
"与一些语言不同，MoonBit 对可出错值和可空值进行了区分。尽管有些人可能将它们类比对待，因为一个不包含值的 `Err` 对象就像 "
"`null`。MoonBit 知道这一点。"

#: ../../language/error-handling.md:351
msgid "`to_option` converts a `Result` to `Option`."
msgstr "`to_option` 将 `Result` 转换为 `Option`。"

#: ../../language/error-handling.md:353
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let option = res1.to_option() // Some(42)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let option1 = res2.to_option() // None\n"
msgstr ""

#: ../../language/error-handling.md:361
msgid "Built-in error type and functions"
msgstr "内置错误类型和相关函数"

#: ../../language/error-handling.md:363
msgid "In MoonBit, `Error` is a generalized error type:"
msgstr "在 MoonBit 中，`Error` 是一个通用的错误类型："

#: ../../language/error-handling.md:365
msgid ""
"// These signatures are equivalent. They all raise Error.\n"
"fn f() -> Unit! { .. }\n"
"fn f!() -> Unit { .. }\n"
"fn f() -> Unit!Error { .. }\n"
"\n"
"fn test_error() -> Result[Int, Error] {\n"
"  fn f() -> _!_ {\n"
"    raise DivisionByZeroError(\"err\")\n"
"  }\n"
"\n"
"  try {\n"
"    Ok(f!())\n"
"  } catch {\n"
"    err => Err(err)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:384
msgid ""
"Although the constructor `Err` expects a type of `Error`, we may still "
"pass an error of type `DivisionByZeroError` to it."
msgstr "尽管构造器 `Err` 期望一个 `Error` 类型，我们仍然可以将 `DivisionByZeroError` 类型的错误传递给它。"

#: ../../language/error-handling.md:387
msgid ""
"But `Error` can't be constructed directly. It's meant to be passed "
"around, not used directly:"
msgstr "但是 `Error` 不能直接构造。它是用来传递的，而不是直接使用："

#: ../../language/error-handling.md:389
msgid ""
"type! ArithmeticError\n"
"\n"
"fn what_error_is_this(e : Error) -> Unit {\n"
"  match e {\n"
"    DivisionByZeroError(_) => println(\"DivisionByZeroError\")\n"
"    ArithmeticError => println(\"ArithmeticError\")\n"
"    ... => println(\"...\")\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:402
msgid ""
"`Error` is typically used where concrete error type is not needed, or "
"simply act as a catch-all for all kinds of sub-errors."
msgstr "`Error` 通常用于不需要具体错误类型的情况，或者简单地用来捕获所有的子错误。"

#: ../../language/error-handling.md:405
msgid ""
"As `Error` includes multiple error types, partial matching is not allowed"
" here. We have to do exhaustive matching by providing a catch-"
"all/wildcard case `_`."
msgstr "由于 `Error` 包含多种错误类型，这里不允许部分匹配。我们必须通过提供一个通配符 `_` 来进行兜底匹配。"

#: ../../language/error-handling.md:407
msgid ""
"We usually use the builtin `Failure` error type for a generalized error, "
"and by generalized we mean using it for trivial errors that doesn't need "
"a new error type."
msgstr "我们通常使用内置的 `Failure` 错误类型来表示通用错误：通用意味着它用于不值得单独定义类型的错误。"

#: ../../language/error-handling.md:410
msgid ""
"fn div_trivial(x : Int, y : Int) -> Int!Failure {\n"
"  if y == 0 {\n"
"    raise Failure(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:419
msgid ""
"Besides using the constructor directly, the function `fail!` provides a "
"shorthand to construct a `Failure`. And if we take a look at the source "
"code:"
msgstr "除了直接使用构造器，函数 `fail!` 提供了一个快捷方式来构造 `Failure`。如果我们查看源代码："

#: ../../language/error-handling.md:422
msgid ""
"pub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {\n"
"  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:428
msgid ""
"We can see that `fail` is merely a constructor with a pre-defined output "
"template for showing both the error and the source location. In practice,"
" `fail!` is always preferred over `Failure`."
msgstr "我们可以看到 `fail` 只是一个带有预定义输出模板的构造函数，用于显示错误和源位置。在实践中，`fail!` 总是比 `Failure`更常用。"

#: ../../language/error-handling.md:432
msgid ""
"Other functions used to break control flow are `abort` and `panic`. They "
"are equivalent. An `panic` at any place will manually crash the program "
"at that place, and prints out stack trace."
msgstr ""
"其他用于打破控制流的函数有 `abort` 和 `panic`。它们是等效的。在任何地方的 `panic` "
"都会手动在那个地方崩溃程序，并打印出堆栈跟踪。"

#: ../../language/error_codes/E0001.md:1
msgid "E0001"
msgstr ""

#: ../../language/error_codes/E0001.md:3
msgid ""
"There is an internal error occurred to the compiler. Usually this means "
"you have discovered a bug in the compiler."
msgstr ""

#: ../../language/error_codes/E0001.md:6
msgid ""
"A bug report containing the error description and relevant code would be "
"greatly appreciated. You can submit the bug report here:"
msgstr ""

#: ../../language/error_codes/E0001.md:9
msgid "<https://github.com/moonbitlang/moonbit-docs/issues/new?labels=bug,ICE>"
msgstr ""

#: ../../language/error_codes/E1001.md:1
msgid "E1001"
msgstr ""

#: ../../language/error_codes/E1001.md:3
msgid "Unused function."
msgstr "内联函数"

#: ../../language/error_codes/E1001.md:5
msgid ""
"This function is not used by any other part of your code, nor marked with"
" `pub` visibility."
msgstr ""

#: ../../language/error_codes/E1001.md:8
msgid ""
"Note that this warning might uncover other bugs in your code. For "
"example, if there are two functions in your codebase that has similar "
"name, you might just call the other function by mistake."
msgstr ""

#: ../../language/error_codes/E1001.md:12
#: ../../language/error_codes/E1002.md:15
#: ../../language/error_codes/E1003.md:16 ../../language/error_codes/E1005.md:9
#: ../../language/error_codes/E1006.md:11 ../../language/error_codes/E1007.md:6
#: ../../language/error_codes/E1008.md:6 ../../language/error_codes/E1009.md:5
#: ../../language/error_codes/E1010.md:10 ../../language/error_codes/E1011.md:6
#: ../../language/error_codes/E1012.md:7 ../../language/error_codes/E1013.md:18
#: ../../language/error_codes/E1014.md:5 ../../language/error_codes/E1015.md:8
#: ../../language/error_codes/E1018.md:12
#: ../../language/error_codes/E1019.md:11
#: ../../language/error_codes/E1020.md:30 ../../language/error_codes/E1021.md:5
#: ../../language/error_codes/E1022.md:8 ../../language/error_codes/E1023.md:5
#: ../../language/error_codes/E1024.md:5 ../../language/error_codes/E1026.md:8
#: ../../language/error_codes/E1028.md:5 ../../language/error_codes/E1029.md:5
#: ../../language/error_codes/E1030.md:5 ../../language/error_codes/E1031.md:7
#: ../../language/error_codes/E1032.md:5 ../../language/error_codes/E1033.md:10
#: ../../language/error_codes/E1035.md:29
#: ../../language/error_codes/E1036.md:13 ../../language/error_codes/E1037.md:5
#: ../../language/error_codes/E1038.md:13 ../../language/error_codes/E1039.md:9
#: ../../language/error_codes/E1040.md:7 ../../language/error_codes/E2000.md:17
#: ../../language/error_codes/E3001.md:5 ../../language/error_codes/E3002.md:5
#: ../../language/error_codes/E3003.md:5 ../../language/error_codes/E3004.md:6
#: ../../language/error_codes/E3005.md:14 ../../language/error_codes/E3006.md:7
#: ../../language/error_codes/E3007.md:5 ../../language/error_codes/E3008.md:5
#: ../../language/error_codes/E3009.md:5 ../../language/error_codes/E3010.md:5
#: ../../language/error_codes/E3011.md:6 ../../language/error_codes/E3012.md:6
#: ../../language/error_codes/E3014.md:8 ../../language/error_codes/E3015.md:25
#: ../../language/error_codes/E3016.md:5 ../../language/error_codes/E3017.md:9
#: ../../language/error_codes/E3019.md:10 ../../language/error_codes/E3020.md:6
#: ../../language/error_codes/E3800.md:10 ../../language/error_codes/E4000.md:5
#: ../../language/error_codes/E4005.md:5 ../../language/error_codes/E4007.md:8
#: ../../language/error_codes/E4050.md:9 ../../language/error_codes/E4051.md:15
#: ../../language/error_codes/E4052.md:7 ../../language/error_codes/E4053.md:18
#: ../../language/error_codes/E4055.md:5 ../../language/error_codes/E4056.md:5
#: ../../language/error_codes/E4057.md:5 ../../language/error_codes/E4059.md:9
#: ../../language/error_codes/E4060.md:13
#: ../../language/error_codes/E4061.md:18
#: ../../language/error_codes/E4062.md:37
#: ../../language/error_codes/E4063.md:13
#: ../../language/error_codes/E4065.md:27 ../../language/error_codes/E4066.md:9
#: ../../language/error_codes/E4067.md:11
#: ../../language/error_codes/E4068.md:11
#: ../../language/error_codes/E4069.md:15 ../../language/error_codes/E4070.md:8
#: ../../language/error_codes/E4071.md:9 ../../language/error_codes/E4072.md:5
#: ../../language/error_codes/E4073.md:12
#: ../../language/error_codes/E4074.md:18 ../../language/error_codes/E4075.md:7
#: ../../language/error_codes/E4076.md:9 ../../language/error_codes/E4077.md:9
#: ../../language/error_codes/E4078.md:9 ../../language/error_codes/E4079.md:8
msgid "Erroneous example"
msgstr "错误示例"

#: ../../language/error_codes/E1001.md:14
msgid ""
"fn greeting() -> String {\n"
"  \"Hello!\"\n"
"}\n"
"\n"
"fn main {\n"
"  fn local_greeting() -> String {\n"
"    \"Hello, world!\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1001.md:26
#: ../../language/error_codes/E1002.md:31
#: ../../language/error_codes/E1003.md:30
#: ../../language/error_codes/E1005.md:24
#: ../../language/error_codes/E1006.md:28
#: ../../language/error_codes/E1007.md:37
#: ../../language/error_codes/E1008.md:22
#: ../../language/error_codes/E1009.md:23
#: ../../language/error_codes/E1010.md:21
#: ../../language/error_codes/E1011.md:17
#: ../../language/error_codes/E1012.md:16
#: ../../language/error_codes/E1013.md:59
#: ../../language/error_codes/E1014.md:14
#: ../../language/error_codes/E1015.md:18
#: ../../language/error_codes/E1018.md:25
#: ../../language/error_codes/E1019.md:17
#: ../../language/error_codes/E1020.md:40
#: ../../language/error_codes/E1021.md:22
#: ../../language/error_codes/E1022.md:22
#: ../../language/error_codes/E1023.md:17
#: ../../language/error_codes/E1024.md:13
#: ../../language/error_codes/E1026.md:34
#: ../../language/error_codes/E1028.md:13
#: ../../language/error_codes/E1029.md:50
#: ../../language/error_codes/E1030.md:19
#: ../../language/error_codes/E1031.md:33
#: ../../language/error_codes/E1032.md:30
#: ../../language/error_codes/E1033.md:51
#: ../../language/error_codes/E1035.md:37
#: ../../language/error_codes/E1036.md:29
#: ../../language/error_codes/E1037.md:24
#: ../../language/error_codes/E1038.md:28
#: ../../language/error_codes/E1039.md:28
#: ../../language/error_codes/E1040.md:25
#: ../../language/error_codes/E2000.md:39
#: ../../language/error_codes/E3001.md:23
#: ../../language/error_codes/E3002.md:21
#: ../../language/error_codes/E3003.md:13
#: ../../language/error_codes/E3004.md:14
#: ../../language/error_codes/E3005.md:20
#: ../../language/error_codes/E3006.md:16
#: ../../language/error_codes/E3007.md:20
#: ../../language/error_codes/E3008.md:14
#: ../../language/error_codes/E3009.md:20
#: ../../language/error_codes/E3010.md:13
#: ../../language/error_codes/E3011.md:16
#: ../../language/error_codes/E3012.md:29
#: ../../language/error_codes/E3014.md:16
#: ../../language/error_codes/E3015.md:33
#: ../../language/error_codes/E3016.md:21
#: ../../language/error_codes/E3017.md:18
#: ../../language/error_codes/E3018.md:17
#: ../../language/error_codes/E3019.md:21
#: ../../language/error_codes/E3020.md:21
#: ../../language/error_codes/E3800.md:26
#: ../../language/error_codes/E4000.md:17
#: ../../language/error_codes/E4001.md:21
#: ../../language/error_codes/E4002.md:20
#: ../../language/error_codes/E4003.md:18
#: ../../language/error_codes/E4004.md:14
#: ../../language/error_codes/E4005.md:14
#: ../../language/error_codes/E4006.md:21
#: ../../language/error_codes/E4007.md:21
#: ../../language/error_codes/E4008.md:14
#: ../../language/error_codes/E4009.md:21
#: ../../language/error_codes/E4010.md:18
#: ../../language/error_codes/E4011.md:18
#: ../../language/error_codes/E4013.md:21
#: ../../language/error_codes/E4014.md:16
#: ../../language/error_codes/E4015.md:18
#: ../../language/error_codes/E4016.md:22
#: ../../language/error_codes/E4017.md:26
#: ../../language/error_codes/E4018.md:22
#: ../../language/error_codes/E4019.md:20
#: ../../language/error_codes/E4020.md:19
#: ../../language/error_codes/E4021.md:19
#: ../../language/error_codes/E4023.md:19
#: ../../language/error_codes/E4024.md:19
#: ../../language/error_codes/E4025.md:23
#: ../../language/error_codes/E4026.md:18
#: ../../language/error_codes/E4027.md:19
#: ../../language/error_codes/E4028.md:19
#: ../../language/error_codes/E4030.md:21
#: ../../language/error_codes/E4031.md:19
#: ../../language/error_codes/E4033.md:21
#: ../../language/error_codes/E4034.md:22
#: ../../language/error_codes/E4036.md:32
#: ../../language/error_codes/E4037.md:53
#: ../../language/error_codes/E4038.md:30
#: ../../language/error_codes/E4039.md:18
#: ../../language/error_codes/E4040.md:20
#: ../../language/error_codes/E4041.md:15
#: ../../language/error_codes/E4043.md:32
#: ../../language/error_codes/E4044.md:22
#: ../../language/error_codes/E4045.md:22
#: ../../language/error_codes/E4046.md:20
#: ../../language/error_codes/E4050.md:19
#: ../../language/error_codes/E4051.md:47
#: ../../language/error_codes/E4052.md:14
#: ../../language/error_codes/E4053.md:53
#: ../../language/error_codes/E4055.md:14
#: ../../language/error_codes/E4056.md:22
#: ../../language/error_codes/E4057.md:14
#: ../../language/error_codes/E4059.md:34
#: ../../language/error_codes/E4060.md:30
#: ../../language/error_codes/E4061.md:62
#: ../../language/error_codes/E4062.md:81
#: ../../language/error_codes/E4063.md:34
#: ../../language/error_codes/E4065.md:43
#: ../../language/error_codes/E4066.md:18
#: ../../language/error_codes/E4067.md:33
#: ../../language/error_codes/E4068.md:35
#: ../../language/error_codes/E4069.md:33
#: ../../language/error_codes/E4070.md:19
#: ../../language/error_codes/E4071.md:21
#: ../../language/error_codes/E4072.md:23
#: ../../language/error_codes/E4073.md:49
#: ../../language/error_codes/E4074.md:53
#: ../../language/error_codes/E4075.md:14
#: ../../language/error_codes/E4076.md:16
#: ../../language/error_codes/E4077.md:19
#: ../../language/error_codes/E4078.md:15
#: ../../language/error_codes/E4079.md:18
msgid "Suggestion"
msgstr "建议"

#: ../../language/error_codes/E1001.md:28
#: ../../language/error_codes/E1002.md:33
#: ../../language/error_codes/E1003.md:32
msgid "There are multiple ways to fix this warning:"
msgstr "有几种方式可以修复这个警告："

#: ../../language/error_codes/E1001.md:30
msgid ""
"If the function is indeed useless, you can remove the definition of the "
"function."
msgstr ""

#: ../../language/error_codes/E1001.md:32
msgid ""
"If this function is at the toplevel (i.e., not local), and is part of the"
" public API of your module, you can add the `pub` keyword to the "
"function."
msgstr ""

#: ../../language/error_codes/E1001.md:35
msgid ""
"pub fn greeting() -> String {\n"
"  \"Hello!\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1001.md:41
msgid ""
"If you made a typo in the function name, you can rename the function to "
"the correct name at the call site."
msgstr ""

#: ../../language/error_codes/E1001.md:44
msgid ""
"There are some cases where you might want to keep the function private "
"and unused at the same time. In this case, you can call `ignore()` on the"
" function to force the use of it."
msgstr ""

#: ../../language/error_codes/E1001.md:48
msgid ""
"fn greeting() -> String {\n"
"  \"Hello, world!\"\n"
"}\n"
"\n"
"fn init {\n"
"  ignore(greeting)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1001.md:58
msgid ""
"fn main {\n"
"  fn local_greeting() -> String {\n"
"    \"Hello, world!\"\n"
"  }\n"
"  ignore(local_greeting)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1002.md:1
msgid "E1002"
msgstr ""

#: ../../language/error_codes/E1002.md:3
msgid "Unused variable."
msgstr ""

#: ../../language/error_codes/E1002.md:5
msgid ""
"This variable is unused by any other part of your code, nor marked with "
"`pub` visibility."
msgstr ""

#: ../../language/error_codes/E1002.md:8
msgid ""
"Note that this warning might uncover other bugs in your code. For "
"example, if there are two variables in your codebase that has similar "
"name, you might just use the other variable by mistake."
msgstr ""

#: ../../language/error_codes/E1002.md:12
msgid ""
"Specifically, if the variable is at the toplevel, and the body of the "
"module contains side effects, the side effects will not happen."
msgstr ""

#: ../../language/error_codes/E1002.md:17
msgid ""
"let p : Int = {\n"
"//  ^ Warning: Unused toplevel variable 'p'.\n"
"//             Note if the body contains side effect, it will not happen."
"\n"
"//             Use `fn init { .. }` to wrap the effect.\n"
"  println(\"Side effect\")\n"
"  42\n"
"}\n"
"\n"
"fn main {\n"
"  let x = 42 // Warning: Unused variable 'x'\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1002.md:35
msgid ""
"If the variable is indeed useless, you can remove the definition of the "
"variable."
msgstr ""

#: ../../language/error_codes/E1002.md:37
msgid ""
"If this variable is at the toplevel (i.e., not local), and is part of the"
" public API of your module, you can add the `pub` keyword to the "
"variable."
msgstr ""

#: ../../language/error_codes/E1002.md:40
msgid "pub let p = 42\n"
msgstr ""

#: ../../language/error_codes/E1002.md:44
msgid ""
"If you made a typo in the variable name, you can rename the variable to "
"the correct name at the use site."
msgstr ""

#: ../../language/error_codes/E1002.md:46
msgid ""
"If your code depends on the side-effect of the variable, you can wrap the"
" side-effect in a `fn init` block."
msgstr ""

#: ../../language/error_codes/E1002.md:49
msgid ""
"fn init {\n"
"  println(\"Side effect\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1002.md:55
msgid ""
"There are some cases where you might want to keep the variable private "
"and unused at the same time. In this case, you can call `ignore()` on the"
" variable to force the use of it."
msgstr ""

#: ../../language/error_codes/E1002.md:59
msgid ""
"let p : Int = {\n"
"  println(\"Side effect\")\n"
"  42\n"
"}\n"
"\n"
"fn init {\n"
"  ignore(p)\n"
"}\n"
"\n"
"fn main {\n"
"  let x = 42\n"
"  ignore(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1003.md:1
msgid "E1003"
msgstr ""

#: ../../language/error_codes/E1003.md:3
msgid "Unused type declaration."
msgstr ""

#: ../../language/error_codes/E1003.md:5
msgid ""
"This type is not used by any other part of your code, and it is private. "
"Type declaration is by default abstract, which means it is publicly "
"visible to users of this package, but they cannot see the implementation "
"of the type, nor can create instances of it directly. Therefore, this "
"warning is only shown if the type is marked with `priv` visibility, and "
"is not used by any other part of this package."
msgstr ""

#: ../../language/error_codes/E1003.md:12
msgid ""
"Note that this warning might uncover other bugs in your code. For "
"example, if there are two types in the package that has similar name, you"
" might just use the other type by mistake."
msgstr ""

#: ../../language/error_codes/E1003.md:18
msgid ""
"priv struct Foo { // Warning: Unused type 'Foo'.\n"
"  bar : Int\n"
"}\n"
"\n"
"fn main {\n"
"  struct Bar { // Warning: Unused type 'Bar'.\n"
"    foot : Int\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1003.md:34
msgid "If the type is indeed useless, you can remove the definition of the type."
msgstr ""

#: ../../language/error_codes/E1003.md:35
msgid ""
"If this type is not local, and is part of the public API of your module, "
"you can remove the `priv` visibility keyword from the type."
msgstr ""

#: ../../language/error_codes/E1003.md:38
msgid ""
"type Foo {\n"
"  bar : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1003.md:44
msgid "Check if you are referencing the type with a correct name."
msgstr ""

#: ../../language/error_codes/E1003.md:46
msgid ""
"It is rather rare (and difficult) to have a type that is private and "
"unused at the same time; therefore, we suggest you remove the type if it "
"is not used."
msgstr ""

#: ../../language/error_codes/E1004.md:1
msgid "E1004"
msgstr ""

#: ../../language/error_codes/E1004.md:3
msgid "Unused abstract type."
msgstr ""

#: ../../language/error_codes/E1004.md:5
msgid "Currently, MoonBit won't emit this warning."
msgstr ""

#: ../../language/error_codes/E1005.md:1
msgid "E1005"
msgstr ""

#: ../../language/error_codes/E1005.md:3
msgid "Unused generic type variable."
msgstr ""

#: ../../language/error_codes/E1005.md:5
msgid ""
"In some cases, using types with unused generic type variables will make "
"it impossible for the type checker to infer the type of the unused "
"variable. This might lead to cryptic error messages, even unexpected "
"runtime behavior."
msgstr ""

#: ../../language/error_codes/E1005.md:11
msgid ""
"struct Foo[T] { // Warning: Unused type variable 'T'.\n"
"  bar : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let foo : Foo[Int] = { bar : 42 }\n"
"  let baz = { bar : 42 } // Warning: The type of this expression is "
"Foo[_/0]\n"
"  println(foo.bar)\n"
"  println(baz.bar)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1005.md:26
msgid "If the type variable is indeed useless, remove the unused type variable."
msgstr ""

#: ../../language/error_codes/E1005.md:28
msgid ""
"struct Foo { // Remove the unused type variable.\n"
"  bar : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1005.md:34
msgid ""
"If you wish to keep the type variable, you can use `_` to indicate that "
"the type variable is intentionally unused."
msgstr ""

#: ../../language/error_codes/E1005.md:37
msgid ""
"struct Foo[_] {\n"
"  bar : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:1
msgid "E1006"
msgstr ""

#: ../../language/error_codes/E1006.md:3
msgid "Variant is never read, never constructed, or both."
msgstr ""

#: ../../language/error_codes/E1006.md:5
msgid ""
"If a variant is never read, it means it is defined but never destructed "
"in a pattern matching expression (`match`, `let`, `guard let`, loop "
"function, etc.)."
msgstr ""

#: ../../language/error_codes/E1006.md:8
msgid "If a variant `A` is never constructed, it means there is no `A(...)`."
msgstr ""

#: ../../language/error_codes/E1006.md:9
msgid "If a variant is unused, it means it is never constructed and never read."
msgstr ""

#: ../../language/error_codes/E1006.md:13
msgid ""
"priv enum T {\n"
"  A // Warning: Variant 'A' is never read\n"
"  B // Warning: Variant 'B' is never constructed\n"
"  C // Warning: Variant 'C' is unused\n"
"}\n"
"\n"
"fn main {\n"
"  match T::A {\n"
"    B => ()\n"
"    _ => ()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:30
msgid ""
"If some variants are never read, while others are read, this means that "
"you have use wildcard pattern (`_`) in your code. You can expand the "
"wildcard pattern to include the unused variants."
msgstr ""

#: ../../language/error_codes/E1006.md:34
msgid ""
"fn main {\n"
"  match T::A {\n"
"    B => ()\n"
"    C => ()\n"
"    A => ()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:44
msgid ""
"If all variants are never read, and you need to read these variants "
"outside of current package, you can add `pub` keyword to the enum "
"definition."
msgstr ""

#: ../../language/error_codes/E1006.md:47
msgid ""
"pub enum T {\n"
"  A\n"
"  B\n"
"  C\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:55
msgid ""
"If you need to construct the \"never constructed\" variant outside of the"
" current package, you can add `pub(all)` keyword to the variant. Notice "
"this will make the implementation of the variant visible to the users of "
"the package."
msgstr ""

#: ../../language/error_codes/E1006.md:60
msgid ""
"pub(all) enum T {\n"
"  A\n"
"  B\n"
"  C\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1006.md:68
msgid "If some variants are indeed useless, you can remove the unused variants."
msgstr ""

#: ../../language/error_codes/E1006.md:70
msgid ""
"enum T {\n"
"  A\n"
"  B\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:1
msgid "E1007"
msgstr ""

#: ../../language/error_codes/E1007.md:3
msgid ""
"Field is never read. This include fields in structs and fields in enum "
"constructors."
msgstr ""

#: ../../language/error_codes/E1007.md:8
msgid "For enum constructor fields:"
msgstr "对于枚举构造器字段"

#: ../../language/error_codes/E1007.md:10
msgid ""
"enum E {\n"
"  A(Int) // Warning: The 1st positional argument of constructor 'A' is "
"unused.\n"
"  B(value~ : Int) // Warning: Field 'value' of constructor 'B' is unused."
"\n"
"}\n"
"\n"
"fn main {\n"
"  ignore(B(value=1))\n"
"  match A(1) {\n"
"    A(_) => println(\"A\")\n"
"    B(_) => println(\"B\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:25
msgid "For struct fields:"
msgstr "对于结构体字段"

#: ../../language/error_codes/E1007.md:27
msgid ""
"struct S {\n"
"  value : Int // Warning: Field 'value' is never read\n"
"}\n"
"\n"
"fn main {\n"
"  ignore(S::{ value : 1 })\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:39
msgid ""
"If the fields in enum constructors are unused, you can expand them in the"
" pattern to use them:"
msgstr ""

#: ../../language/error_codes/E1007.md:42
msgid ""
"fn main {\n"
"  // ...\n"
"  match A(1) {\n"
"    A(x) => println(\"A(\\{x})\")\n"
"    B(value~) => println(\"B(\\{value})\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:52
msgid ""
"If the fields in structs are unused, you can list them in record pattern,"
" or use the dot-syntax to access them:"
msgstr ""

#: ../../language/error_codes/E1007.md:55
msgid ""
"fn main {\n"
"  let s = S::{ value : 1 }\n"
"  match s {\n"
"    { value } => println(\"S(\\{value})\")\n"
"  }\n"
"  println(\"S(\\{s.value})\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:65
msgid ""
"Or, if the fields are indeed useless, you can remove the field from the "
"constructor:"
msgstr ""

#: ../../language/error_codes/E1007.md:68
msgid ""
"enum E {\n"
"  A\n"
"  B\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1007.md:75
msgid ""
"struct S {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1008.md:1
msgid "E1008"
msgstr ""

#: ../../language/error_codes/E1008.md:3
msgid ""
"The modifier (`pub`/`priv`) is redundant here, since this field has such "
"visibility by default."
msgstr ""

#: ../../language/error_codes/E1008.md:8
msgid ""
"struct A {\n"
"  priv value : Int\n"
"  // Warning: The private modifier is redundant here\n"
"  //          since field value is private by default\n"
"}\n"
"\n"
"pub struct B {\n"
"  pub value : Int\n"
"  // Warning: The public modifier is redundant here\n"
"  //          since field value is public by default\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1008.md:24
msgid "Remove the visibility modifier on the field."
msgstr ""

#: ../../language/error_codes/E1008.md:26
msgid ""
"struct A {\n"
"  value : Int\n"
"}\n"
"\n"
"pub struct B {\n"
"  value : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:1
msgid "E1009"
msgstr ""

#: ../../language/error_codes/E1009.md:3
msgid "The struct is never constructed."
msgstr ""

#: ../../language/error_codes/E1009.md:7
msgid ""
"pub struct A { // Warning: The struct A is never constructed\n"
"  value : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:13
msgid ""
"priv struct A { // Warning: The struct A is never constructed\n"
"  value : Int\n"
"}\n"
"\n"
"fn f(a : A) -> Int {\n"
"  a.value\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:25
msgid ""
"The `pub` visibility modifier only allows external packages to access the"
" struct, by dot-syntax (`a.value`), or by pattern matching. Therefore, if"
" you expect external packages to be able to construct the struct, you "
"should use the `pub(all)` visibility modifier."
msgstr ""

#: ../../language/error_codes/E1009.md:30
msgid ""
"pub(all) struct A {\n"
"  value : Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1009.md:36
msgid ""
"However, if you do not want external packages to construct the struct, "
"this might be due to incompleteness or bugs in your code. There are some "
"common cases:"
msgstr ""

#: ../../language/error_codes/E1009.md:40
msgid ""
"You planned to use smart constructors or factory functions to construct "
"the struct, but you forgot or have not implemented them."
msgstr ""

#: ../../language/error_codes/E1009.md:42
msgid ""
"You intend to keep the struct private to control its instantiation but "
"may have forgotten to provide a way to do so within its own package."
msgstr ""

#: ../../language/error_codes/E1009.md:45
msgid ""
"In these cases, you should consider providing a way to construct the "
"struct within its own package."
msgstr ""

#: ../../language/error_codes/E1009.md:48
msgid ""
"priv struct A {\n"
"  value : Int\n"
"}\n"
"\n"
"fn A::new(value : Int) -> A {\n"
"  A::{ value }\n"
"}\n"
"\n"
"fn A::value(self : A) -> Int {\n"
"  self.value\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1010.md:1
msgid "E1010"
msgstr ""

#: ../../language/error_codes/E1010.md:3
msgid ""
"This pattern is unused. This usually happens in pattern matching, and "
"this pattern is completely covered by a prior pattern."
msgstr ""

#: ../../language/error_codes/E1010.md:6
msgid ""
"Pattern matching in MoonBit is executed sequentially, from the first "
"branch to the last. If a pattern is covered by a prior pattern, it will "
"never be reached, since all control flow will be directed to the first "
"matching branch."
msgstr ""

#: ../../language/error_codes/E1010.md:12
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    _ => println(\"_\")\n"
"    Some(a) => println(\"Some(\\{a})\") // Warning: Unused pattern\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1010.md:23
msgid ""
"This warning can be usually fixed by swapping the order of the branches "
"in the pattern matching. If the order of the branches is important, then "
"you may want to refine the first pattern so that it excludes what the "
"second pattern covers."
msgstr ""

#: ../../language/error_codes/E1010.md:27
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    Some(a) => println(\"Some(\\{a})\")\n"
"    _ => println(\"_\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1010.md:36
#: ../../language/error_codes/E3012.md:43
#: ../../language/error_codes/E3016.md:39
msgid "Or,"
msgstr ""

#: ../../language/error_codes/E1010.md:38
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    None => println(\"_\")\n"
"    Some(a) => println(\"Some(\\{a})\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1011.md:1
msgid "E1011"
msgstr ""

#: ../../language/error_codes/E1011.md:3
msgid ""
"Partial match. The match/guard/loop expression does not cover all "
"possible cases."
msgstr ""

#: ../../language/error_codes/E1011.md:8
msgid ""
"///|\n"
"fn main {\n"
"  match Some(1) { // Partial match, some hints: None\n"
"    Some(x) => println(x)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1011.md:19
msgid ""
"The warning message usually contains hints about the missing patterns. "
"Add the missing cases to avoid incomplete matches."
msgstr ""

#: ../../language/error_codes/E1011.md:21
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    Some(x) => println(x)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1011.md:29
msgid "Or, you can add a wildcard pattern to catch all remaining cases:"
msgstr ""

#: ../../language/error_codes/E1011.md:31
msgid ""
"fn main {\n"
"  match Some(1) {\n"
"    Some(x) => println(x)\n"
"    _ => println(\"Other\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1012.md:1
msgid "E1012"
msgstr ""

#: ../../language/error_codes/E1012.md:3
msgid ""
"Unreachable code. This usually happens when a `return` statement is "
"followed by more code. The `return` statement will exit the function "
"immediately, so any code after it will not be executed."
msgstr ""

#: ../../language/error_codes/E1012.md:9
msgid ""
"fn main {\n"
"  return\n"
"  println(\"Hello, World!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1012.md:18
msgid ""
"Remove the unreachable code, or move it before the `return` statement if "
"you want the code to be executed."
msgstr ""

#: ../../language/error_codes/E1012.md:21
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"  return\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:1
msgid "E1013"
msgstr ""

#: ../../language/error_codes/E1013.md:3
msgid "The type of this expression contains unresolved type variables."
msgstr ""

#: ../../language/error_codes/E1013.md:5
msgid ""
"This error occurs when the compiler encounters a type that contains type "
"variables which cannot be determined from the context. Type variables are"
" placeholders for types that should be inferred by the compiler."
msgstr ""

#: ../../language/error_codes/E1013.md:9
msgid "Common cases where this happens:"
msgstr ""

#: ../../language/error_codes/E1013.md:11
msgid "Writing local functions without explicit type annotations"
msgstr ""

#: ../../language/error_codes/E1013.md:12
msgid ""
"Creating empty collections (Arrays, Options) without specifying their "
"element type"
msgstr ""

#: ../../language/error_codes/E1013.md:15
msgid ""
"When the compiler cannot resolve these type variables, it defaults them "
"to `Unit` type, which may not be what you intended."
msgstr ""

#: ../../language/error_codes/E1013.md:20
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x) {\n"
"//     ^ Warning: The type of this expression is Option[_/0], which "
"contains\n"
"//                unresolved type variables. The type variable is default"
" to\n"
"//                Unit.\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a)\n"
"    }\n"
"  }\n"
"\n"
"  f(None)\n"
"}\n"
"\n"
"pub fn f2() -> Unit {\n"
"  fn f(x : Array[_]) -> Int {\n"
"//     ^ Warning: The type of this expression is Array[_/0], which "
"contains\n"
"//                unresolved type variables. The type variable is default"
" to\n"
"//                Unit.\n"
"    x.length()\n"
"  }\n"
"\n"
"  println(f([]))\n"
"}\n"
"\n"
"fn main {\n"
"  let a = []\n"
"//        ^^ Warning: The type of this expression is Array[_/0], which "
"contains\n"
"//           unresolved type variables. The type variable is default to "
"Unit.\n"
"  println(a.length())\n"
"  let b = None\n"
"//        ^^ Warning: The type of this expression is Option[_/0], which "
"contains\n"
"//           unresolved type variables. The type variable is default to "
"Unit.\n"
"  println(b.is_empty())\n"
"}\n"
"\n"
msgstr ""

#: ../../language/error_codes/E1013.md:61
msgid "To fix this warning, you can:"
msgstr ""

#: ../../language/error_codes/E1013.md:63
msgid "Add type annotations to local function parameters. For example,"
msgstr ""

#: ../../language/error_codes/E1013.md:65
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x: Option[Int]) {\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a)\n"
"    }\n"
"  }\n"
"  f(None)\n"
"}\n"
"\n"
"pub fn f2() -> Unit {\n"
"  fn f(x : Array[Int]) -> Int {\n"
"    x.length()\n"
"  }\n"
"  println(f([]))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:84
msgid ""
"Explicitly specify the type of the variable or the collection element "
"type."
msgstr ""

#: ../../language/error_codes/E1013.md:86
msgid ""
"fn main {\n"
"  let a : Array[Int] = []\n"
"  println(a.length())\n"
"  let b : Option[Int] = None\n"
"  println(b.is_empty())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:95
msgid "Or equivalently, add annotations on the collection creation."
msgstr ""

#: ../../language/error_codes/E1013.md:97
msgid ""
"fn main {\n"
"  let a = ([] : Array[Int])\n"
"  println(a.length())\n"
"  let b = (None : Option[Int])\n"
"  println(b.is_empty())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1013.md:106
msgid "Provide enough context through usage."
msgstr ""

#: ../../language/error_codes/E1013.md:108
msgid ""
"pub fn f1() -> Unit {\n"
"  fn f(x) {\n"
"    match x {\n"
"      None => ()\n"
"      Some(a) => println(a + 1)\n"
"//                       ^^^^^ through this usage, the compiler can infer"
" the\n"
"//                             type of `x` is `Option[Int]`.\n"
"    }\n"
"  }\n"
"  f(None)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1014.md:1
msgid "E1014"
msgstr ""

#: ../../language/error_codes/E1014.md:3
msgid ""
"Type name should be capitalized. In MoonBit, we recommend using a "
"capitalized type name for all types, including built-in types and user-"
"defined types. This is a convention that is followed by the standard "
"library and most of the community code."
msgstr ""

#: ../../language/error_codes/E1014.md:7
msgid ""
"struct point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1014.md:16
msgid "Capitalize the type name."
msgstr ""

#: ../../language/error_codes/E1014.md:18
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1015.md:1
msgid "E1015"
msgstr ""

#: ../../language/error_codes/E1015.md:3
msgid ""
"The mutability is never used. It is a common mistake to declare an array "
"to be mutable when it is not necessary. Setting the value of an element "
"in an array does not require the array to be mutable. For example, `a[0] "
"= 0` does not require `a` to be mutable, but `a = [0, 1, 2]` does."
msgstr ""

#: ../../language/error_codes/E1015.md:10
msgid ""
"fn main {\n"
"  let mut x = [1, 2, 3] // Warning: The mutability of 'x' is never used.\n"
"  x[0] = 0\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1015.md:20
msgid "Remove the `mut` keyword from the variable declaration."
msgstr ""

#: ../../language/error_codes/E1015.md:22
msgid ""
"fn main {\n"
"  let x = [1, 2, 3]\n"
"  x[0] = 0\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1016.md:1
msgid "E1016"
msgstr ""

#: ../../language/error_codes/E1016.md:3
msgid "Parser consistency check failed."
msgstr ""

#: ../../language/error_codes/E1018.md:1
msgid "E1018"
msgstr ""

#: ../../language/error_codes/E1018.md:3
msgid "There is no `continue` in this loop expression, so `loop` is useless here."
msgstr ""

#: ../../language/error_codes/E1018.md:5
msgid ""
"This error occurs when using a `loop` expression that contains no "
"`continue` statement. In MoonBit, a `loop` without any `continue` "
"statements is equivalent to an block expression that will be executed "
"only once, making the `loop` keyword redundant in such cases. You should "
"either add a `continue` statement if you need to restart the loop from "
"the beginning, or use a simpler control flow construct like `match` or "
"`if`."
msgstr ""

#: ../../language/error_codes/E1018.md:14
msgid ""
"fn countdown(n : Int) -> Int {\n"
"  let mut count = n\n"
"  loop count {\n"
"    _..<0 => break\n"
"    _ => count = count - 1\n"
"  }\n"
"  return count\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1018.md:27
msgid "Either add a `continue` statement if you need to restart the loop:"
msgstr ""

#: ../../language/error_codes/E1018.md:29
msgid ""
"fn countdown(n : Int) -> Int {\n"
"  let mut count = n\n"
"  loop count {\n"
"    _..<0 => break\n"
"    _ => {\n"
"      continue count - 1\n"
"    }\n"
"  }\n"
"  return count\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1018.md:42
msgid "Or use `if`/`match` you don't need to use `continue`:"
msgstr ""

#: ../../language/error_codes/E1018.md:44
msgid ""
"fn countdown(n : Int) -> Int {\n"
"  let mut count = n\n"
"  match count {\n"
"    _..<0 => ()\n"
"    _ => count = count - 1\n"
"  }\n"
"  return count\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1019.md:1
msgid "E1019"
msgstr ""

#: ../../language/error_codes/E1019.md:3
msgid ""
"Toplevel declaration is not left aligned. Every toplevel structure in "
"MoonBit should be left-aligned, i.e. there is no space between the "
"beginning of the line and the declaration."
msgstr ""

#: ../../language/error_codes/E1019.md:7
msgid ""
"Sometimes, earlier parsing errors might causing this error to be raised "
"in the following lines. Therefore, when your are writing local "
"declarations while seeing this error, you should check the previous lines"
" for any parsing errors."
msgstr ""

#: ../../language/error_codes/E1019.md:13
msgid "  let x = 1\n"
msgstr ""

#: ../../language/error_codes/E1019.md:19
msgid "Remove the leading spaces:"
msgstr ""

#: ../../language/error_codes/E1019.md:21
msgid "let x = 1\n"
msgstr ""

#: ../../language/error_codes/E1020.md:1
msgid "E1020"
msgstr ""

#: ../../language/error_codes/E1020.md:3
msgid ""
"Invalid pragma. The pragma either has invalid id, or has invalid "
"properties."
msgstr ""

#: ../../language/error_codes/E1020.md:5
#, fuzzy
msgid "MoonBit compiler support the following pragmas:"
msgstr "MoonBit 提供了以下有用的内建特征："

#: ../../language/error_codes/E1020.md:7
msgid ""
"`@alert`. This pragma is used to emit a warning message. It has the "
"following format: `@alert <category> \"message\"`. For example:"
msgstr ""

#: ../../language/error_codes/E1020.md:10
msgid ""
"///|\n"
"/// @alert deprecated \"This function is deprecated\"\n"
"fn deprecated_function() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1020.md:18
msgid ""
"`@coverage.skip`. This pragma indicates that the following declaration "
"should be skipped when calculating code coverage. It has the following "
"format: `@coverage.skip`. For example:"
msgstr ""

#: ../../language/error_codes/E1020.md:22
msgid ""
"///|\n"
"/// @coverage.skip\n"
"fn function_to_skip() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1020.md:32
msgid ""
"///|\n"
"/// @deprecated \"This function is deprecated\"\n"
"fn f() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1020.md:42
msgid ""
"Depending on the pragma you want to use, you should either remove the "
"invalid pragma, or replace it with a valid one."
msgstr ""

#: ../../language/error_codes/E1020.md:45
msgid ""
"///|\n"
"/// @alert deprecated \"This function is deprecated\"\n"
"fn f() {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1021.md:1
msgid "E1021"
msgstr ""

#: ../../language/error_codes/E1021.md:3
msgid "Some arguments of constructor are omitted in pattern."
msgstr ""

#: ../../language/error_codes/E1021.md:7
msgid ""
"enum E {\n"
"  A(Int, w~ : Int, h~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(0, w=1, h=2) {\n"
"    A(v, w~) => { // Warning: The argument(s) h of constructor A are "
"omitted.\n"
"      println(v)\n"
"      println(w)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1021.md:24
msgid ""
"If you want to omit some arguments, add the `..` to the end of the "
"pattern:"
msgstr ""

#: ../../language/error_codes/E1021.md:26
msgid ""
"fn main {\n"
"  match A(0, w=1, h=2) {\n"
"    A(v, w~, ..) => {\n"
"      println(v)\n"
"      println(w)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1021.md:37
msgid "Or, you can match all arguments:"
msgstr ""

#: ../../language/error_codes/E1021.md:39
msgid ""
"fn main {\n"
"  match A(0, w=1, h=2) {\n"
"    A(v, w~, h~) => {\n"
"      println(v)\n"
"      println(w)\n"
"      println(h)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1022.md:1
msgid "E1022"
msgstr ""

#: ../../language/error_codes/E1022.md:3
msgid ""
"Ambiguous block expression. In MoonBit, the expression `{ value }` is "
"ambiguous because it could be interpreted as a block expression or a "
"struct literal. For now, we treat it as a struct literal, but writing "
"such expressions is discouraged."
msgstr ""

#: ../../language/error_codes/E1022.md:10
msgid ""
"struct S {\n"
"  value : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let value = 3\n"
"  let s = { value }\n"
"  ignore(s)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1022.md:24
msgid ""
"If you want to construct a struct using the struct literal, you can add a"
" comma to the end of the struct literal. Or you can call formatter on "
"this buffer to have the comma added automatically."
msgstr ""

#: ../../language/error_codes/E1022.md:28
msgid ""
"fn main {\n"
"  let value = 3\n"
"  let s = { value, }\n"
"  ignore(s)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1022.md:36
msgid ""
"If you are using it as a block expression, please remove the braces as it"
" has only one expression and is equivalent to the expression `value`:"
msgstr ""

#: ../../language/error_codes/E1022.md:39
msgid ""
"fn main {\n"
"  let value = 3\n"
"  let s = value\n"
"  ignore(s)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1023.md:1
msgid "E1023"
msgstr ""

#: ../../language/error_codes/E1023.md:3
msgid "The body of this try expression never raises any error."
msgstr ""

#: ../../language/error_codes/E1023.md:7
msgid ""
"fn main {\n"
"  try {\n"
"    println(\"Hello, world!\")\n"
"  } catch {\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1023.md:19
#, fuzzy
msgid "Remove the `try` expression:"
msgstr "匹配表达式"

#: ../../language/error_codes/E1023.md:21
#: ../../language/error_codes/E3002.md:27
#: ../../language/error_codes/E3003.md:17
#: ../../language/error_codes/E4069.md:67
msgid ""
"fn main {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1024.md:1
msgid "E1024"
msgstr ""

#: ../../language/error_codes/E1024.md:3
msgid "The error type of this function is never used."
msgstr ""

#: ../../language/error_codes/E1024.md:7
msgid ""
"fn greet() -> Unit! {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1024.md:15
#, fuzzy
msgid "Remove the error type:"
msgstr "默认错误类型"

#: ../../language/error_codes/E1024.md:17
msgid ""
"fn greet() -> Unit {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1026.md:1
msgid "E1026"
msgstr ""

#: ../../language/error_codes/E1026.md:3
msgid ""
"The patterns are complete so the usage of `catch!` is useless. In "
"MoonBit, when there is only one error type that will be raised in a try "
"block, compiler will know that the error type is the only one that will "
"be caught. So, there is no need to use `catch!` in this case."
msgstr ""

#: ../../language/error_codes/E1026.md:10
msgid ""
"type! E\n"
"\n"
"fn f() -> Unit!E {\n"
"  raise E\n"
"}\n"
"\n"
"fn g() -> Unit! {\n"
"  try {\n"
"    f!()\n"
"  } catch! {\n"
"    E => raise E\n"
"  }\n"
"}\n"
"\n"
"fn main {\n"
"  try {\n"
"    g!()\n"
"  } catch {\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1026.md:36
msgid "Remove the `!` in the `catch!`:"
msgstr ""

#: ../../language/error_codes/E1026.md:38
msgid ""
"type! E\n"
"\n"
"fn f() -> Unit!E {\n"
"  raise E\n"
"}\n"
"\n"
"fn g() -> Unit! {\n"
"  try {\n"
"    f!()\n"
"  } catch {\n"
"    E => raise E\n"
"  }\n"
"}\n"
"\n"
"fn main {\n"
"  try {\n"
"    g!()\n"
"  } catch {\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1027.md:1
msgid "E1027"
msgstr ""

#: ../../language/error_codes/E1027.md:3
msgid ""
"The syntax is deprecated. Please refer to the warning message on the "
"reason and potential fix."
msgstr ""

#: ../../language/error_codes/E1028.md:1
msgid "E1028"
msgstr ""

#: ../../language/error_codes/E1028.md:3
msgid ""
"Unfinished code. In MoonBit, you can use `...` to mark a piece of code "
"that is incomplete. You can still compile and run the code, but it will "
"cause a runtime error when it is executed."
msgstr ""

#: ../../language/error_codes/E1028.md:7
msgid ""
"fn f() -> Unit {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1028.md:15
msgid "Complete the code:"
msgstr ""

#: ../../language/error_codes/E1028.md:17
msgid ""
"fn f() -> Unit {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:1
msgid "E1029"
msgstr ""

#: ../../language/error_codes/E1029.md:3
msgid "Unused package."
msgstr ""

#: ../../language/error_codes/E1029.md:7
msgid "`moon.mod.json`:"
msgstr ""

#: ../../language/error_codes/E1029.md:9
msgid ""
"{\n"
"  \"name\": \"username/hello\",\n"
"  \"version\": \"0.1.0\",\n"
"  \"readme\": \"README.md\",\n"
"  \"source\": \"src\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:18
#: ../../language/error_codes/E1033.md:12
#: ../../language/error_codes/E4069.md:19
#: ../../language/error_codes/E4069.md:47
msgid "`lib/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E1029.md:20
#: ../../language/error_codes/E1033.md:14
#: ../../language/error_codes/E4061.md:34
msgid "{}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:24
msgid "`lib/hello.mbt`:"
msgstr ""

#: ../../language/error_codes/E1029.md:26
#: ../../language/error_codes/E1033.md:20
msgid ""
"pub fn greeting() -> String {\n"
"  \"Hello, world!\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:32
#: ../../language/error_codes/E1029.md:54
#: ../../language/error_codes/E1033.md:26
#: ../../language/error_codes/E1033.md:56
#: ../../language/error_codes/E4067.md:15
#: ../../language/error_codes/E4067.md:50
#: ../../language/error_codes/E4068.md:15
#: ../../language/error_codes/E4069.md:57
msgid "`main/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E1029.md:34
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    \"username/hello/lib\" // Unused package 'username/hello/lib'\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:43
#: ../../language/error_codes/E1033.md:43
#: ../../language/error_codes/E1033.md:72
#: ../../language/error_codes/E4067.md:23
#: ../../language/error_codes/E4067.md:37
#: ../../language/error_codes/E4068.md:23
#: ../../language/error_codes/E4069.md:65
msgid "`main/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E1029.md:45
msgid ""
"fn main {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1029.md:52
msgid "Remove the unused package:"
msgstr ""

#: ../../language/error_codes/E1029.md:56
#: ../../language/error_codes/E4068.md:17
#: ../../language/error_codes/E4068.md:53
#: ../../language/error_codes/E4069.md:49
#: ../../language/error_codes/E4069.md:59
msgid ""
"{\n"
"  \"is-main\": true\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1030.md:1
msgid "E1030"
msgstr ""

#: ../../language/error_codes/E1030.md:3
msgid ""
"The package alias is empty. The default package alias will be used "
"instead."
msgstr ""

#: ../../language/error_codes/E1030.md:7
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"\" // Warning: The package alias is empty. The default"
" package alias will be used instead.\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1030.md:21
msgid "Use a non-empty alias for the package:"
msgstr ""

#: ../../language/error_codes/E1030.md:23
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"hello\"\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1031.md:1
msgid "E1031"
msgstr ""

#: ../../language/error_codes/E1031.md:3
msgid ""
"The optional argument is never supplied. If the optional argument is "
"never supplied, then it can be safety removed from the parameter list and"
" be used purely internally as a normal variable."
msgstr ""

#: ../../language/error_codes/E1031.md:9
msgid ""
"Note, this warning is turned off by default. To enable this warning, you "
"have to modify the `\"warn-list\"` of `moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E1031.md:12
msgid ""
"{\n"
"  // ...\n"
"  \"warn-list\": \"+31\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1031.md:19
#: ../../language/error_codes/E1032.md:16
msgid "`main.mbt`:"
msgstr ""

#: ../../language/error_codes/E1031.md:21
msgid ""
"fn f(opt~ : Int = 4) -> Int {\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f())\n"
"  println(f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1031.md:35
msgid ""
"You can remove the optional argument, and use a local variable definition"
" instead:"
msgstr ""

#: ../../language/error_codes/E1031.md:38
msgid ""
"fn f() -> Int {\n"
"  let opt = 4\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f())\n"
"  println(f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1032.md:1
msgid "E1032"
msgstr ""

#: ../../language/error_codes/E1032.md:3
msgid ""
"Default value of optional argument is unused. This implies at every call "
"site of this function, the optional argument is always explicitly "
"supplied with a value. This means the optional argument can be refactored"
" into a labelled argument."
msgstr ""

#: ../../language/error_codes/E1032.md:7
msgid ""
"Note, this warning is turned off by default. To enable this warning, you "
"need to modify the `\"warn-list\"` of `moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E1032.md:9
msgid ""
"{\n"
"  // ...\n"
"  \"warn-list\": \"+32\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1032.md:18
msgid ""
"fn f(opt~ : Int = 4) -> Int {\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f(opt=3))\n"
"  println(f(opt=3))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1032.md:32
#, fuzzy
msgid "Turn the optional argument into a labelled argument:"
msgstr "只有顶层函数可以有带标签的参数。"

#: ../../language/error_codes/E1032.md:34
msgid ""
"fn f(opt~ : Int) -> Int {\n"
"  ignore(opt)\n"
"  0\n"
"}\n"
"\n"
"fn main {\n"
"  println(f(opt=3))\n"
"  println(f(opt=3))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:1
msgid "E1033"
msgstr ""

#: ../../language/error_codes/E1033.md:3
msgid "The import value is never used directly."
msgstr ""

#: ../../language/error_codes/E1033.md:5
msgid ""
"In MoonBit, you can import a value (say `f`) from another package into "
"current package, so that you don't have to use `@pkg.f` to qualify the "
"value, and you can just use `f` as if it were defined in this package. "
"However, if `f` is not used in current package, this warning will be "
"emitted."
msgstr ""

#: ../../language/error_codes/E1033.md:18
msgid "`lib/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E1033.md:28
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"hello\",\n"
"      \"value\": [\n"
"        \"greeting\" // Warning: The import value greeting is never used "
"directly.\n"
"      ]\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:45
msgid ""
"fn main {\n"
"  println(@hello.greeting())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:53
msgid ""
"It is possible that you still use qualified name to access the imported "
"value. In this case, either remove the imported value from "
"`moon.pkg.json`."
msgstr ""

#: ../../language/error_codes/E1033.md:58
msgid ""
"{\n"
"  // ...\n"
"  \"import\": [\n"
"    {\n"
"      \"path\": \"username/hello/lib\",\n"
"      \"alias\": \"hello\"\n"
"    }\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1033.md:70
msgid "Or remove the qualified package name from your code:"
msgstr ""

#: ../../language/error_codes/E1033.md:74
msgid ""
"fn main {\n"
"  println(greeting())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1034.md:1
msgid "E1034"
msgstr ""

#: ../../language/error_codes/E1034.md:3
msgid ""
"The syntax `~label` is deprecated. We have removed this syntax and this "
"warning is no longer emitted by the compiler."
msgstr ""

#: ../../language/error_codes/E1035.md:1
msgid "E1035"
msgstr ""

#: ../../language/error_codes/E1035.md:3
msgid ""
"The word is reserved for possible future use. Please use another name for"
" it."
msgstr ""

#: ../../language/error_codes/E1035.md:5
msgid "Here is a list of reserved name:"
msgstr ""

#: ../../language/error_codes/E1035.md:7
msgid "`module`"
msgstr ""

#: ../../language/error_codes/E1035.md:8
msgid "`move`"
msgstr ""

#: ../../language/error_codes/E1035.md:9
msgid "`ref`"
msgstr ""

#: ../../language/error_codes/E1035.md:10
msgid "`static`"
msgstr ""

#: ../../language/error_codes/E1035.md:11
msgid "`super`"
msgstr ""

#: ../../language/error_codes/E1035.md:12
msgid "`unsafe`"
msgstr ""

#: ../../language/error_codes/E1035.md:13
msgid "`use`"
msgstr ""

#: ../../language/error_codes/E1035.md:14
msgid "`where`"
msgstr ""

#: ../../language/error_codes/E1035.md:15
msgid "`await`"
msgstr ""

#: ../../language/error_codes/E1035.md:16
msgid "`dyn`"
msgstr ""

#: ../../language/error_codes/E1035.md:17
#, fuzzy
msgid "`abstract`"
msgstr "结构体"

#: ../../language/error_codes/E1035.md:18
msgid "`do`"
msgstr ""

#: ../../language/error_codes/E1035.md:19
msgid "`final`"
msgstr ""

#: ../../language/error_codes/E1035.md:20
msgid "`macro`"
msgstr ""

#: ../../language/error_codes/E1035.md:21
msgid "`override`"
msgstr ""

#: ../../language/error_codes/E1035.md:22
#, fuzzy
msgid "`typeof`"
msgstr "类型"

#: ../../language/error_codes/E1035.md:23
msgid "`virtual`"
msgstr ""

#: ../../language/error_codes/E1035.md:24
msgid "`yield`"
msgstr ""

#: ../../language/error_codes/E1035.md:25
msgid "`local`"
msgstr ""

#: ../../language/error_codes/E1035.md:26
#, fuzzy
msgid "`method`"
msgstr "方法名称"

#: ../../language/error_codes/E1035.md:27
msgid "`alias`"
msgstr ""

#: ../../language/error_codes/E1035.md:31
msgid ""
"fn module() -> Int { // Warning: The word `module` is reserved for "
"possible future use. Please consider using another name.\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1035.md:39
msgid ""
"fn module_() -> Int {\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1036.md:1
msgid "E1036"
msgstr ""

#: ../../language/error_codes/E1036.md:3
msgid "The loop label name shadows a label that is already in scope."
msgstr ""

#: ../../language/error_codes/E1036.md:5
msgid ""
"Loop labels must be unique within their scope. When a label name is "
"reused within a nested scope, it shadows the outer label, which can lead "
"to confusion about which loop is being referenced by `break` or "
"`continue` statements."
msgstr ""

#: ../../language/error_codes/E1036.md:9
msgid ""
"This warning helps prevent bugs that could occur when breaking or "
"continuing to the wrong loop level due to label shadowing. It's "
"recommended to use distinct, descriptive label names for different loops "
"to make the code's intent clear."
msgstr ""

#: ../../language/error_codes/E1036.md:15
msgid ""
"fn f(xss : Array[Array[Int]]) -> Unit {\n"
"  l~: for xs in xss {\n"
"    l~: for x in xs {\n"
"//  ^^  Warning: The label name `l` shadows a label name that is already "
"in\n"
"//               scope.\n"
"      if x > 0 {\n"
"        break l~\n"
"      }\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1036.md:31
msgid ""
"Use distinct, descriptive label names for different loops to make the "
"code's intent clear."
msgstr ""

#: ../../language/error_codes/E1037.md:1
msgid "E1037"
msgstr ""

#: ../../language/error_codes/E1037.md:3
#, fuzzy
msgid "The loop label name is never used."
msgstr "可选参数未被提供"

#: ../../language/error_codes/E1037.md:7
msgid ""
"fn read() -> BytesView {\n"
"  ...\n"
"}\n"
"\n"
"fn main {\n"
"  let mut bytes = []\n"
"  read~: loop read() {\n"
"    [] => break\n"
"    bs => {\n"
"      bytes = [..bytes, ..bs]\n"
"      continue read()\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1037.md:26
msgid "Remove the unused loop label."
msgstr ""

#: ../../language/error_codes/E1037.md:28
msgid ""
"fn main {\n"
"  let mut bytes = []\n"
"  loop {\n"
"    let bs = read()\n"
"    if bs == [] {\n"
"      break\n"
"    }\n"
"    bytes = [..bytes, ..bs]\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1038.md:1
msgid "E1038"
msgstr ""

#: ../../language/error_codes/E1038.md:3
msgid ""
"Useless guard because the pattern is irrefutable. A pattern is "
"irrefutable means it accepts all possible input. If a pattern in guard "
"let accepts all possible input, then it will always continue on, making "
"the guard useless."
msgstr ""

#: ../../language/error_codes/E1038.md:7
msgid ""
"One common mistake is, say if you want to return early on some condition,"
" and continues otherwise. However, since the pattern matching is "
"evaluated from first to last, the pattern after `guard let` will be first"
" evaluated and will always be success. Therefore, such code will not work"
" since all control will continue on and never returns early."
msgstr ""

#: ../../language/error_codes/E1038.md:15
msgid ""
"fn f(input : Int?) -> Int {\n"
"  guard let _ = input else {\n"
"    Some(_..<0) => abort(\"Invalid input\")\n"
"  }\n"
"  3\n"
"}\n"
"\n"
"fn main {\n"
"  ignore(f(None))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1038.md:30
msgid ""
"If you want all possible control flows goes through, then you can remove "
"the guard and just use let expression."
msgstr ""

#: ../../language/error_codes/E1038.md:33
msgid ""
"fn f(input : Int?) -> Int {\n"
"  let _ = input\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1038.md:40
msgid ""
"If you fail into the early return mistake, you can switch to `match` "
"expression:"
msgstr ""

#: ../../language/error_codes/E1038.md:42
msgid ""
"fn f(input : Int?) -> Int {\n"
"  match input {\n"
"    Some(_..<0) => abort(\"Invalid input\")\n"
"    _ => ()\n"
"  }\n"
"  3\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1039.md:1
msgid "E1039"
msgstr ""

#: ../../language/error_codes/E1039.md:3
msgid "Method name conflicts with another definition."
msgstr ""

#: ../../language/error_codes/E1039.md:5
msgid ""
"Note: methods declared with the syntax `fn f(self : T, ..)` will be "
"promoted to regular function in the future, declare the method using `fn "
"T::f(..)` to avoid name clash."
msgstr ""

#: ../../language/error_codes/E1039.md:11
msgid ""
"type A Int\n"
"\n"
"fn f() -> Int {\n"
"  3\n"
"}\n"
"\n"
"fn f(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  println(f())\n"
"  println(A(3).f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1039.md:30
msgid "You can defined the method as `A::f`:"
msgstr ""

#: ../../language/error_codes/E1039.md:32
msgid ""
"fn T::f(self : A) -> Int {\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1039.md:38
msgid ""
"However, defining a method with `T::` prefix makes it impossible to be "
"invoked as regular function. If you wish to call the method as regular "
"function, then you have to rename either the method name, or the regular "
"function name to resolve the name clash."
msgstr ""

#: ../../language/error_codes/E1039.md:43
msgid ""
"fn f_(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  println(f_(A(3)))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1040.md:1
msgid "E1040"
msgstr ""

#: ../../language/error_codes/E1040.md:3
msgid ""
"This method is declared as `T::f`, Calling this kind of method directly "
"via name(..) is deprecated, use qualified syntax `T::f(..)`, or declare "
"the method as `fn f(self : A, ..)` instead."
msgstr ""

#: ../../language/error_codes/E1040.md:9
msgid ""
"type A Int\n"
"\n"
"fn A::f(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  let _ = f(A(1))\n"
"  // Warning:\n"
"  // This method is declared as A::f, calling this kind of method "
"directly via\n"
"  // f(..) is deprecated, use qualified syntax A::f(..), or declare the "
"method\n"
"  // as `fn f(self : A, ..)` instead.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1040.md:27
msgid "You can either modify the calling of this function at call sites:"
msgstr ""

#: ../../language/error_codes/E1040.md:29
msgid ""
"fn main {\n"
"  let _ = A::f(A(1))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E1040.md:35
msgid "Or you can define the method as:"
msgstr ""

#: ../../language/error_codes/E1040.md:37
msgid ""
"fn f(self : A) -> Int {\n"
"  self._\n"
"}\n"
"\n"
"fn main {\n"
"  let _ = f(A(1))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E2000.md:1
msgid "E2000"
msgstr ""

#: ../../language/error_codes/E2000.md:3
msgid ""
"The usage of function (type, trait, etc.) is flagged with alert. Usually,"
" alert message comes with a alert kind and a detailed description of the "
"alert. If you are using the function from a library, these alerts are set"
" by the library author to provide some more information on the usage of "
"the function"
msgstr ""

#: ../../language/error_codes/E2000.md:8
msgid "There are some common alerts that you may encounter:"
msgstr ""

#: ../../language/error_codes/E2000.md:10
msgid ""
"`deprecated`: indicates the function (type, trait, etc) is deprecated and"
" should not be used or migrate to new APIs."
msgstr ""

#: ../../language/error_codes/E2000.md:12
msgid ""
"`unsafe`: indicates this API panics, breaks internal invariants, has "
"undefined behavior under some circumstances. The concrete semantics of "
"this kind of alerts may be different across packages, and please consult "
"the documentation or the author of these packages for further details."
msgstr ""

#: ../../language/error_codes/E2000.md:19
msgid ""
"/// @alert deprecated \"Use `greet` instead\"\n"
"fn greeting() -> String {\n"
"  \"Hello!\"\n"
"}\n"
"\n"
"fn greet(name~ : String = \"\") -> String {\n"
"  if name != \"\" {\n"
"    \"Hello!\"\n"
"  } else {\n"
"    \"Hello, \\{name}!\"\n"
"  }\n"
"}\n"
"\n"
"fn main() -> Unit {\n"
"  println(greeting())\n"
"  //      ^~~~~~~~ Warning (Alert deprecated): Use `greet` instead(2000)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E2000.md:41
msgid ""
"One way to fix the alert, is to change your code as suggested by the "
"message (like `deprecated`):"
msgstr ""

#: ../../language/error_codes/E2000.md:43
msgid ""
"// ... code in the example above ...\n"
"fn main() -> Unit {\n"
"  println(greet(name=\"world\"))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E2000.md:50
msgid ""
"If you clearly know what you are doing and would like to suppress the "
"alert, you can change the `moon.pkg.json` file for packages where you "
"would like to disable **this kind of alert**. For example:"
msgstr ""

#: ../../language/error_codes/E2000.md:52
msgid ""
"{\n"
"  // ... other fields in the file\n"
"  \"alert-list\": \"-deprecated\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E2000.md:59
msgid "NOTE: There is no way to disable alerts for a line/file."
msgstr ""

#: ../../language/error_codes/E3001.md:1
msgid "E3001"
msgstr ""

#: ../../language/error_codes/E3001.md:3
msgid "This source files contains invalid or incomplete tokens."
msgstr ""

#: ../../language/error_codes/E3001.md:7
msgid ""
"fn main {\n"
"  println('3)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3001.md:13
msgid "This example gives the following error on line 2:"
msgstr ""

#: ../../language/error_codes/E3001.md:15
msgid "Lexing error: unrecognized character u32:0x27\n"
msgstr ""

#: ../../language/error_codes/E3001.md:19
msgid ""
"... which indicates that the compiler don't know how to interpret the "
"dangling character `'` (ASCII 0x27) on that line as a part of a MoonBit "
"token."
msgstr ""

#: ../../language/error_codes/E3001.md:25
msgid ""
"Change your code to strictly follow the MoonBit syntax rules, so that it "
"only contains valid MoonBit tokens."
msgstr ""

#: ../../language/error_codes/E3001.md:28
msgid "In the above example, the missing closing apostrophe should be added:"
msgstr ""

#: ../../language/error_codes/E3001.md:30
msgid ""
"fn main {\n"
"  println('3')\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3002.md:1
msgid "E3002"
msgstr ""

#: ../../language/error_codes/E3002.md:3
msgid "This source files contains errors in the syntax of the code."
msgstr ""

#: ../../language/error_codes/E3002.md:7
msgid ""
"fn main() -> Unit {\n"
"  println(\"Hello, world!\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3002.md:13
msgid "This example gives the following error on line 3:"
msgstr ""

#: ../../language/error_codes/E3002.md:15
msgid "Parse error, unexpected token `}`, you may expect `,` or `)`.\n"
msgstr ""

#: ../../language/error_codes/E3002.md:19
msgid ""
"... which indicates a missing closing parenthesis (`)`) in the `println` "
"function call."
msgstr ""

#: ../../language/error_codes/E3002.md:23
msgid "Change your code to strictly follow the MoonBit syntax rules."
msgstr ""

#: ../../language/error_codes/E3002.md:25
msgid "In the above example, the missing closing parenthesis should be added:"
msgstr ""

#: ../../language/error_codes/E3003.md:1
msgid "E3003"
msgstr ""

#: ../../language/error_codes/E3003.md:3
msgid "`init` and `main` function must have no arguments and no return value."
msgstr "`init` 与 `main` 函数不得有参数列表或返回类型。"

#: ../../language/error_codes/E3003.md:7
msgid ""
"fn main() -> Unit {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3003.md:15
msgid "Remove the argument list and return type annotation, as:"
msgstr ""

#: ../../language/error_codes/E3004.md:1
msgid "E3004"
msgstr ""

#: ../../language/error_codes/E3004.md:3
msgid ""
"Missing parameters list. Add `()` after the name of the function if it "
"takes 0 parameter."
msgstr ""

#: ../../language/error_codes/E3004.md:8
msgid ""
"fn greet {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3004.md:16
msgid "Add `()` after the function name."
msgstr ""

#: ../../language/error_codes/E3004.md:18
msgid ""
"fn greet() {\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3005.md:1
msgid "E3005"
msgstr ""

#: ../../language/error_codes/E3005.md:3
msgid "There is no such visibility for the entity (function/type/trait/...)."
msgstr ""

#: ../../language/error_codes/E3005.md:5
msgid ""
"Usually, this means that you put an `priv` visibility modifier on a "
"entity is by-default private."
msgstr ""

#: ../../language/error_codes/E3005.md:8
msgid ""
"See the [Access "
"Control](https://docs.moonbitlang.com/en/latest/language/packages.html"
"#access-control) section of [MoonBit Language "
"Documentation](https://docs.moonbitlang.com/en/latest/language/index.html)"
" for a detailed explanaion on the visibility in MoonBit."
msgstr ""

#: ../../language/error_codes/E3005.md:16
msgid "priv let value = 3\n"
msgstr ""

#: ../../language/error_codes/E3005.md:22
msgid "Remove the visibility modifier from the definition of the entity:"
msgstr ""

#: ../../language/error_codes/E3005.md:24
msgid "let value = 3 // This is already `priv` by default.\n"
msgstr ""

#: ../../language/error_codes/E3006.md:1
msgid "E3006"
msgstr ""

#: ../../language/error_codes/E3006.md:3
msgid "There is no individual visibility control fro enum constructors."
msgstr ""

#: ../../language/error_codes/E3006.md:5
msgid ""
"Usually, this means that you put an `priv` or `pub` visibility modifier "
"on a enum constructor."
msgstr ""

#: ../../language/error_codes/E3006.md:9
msgid ""
"enum A {\n"
"  priv A1\n"
"  pub A2\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3006.md:18
msgid ""
"Remove the visibility modifier from the definition of the enum "
"constructor:"
msgstr ""

#: ../../language/error_codes/E3006.md:20
msgid ""
"enum A {\n"
"  A1\n"
"  A2\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3007.md:1
msgid "E3007"
msgstr ""

#: ../../language/error_codes/E3007.md:3
msgid ""
"Wrong location of `..` in pattern match. Put `..` at the end of the "
"pattern."
msgstr ""

#: ../../language/error_codes/E3007.md:7
msgid ""
"struct S {\n"
"  a : Int\n"
"  b : Int\n"
"  c : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { a : 1, b : 2, c : 3 }\n"
"  let { a, .., c } = s\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3007.md:22
msgid ""
"// ...\n"
"fn main {\n"
"  // ...\n"
"  let { a, c, .. } = s\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3008.md:1
msgid "E3008"
msgstr ""

#: ../../language/error_codes/E3008.md:3
msgid ""
"There are multiple `..` patterns in array pattern. Remove until there is "
"only one `..` pattern in array pattern."
msgstr ""

#: ../../language/error_codes/E3008.md:7
msgid ""
"fn main {\n"
"  let array = [1, 2, 3, 4, 5]\n"
"  let [fst, .., .., snd] = array\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3008.md:16
msgid "Remove the extra `..` pattern."
msgstr ""

#: ../../language/error_codes/E3008.md:18
msgid ""
"fn main {\n"
"  // ...\n"
"  let [fst, .., snd] = array\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3009.md:1
msgid "E3009"
msgstr ""

#: ../../language/error_codes/E3009.md:3
msgid "Record pattern cannot contain only `..`, use wildcard pattern `_` instead."
msgstr ""

#: ../../language/error_codes/E3009.md:7
msgid ""
"struct Point {\n"
"  x: Int,\n"
"  y: Int\n"
"}\n"
"\n"
"fn process_point(p: Point) {\n"
"  match p {\n"
"    { .. } -> println(\"Got a point\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3009.md:22
msgid "Use the wildcard pattern `_` instead of `{ .. }`:"
msgstr ""

#: ../../language/error_codes/E3009.md:24
msgid ""
"struct Point {\n"
"  x: Int,\n"
"  y: Int\n"
"}\n"
"\n"
"fn process_point(p: Point) {\n"
"  match p {\n"
"    _ -> println(\"Got a point\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3009.md:37
msgid ""
"You can also use `{ .. }` along with other fields if you want to match "
"specific fields:"
msgstr ""

#: ../../language/error_codes/E3009.md:39
msgid ""
"fn process_point(p: Point) {\n"
"  match p {\n"
"    { x: 0, .. } -> println(\"Point on y-axis\")\n"
"    _ -> println(\"Other point\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3010.md:1
msgid "E3010"
msgstr ""

#: ../../language/error_codes/E3010.md:3
msgid "Only labelled arguments can have default value."
msgstr ""

#: ../../language/error_codes/E3010.md:7
msgid ""
"fn greet(name = \"World\") {\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3010.md:15
msgid "Use a labelled argument with `~` if you want to provide a default value:"
msgstr ""

#: ../../language/error_codes/E3010.md:17
msgid ""
"fn greet(~name = \"World\") {\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
"\n"
"// Can be called as:\n"
"greet() // Uses default value \"World\"\n"
"greet(~name = \"Alice\") // Uses provided value \"Alice\"\n"
msgstr ""

#: ../../language/error_codes/E3010.md:27
msgid ""
"Or remove the default value if you want to keep it as a positional "
"argument:"
msgstr ""

#: ../../language/error_codes/E3010.md:29
msgid ""
"fn greet(name: String) {\n"
"  println(\"Hello, \" + name + \"!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3011.md:1
msgid "E3011"
msgstr ""

#: ../../language/error_codes/E3011.md:3
msgid ""
"The assignment contains an invalid left-hand-side (LHS) expression, such "
"as a constant or a constructor."
msgstr ""

#: ../../language/error_codes/E3011.md:8
msgid ""
"const N = 4\n"
"\n"
"fn main {\n"
"  N = 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3011.md:18
msgid ""
"Change the LHS to a valid mutable memory location, such as a mutable "
"variable or a mutable field:"
msgstr ""

#: ../../language/error_codes/E3011.md:21
msgid ""
"fn main {\n"
"  let mut n = 4\n"
"  n = 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3012.md:1
msgid "E3012"
msgstr ""

#: ../../language/error_codes/E3012.md:3
msgid ""
"Record pattern and map pattern cannot be mixed. The key in map pattern "
"must be a literal, while the key in record pattern must be the field "
"name."
msgstr ""

#: ../../language/error_codes/E3012.md:8
msgid ""
"struct S {\n"
"  value : Int\n"
"}\n"
"\n"
"pub fn S::op_get(self : S, index : String) -> Int? {\n"
"  if index == \"value\" {\n"
"    return Some(self.value)\n"
"  }\n"
"  return None\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { value: 42 }\n"
"  match s {\n"
"    { \"value\": value, value } => println(\"Value is: \\{value}\") // "
"Error: Record pattern and map pattern cannot be mixed.\n"
"    _ => println(\"No value\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3012.md:31
msgid ""
"Remove either the map pattern part or the record pattern part from the "
"pattern."
msgstr ""

#: ../../language/error_codes/E3012.md:33
msgid ""
"fn main {\n"
"  let s : S = { value: 42 }\n"
"  match s {\n"
"    { \"value\": value } => println(\"Value is: \\{value}\")\n"
"    _ => println(\"No value\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3012.md:45
msgid ""
"fn main {\n"
"  let s : S = { value: 42 }\n"
"  match s {\n"
"    { value } => println(\"Value is: \\{value}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3014.md:1
msgid "E3014"
msgstr ""

#: ../../language/error_codes/E3014.md:3
msgid ""
"Inline wasm syntax error. MoonBit will check if the inline wasm syntax is"
" correct, including:"
msgstr ""

#: ../../language/error_codes/E3014.md:5
msgid "If the parenthesis are correctly matched."
msgstr ""

#: ../../language/error_codes/E3014.md:6
msgid "If the wasm instructions are correctly formatted."
msgstr ""

#: ../../language/error_codes/E3014.md:10
msgid ""
"extern \"wasm\" fn i32_load(addr : Int) -> Int = // Error: Inline wasm "
"syntax error: unmatched parenthesis at 1:1-1:57\n"
"  #|(func (param i32) (result i32)\n"
"  #| (i32.load (local.get 0))\n"
msgstr ""

#: ../../language/error_codes/E3014.md:18
msgid "Fix the inline wasm syntax as suggested by the warning message."
msgstr ""

#: ../../language/error_codes/E3014.md:20
msgid ""
"extern \"wasm\" fn i32_load(addr : Int) -> Int =\n"
"  #|(func (param i32) (result i32)\n"
"  #| (i32.load (local.get 0)))\n"
msgstr ""

#: ../../language/error_codes/E3015.md:1
msgid "E3015"
msgstr ""

#: ../../language/error_codes/E3015.md:3
msgid "The parameter already has default value `None`."
msgstr ""

#: ../../language/error_codes/E3015.md:5
msgid "In MoonBit, the optional parameter has one of the two following forms:"
msgstr ""

#: ../../language/error_codes/E3015.md:7
msgid "Optional parameter with default value:"
msgstr ""

#: ../../language/error_codes/E3015.md:9
msgid ""
"fn f(a~ : Int = 0) -> Unit {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3015.md:15
msgid ""
"Optional parameter with no default value. In this case, when the "
"parameter is not provided, it is `None` by default."
msgstr ""

#: ../../language/error_codes/E3015.md:17
msgid ""
"fn f(a? : Int) -> Unit { // a has type Int?\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3015.md:23
msgid ""
"Therefore, if the optional parameter has a default value of `None`, it is"
" redundant and should be removed."
msgstr ""

#: ../../language/error_codes/E3015.md:27
msgid ""
"fn f(a? : Int = None) -> Unit { // Error: The parameter a? already has "
"default value `None`.\n"
"  println(a)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3015.md:35
msgid "Remove the `= None` part from the optional parameter."
msgstr ""

#: ../../language/error_codes/E3015.md:37
msgid ""
"fn f(a? : Int) -> Unit {\n"
"  println(a)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3016.md:1
msgid "E3016"
msgstr ""

#: ../../language/error_codes/E3016.md:3
msgid "Unexpected `~` in argument. Did you mean `label=pattern` or `label~`?"
msgstr ""

#: ../../language/error_codes/E3016.md:7
msgid ""
"enum A {\n"
"  A(b~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(b=1) {\n"
"    A(b~=c) => {\n"
"      println(\"Hello, world! \\{c}\") // Error: unexpected `~` in "
"argument. Did you mean `label=pattern` or `label~`?\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3016.md:23
msgid "Replace `b~` with `b=` or `b~` as appropriate."
msgstr ""

#: ../../language/error_codes/E3016.md:25
msgid ""
"enum A {\n"
"  A(b~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(b=1) {\n"
"    A(b~) => {\n"
"      println(\"Hello, world! \\{b}\")\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3016.md:41
msgid ""
"enum A {\n"
"  A(b~ : Int)\n"
"}\n"
"\n"
"fn main {\n"
"  match A(b=1) {\n"
"    A(b=c) => {\n"
"      println(\"Hello, world! \\{c}\")\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3017.md:1
msgid "E3017"
msgstr ""

#: ../../language/error_codes/E3017.md:3
msgid "JSON parse error. This will only appear in `moon.pkg.json` files only."
msgstr ""

#: ../../language/error_codes/E3017.md:5
msgid ""
"It is very like that the editor you are using will have support for JSON "
"installed (for example, Visual Studio Code has a built-in JSON parser). "
"This error is likely to be caused by a missing comma or a missing closing"
" brace."
msgstr ""

#: ../../language/error_codes/E3017.md:11
msgid ""
"{\n"
"  \"is-main\": true\n"
"  \"import\": [] // Error: Expect_comma_or_rbrace\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3017.md:20
msgid ""
"{\n"
"  \"is-main\": true,\n"
"  \"import\": []\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:1
msgid "E3018"
msgstr ""

#: ../../language/error_codes/E3018.md:3
msgid "Bounds of range pattern must be constant, named constant or wildcard."
msgstr ""

#: ../../language/error_codes/E3018.md:5
#, fuzzy
msgid "Errnoeous example"
msgstr "错误示例："

#: ../../language/error_codes/E3018.md:7
msgid ""
"fn main {\n"
"  let a = 3\n"
"  match 0 {\n"
"    0..<a => println(\"Between 0 and 3\") // Error: Bounds of range "
"pattern must be constant, named constant or wildcard.\n"
"    _ => println(\"Not between 0 and 3\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:19
msgid "You can either lift the variable `a` to a named constant:"
msgstr ""

#: ../../language/error_codes/E3018.md:21
msgid ""
"const A = 3\n"
"fn main {\n"
"  match 0 {\n"
"    0..<A => println(\"Between 0 and 3\")\n"
"    _ => println(\"Not between 0 and 3\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:31
msgid "Or, you can use the constant value directly:"
msgstr ""

#: ../../language/error_codes/E3018.md:33
msgid ""
"fn main {\n"
"  match 0 {\n"
"    0..<3 => println(\"Between 0 and 3\")\n"
"    _ => println(\"Not between 0 and 3\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:42
msgid "Or, you can use a wildcard:"
msgstr ""

#: ../../language/error_codes/E3018.md:44
msgid ""
"fn main {\n"
"  let a = 3\n"
"  match 0 {\n"
"    0..<_ => println(\"Big than or equal to 0\")\n"
"    _ => println(\"Less than 0\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3018.md:54
msgid "Notice, using wildcard alters the meaning of this range pattern."
msgstr ""

#: ../../language/error_codes/E3019.md:1
msgid "E3019"
msgstr ""

#: ../../language/error_codes/E3019.md:3
msgid "Inclusive range pattern `a..=b` cannot have `_` as upper bound."
msgstr ""

#: ../../language/error_codes/E3019.md:5
msgid ""
"Writing `a..=_` does not make sense, because `_` is a wildcard that "
"matches any value. It is unclear what does \"equals to any value\" mean. "
"If you want to express the meaning of \"greater than or equal to `a`\", "
"you can use `a..<_` instead."
msgstr ""

#: ../../language/error_codes/E3019.md:12
msgid ""
"fn main {\n"
"  match 0 {\n"
"    0..=_ => println(\"Big than or equal to 0\") // Error: Inclusive "
"range pattern `a..=b` cannot have `_` as upper bound\n"
"    _ => println(\"Less than 0\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3019.md:23
msgid "Replace `_` with `<`:"
msgstr ""

#: ../../language/error_codes/E3019.md:25
msgid ""
"fn main {\n"
"  match 0 {\n"
"    0..<_ => println(\"Big than or equal to 0\")\n"
"    _ => println(\"Less than 0\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3020.md:1
msgid "E3020"
msgstr ""

#: ../../language/error_codes/E3020.md:3
msgid ""
"Unexpected `=` in struct expression. The correct syntax for struct "
"expression is `{ field: expression }`."
msgstr ""

#: ../../language/error_codes/E3020.md:8
msgid ""
"struct S {\n"
"  a : Int\n"
"  b : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { a : 1, b : 2 }\n"
"  let ss = { ..s, a = 1 } // Error: Unexpected `=` in struct expression.\n"
"  ignore(ss)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3020.md:23
msgid "Change the struct expression to use the correct syntax:"
msgstr ""

#: ../../language/error_codes/E3020.md:25
msgid ""
"struct S {\n"
"  a : Int\n"
"  b : Int\n"
"}\n"
"\n"
"fn main {\n"
"  let s : S = { a : 1, b : 2 }\n"
"  let ss = { ..s, a : 1 }\n"
"  ignore(ss)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3800.md:1
msgid "E3800"
msgstr ""

#: ../../language/error_codes/E3800.md:3
msgid "Expecting a newline or `;` here, but encountered another delimiter."
msgstr ""

#: ../../language/error_codes/E3800.md:5
msgid ""
"Constructors in `enum` definition, fields in `struct` definition, and "
"constructors in error type `type!` definition, should be separated by a "
"newline or a `;`. It is so common for AI to generate code with a wrong "
"delimiter `,`, and we specifically catch this error to help you and AI "
"fix it."
msgstr ""

#: ../../language/error_codes/E3800.md:12
msgid ""
"enum V {\n"
"  A, // Error: Expecting a newline or `;` here, but encountered another "
"delimiter `,`.\n"
"}\n"
"\n"
"struct S {\n"
"  a : Int, // Error: Expecting a newline or `;` here, but encountered "
"another delimiter `,`.\n"
"}\n"
"\n"
"type! E {\n"
"  A, // Error: Expecting a newline or `;` here, but encountered another "
"delimiter `,`.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E3800.md:28
msgid ""
"Replace `,` with a newline or `;` as appropriate. We suggest using a "
"newline since it conforms to the MoonBit style suggested by the MoonBit "
"formatter."
msgstr ""

#: ../../language/error_codes/E3800.md:31
msgid ""
"enum V {\n"
"  A\n"
"}\n"
"\n"
"struct S {\n"
"  a : Int\n"
"}\n"
"\n"
"type! E {\n"
"  A\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4000.md:1
msgid "E4000"
msgstr ""

#: ../../language/error_codes/E4000.md:3
msgid "Generic type variable name is already used."
msgstr ""

#: ../../language/error_codes/E4000.md:7
msgid ""
"struct Container[T, T] {\n"
"  value : T\n"
"}\n"
"\n"
"fn transform[A, A](x : A) -> A {\n"
"  x\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4000.md:19
msgid "Use different names for type variables:"
msgstr ""

#: ../../language/error_codes/E4000.md:21
msgid ""
"struct Container[T1, T2] {\n"
"  value : T1\n"
"}\n"
"\n"
"fn transform[A, B](x : A) -> B {\n"
"  // ... implementation\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4000.md:31
msgid "Or remove the duplicate type parameter if you meant to use the same type:"
msgstr ""

#: ../../language/error_codes/E4000.md:33
msgid ""
"struct Container[T] {\n"
"  value : T\n"
"}\n"
"\n"
"fn transform[A](x : A) -> A {\n"
"  x\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4001.md:1
msgid "E4001"
msgstr ""

#: ../../language/error_codes/E4001.md:3
msgid "A field with different visibility cannot be declared within a struct."
msgstr ""

#: ../../language/error_codes/E4001.md:5 ../../language/error_codes/E4002.md:5
#: ../../language/error_codes/E4003.md:5 ../../language/error_codes/E4004.md:6
#: ../../language/error_codes/E4006.md:5 ../../language/error_codes/E4008.md:5
#: ../../language/error_codes/E4009.md:5 ../../language/error_codes/E4010.md:5
#: ../../language/error_codes/E4011.md:5 ../../language/error_codes/E4012.md:5
#: ../../language/error_codes/E4013.md:5 ../../language/error_codes/E4014.md:5
#: ../../language/error_codes/E4015.md:5 ../../language/error_codes/E4016.md:5
#: ../../language/error_codes/E4017.md:5 ../../language/error_codes/E4018.md:5
#: ../../language/error_codes/E4019.md:5 ../../language/error_codes/E4020.md:5
#: ../../language/error_codes/E4021.md:5 ../../language/error_codes/E4023.md:5
#: ../../language/error_codes/E4024.md:5 ../../language/error_codes/E4025.md:5
#: ../../language/error_codes/E4026.md:5 ../../language/error_codes/E4027.md:5
#: ../../language/error_codes/E4028.md:5 ../../language/error_codes/E4029.md:5
#: ../../language/error_codes/E4030.md:5 ../../language/error_codes/E4031.md:5
#: ../../language/error_codes/E4033.md:5 ../../language/error_codes/E4034.md:5
#: ../../language/error_codes/E4036.md:5 ../../language/error_codes/E4037.md:5
#: ../../language/error_codes/E4038.md:5 ../../language/error_codes/E4039.md:5
#: ../../language/error_codes/E4040.md:5 ../../language/error_codes/E4041.md:5
#: ../../language/error_codes/E4043.md:5 ../../language/error_codes/E4044.md:5
#: ../../language/error_codes/E4045.md:5 ../../language/error_codes/E4046.md:5
msgid "Erroneous Example"
msgstr "错误示例："

#: ../../language/error_codes/E4001.md:7
msgid ""
"priv struct S {\n"
"  pub field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4001.md:13
msgid ""
"This example declares a field with public visibility within a struct with"
" private visibility, which is not allowed and will give the following "
"error on line 2:"
msgstr ""

#: ../../language/error_codes/E4001.md:17
msgid "A public field cannot be declared within a private struct.\n"
msgstr ""

#: ../../language/error_codes/E4001.md:23
#: ../../language/error_codes/E4002.md:22
msgid "Change the visibility of the field to match the visibility of the struct:"
msgstr ""

#: ../../language/error_codes/E4001.md:25
#, fuzzy
msgid ""
"priv struct S {\n"
"  field: Int\n"
"}\n"
msgstr "对于结构体字段"

#: ../../language/error_codes/E4001.md:31
msgid ""
"We could have written `priv field: Int` instead of `field: Int` as well, "
"but it is not necessary, as all fields in a private struct are private by"
" default."
msgstr ""

#: ../../language/error_codes/E4002.md:1
msgid "E4002"
msgstr ""

#: ../../language/error_codes/E4002.md:3
msgid "The modifier is not supported here."
msgstr ""

#: ../../language/error_codes/E4002.md:7
msgid ""
"pub struct S {\n"
"  pub(open) field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4002.md:13
msgid ""
"This example declares a field with the `pub(open)` visibility modifier, "
"which is not allowed and will give the following error on line 2:"
msgstr ""

#: ../../language/error_codes/E4002.md:16
msgid "The public open modifier is not supported here\n"
msgstr ""

#: ../../language/error_codes/E4002.md:24
msgid ""
"pub struct S {\n"
"  field: Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4002.md:30
msgid ""
"We could have written `pub field: Int` instead of `field: Int` as well, "
"but it is not necessary, as all fields in a public struct are public by "
"default."
msgstr ""

#: ../../language/error_codes/E4003.md:1
msgid "E4003"
msgstr ""

#: ../../language/error_codes/E4003.md:3
msgid ""
"This is a reserved type name. Cannot declare it as a type variable, type,"
" or trait."
msgstr ""

#: ../../language/error_codes/E4003.md:7
msgid "struct Error {}\n"
msgstr ""

#: ../../language/error_codes/E4003.md:11
msgid ""
"`Error` is the reserved name for the built-in error type, so it cannot be"
" used for a custom type. This will give the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4003.md:14
msgid "\"Error\" is a reserved type name. Cannot declare it as type\n"
msgstr ""

#: ../../language/error_codes/E4003.md:20
msgid "Consider using another name for your type, such as `MyError` or `Error_`."
msgstr ""

#: ../../language/error_codes/E4003.md:22
msgid "struct MyError {}\n"
msgstr ""

#: ../../language/error_codes/E4004.md:1
msgid "E4004"
msgstr ""

#: ../../language/error_codes/E4004.md:3
msgid ""
"Trait methods cannot have type parameters (be polymorphic). MoonBit "
"currently does not support generic/polymorphic methods within trait "
"definitions."
msgstr ""

#: ../../language/error_codes/E4004.md:8
msgid ""
"trait Stringer {\n"
"  stringify[T: Show](Self, T) -> String\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4004.md:16
msgid "Consider using dynamic dispatch instead of generics:"
msgstr ""

#: ../../language/error_codes/E4004.md:18
msgid ""
"trait Stringer {\n"
"  stringify(Self, &Show) -> String\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4005.md:1
msgid "E4005"
msgstr ""

#: ../../language/error_codes/E4005.md:3
msgid ""
"This error occurs when a trait has multiple declarations of the same "
"method name. Each method in a trait must have a unique name to avoid "
"ambiguity."
msgstr ""

#: ../../language/error_codes/E4005.md:7
msgid ""
"trait Animal {\n"
"  make_sound(Self) -> String\n"
"  make_sound(Self) -> String  // Error: method make_sound is declared "
"twice\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4005.md:16
msgid ""
"Remove the duplicate method declaration and keep only one definition for "
"each method name:"
msgstr ""

#: ../../language/error_codes/E4005.md:18
msgid ""
"trait Animal {\n"
"  make_sound(Self) -> String  // Only declare the method once\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4005.md:24
msgid "If you need different method behaviors, use distinct method names:"
msgstr ""

#: ../../language/error_codes/E4005.md:26
msgid ""
"trait Animal {\n"
"  make_sound(Self) -> String\n"
"  make_loud_sound(Self) -> String  // Use a different name for different "
"behavior\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4006.md:1
msgid "E4006"
msgstr ""

#: ../../language/error_codes/E4006.md:3
msgid ""
"This error occurs when the same local function name is declared multiple "
"times within the same scope. Each local function name must be unique "
"within its scope."
msgstr ""

#: ../../language/error_codes/E4006.md:7
msgid ""
"fn main {\n"
"  fn helper() {\n"
"    1 + 1\n"
"  }\n"
"\n"
"  fn helper() { // E4006: local function 'helper' is already defined\n"
"    2 + 2\n"
"  }\n"
"\n"
"  helper()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4006.md:23
msgid "To fix this error, give each local function a unique name:"
msgstr ""

#: ../../language/error_codes/E4006.md:25
msgid ""
"fn main {\n"
"  fn helper1() {\n"
"    1 + 1\n"
"  }\n"
"\n"
"  fn helper2() {\n"
"    2 + 2\n"
"  }\n"
"\n"
"  helper1()\n"
"  helper2()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4006.md:40
msgid ""
"You can also move one of the functions to a different scope or merge the "
"functionality into a single function if they serve similar purposes."
msgstr ""

#: ../../language/error_codes/E4007.md:1
msgid "E4007"
msgstr ""

#: ../../language/error_codes/E4007.md:3
msgid ""
"When constructing a enum, the arguments passed to the constructor cannot "
"be unit `()`. MoonBit does not allow constructors to take unit as an "
"argument because it would be redundant - a constructor without arguments "
"already represents a singleton value."
msgstr ""

#: ../../language/error_codes/E4007.md:10
msgid ""
"enum Status {\n"
"  Done\n"
"  Pending\n"
"}\n"
"\n"
"fn main {\n"
"  let status = Done() // Error: constructor can't take unit as argument\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4007.md:23
msgid "Remove the unit argument from the constructor since it adds no value:"
msgstr ""

#: ../../language/error_codes/E4007.md:25
msgid ""
"// ...\n"
"fn main {\n"
"  let status = Done\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4007.md:32
msgid ""
"If you really need the constructor to take a unit arguments, explicitly "
"use `Unit` as its argument"
msgstr ""

#: ../../language/error_codes/E4007.md:35
msgid ""
"enum Status {\n"
"  Done(Unit)\n"
"  Pending\n"
"}\n"
"\n"
"fn main {\n"
"  let status = Done(())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4008.md:1
msgid "E4008"
msgstr ""

#: ../../language/error_codes/E4008.md:3
msgid "FFI function cannot have type parameters."
msgstr ""

#: ../../language/error_codes/E4008.md:7
msgid "extern \"js\" fn id[T](x: T) -> T = \"(x) => x\"\n"
msgstr ""

#: ../../language/error_codes/E4008.md:11
msgid ""
"The example declares an FFI function (marked `extern`) with a type "
"parameter, which is not allowed."
msgstr ""

#: ../../language/error_codes/E4008.md:16
msgid "Consider using a concrete type that suits your needs:"
msgstr ""

#: ../../language/error_codes/E4008.md:18
msgid "extern \"js\" fn int_id(x: Int) -> Int = \"(x) => x\"\n"
msgstr ""

#: ../../language/error_codes/E4008.md:22
msgid "For more complicated scenarios, consider adding an extra trait:"
msgstr ""

#: ../../language/error_codes/E4008.md:24
msgid ""
"///|\n"
"trait Ider {\n"
"  id(Self) -> Self\n"
"}\n"
"\n"
"///|\n"
"impl Ider for Int with id(self) { int_id(self) }\n"
msgstr ""

#: ../../language/error_codes/E4009.md:1
msgid "E4009"
msgstr ""

#: ../../language/error_codes/E4009.md:3
msgid "Match function expects a different number of arguments than provided."
msgstr ""

#: ../../language/error_codes/E4009.md:7
msgid ""
"let f = fn {\n"
"  0 => 0\n"
"  a, b => a + b\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4009.md:14
msgid ""
"The example defines a match function that has incoherent number of "
"arguments in different branches. This will result in the following error "
"on line 3:"
msgstr ""

#: ../../language/error_codes/E4009.md:17
msgid "Match function expects 1 arguments, but 2 arguments are provided.\n"
msgstr ""

#: ../../language/error_codes/E4009.md:23
msgid ""
"Change the branches so that the number of arguments are exactly the same "
"in all of them:"
msgstr ""

#: ../../language/error_codes/E4009.md:26
msgid ""
"let f = fn {\n"
"  0 => 0\n"
"  a => a\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4010.md:1
msgid "E4010"
msgstr ""

#: ../../language/error_codes/E4010.md:3
msgid "`pub` is not allowed on default implementation for traits."
msgstr ""

#: ../../language/error_codes/E4010.md:7
msgid ""
"pub(open) trait Stringer {\n"
"  stringify(Self) -> String\n"
"}\n"
"\n"
"pub impl Stringer with stringify(_self) { \"hey\" }\n"
msgstr ""

#: ../../language/error_codes/E4010.md:15
msgid ""
"In the example above, the `pub` keyword is used on the default "
"implementation of the `Stringer` trait, which is not allowed."
msgstr ""

#: ../../language/error_codes/E4010.md:20
msgid "Make sure to keep the default implementation private:"
msgstr ""

#: ../../language/error_codes/E4010.md:22
#: ../../language/error_codes/E4011.md:22
msgid ""
"pub(open) trait Stringer {\n"
"  stringify(Self) -> String\n"
"}\n"
"\n"
"impl Stringer with stringify(_self) { \"hey\" }\n"
msgstr ""

#: ../../language/error_codes/E4011.md:1
msgid "E4011"
msgstr ""

#: ../../language/error_codes/E4011.md:3
msgid "Type parameters are not allowed on default implementation for traits."
msgstr ""

#: ../../language/error_codes/E4011.md:7
msgid ""
"pub(open) trait Stringer {\n"
"  stringify(Self) -> String\n"
"}\n"
"\n"
"impl[T] Stringer with stringify(_self) { \"hey\" }\n"
msgstr ""

#: ../../language/error_codes/E4011.md:15
msgid ""
"The example above uses a type parameter `T` on the default implementation"
" of the `Stringer` trait, which is not allowed."
msgstr ""

#: ../../language/error_codes/E4011.md:20
msgid "Remove the type parameter from the default implementation:"
msgstr ""

#: ../../language/error_codes/E4012.md:1
msgid "E4012"
msgstr ""

#: ../../language/error_codes/E4012.md:3
msgid "Mutable constructor fields are only allowed on labelled arguments."
msgstr "只有带标签的构造器字段可以是可变的。"

#: ../../language/error_codes/E4012.md:7
msgid ""
"enum E {\n"
"  F(mut x : Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4012.md:13
msgid ""
"The example above declares an unlabeled mutable field `x` in the "
"constructor of the `F` variant of the `E` enum, which is not allowed."
msgstr ""

#: ../../language/error_codes/E4012.md:16
#: ../../language/error_codes/E4029.md:24
#, fuzzy
msgid "Suggestions"
msgstr "建议"

#: ../../language/error_codes/E4012.md:18
msgid "Add a label to the mutable field:"
msgstr ""

#: ../../language/error_codes/E4012.md:20
msgid ""
"enum E {\n"
"  F(mut x~ : Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4013.md:1
msgid "E4013"
msgstr ""

#: ../../language/error_codes/E4013.md:3
msgid ""
"This function has a type which expects a different number of arguments "
"than provided."
msgstr ""

#: ../../language/error_codes/E4013.md:7
msgid ""
"fn f() -> (() -> Int) {\n"
"  fn (x: Int) { x }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4013.md:13
msgid ""
"The example above declares a function `f` which expects no arguments, but"
" returns a function that expects one argument. This will give the "
"following error on line 2:"
msgstr ""

#: ../../language/error_codes/E4013.md:17
msgid ""
"This function has type () -> Int, which expects 0 argument(s), but is "
"given 1 argument(s).\n"
msgstr ""

#: ../../language/error_codes/E4013.md:23
msgid ""
"Adjust the code so that the number of arguments in the function type "
"matches the number of arguments in the function definition:"
msgstr ""

#: ../../language/error_codes/E4013.md:26
msgid ""
"fn f() -> (Int -> Int) {\n"
"  fn (x: Int) { x }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4013.md:32
#: ../../language/error_codes/E4046.md:29
msgid "... or:"
msgstr ""

#: ../../language/error_codes/E4013.md:34
msgid ""
"fn f(x: Int) -> (() -> Int) {\n"
"  fn() { x }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4014.md:1
msgid "E4014"
msgstr ""

#: ../../language/error_codes/E4014.md:3
msgid "Type Mismatch."
msgstr ""

#: ../../language/error_codes/E4014.md:7
msgid ""
"fn fst[X, Y] (a: X, b: Y) -> X {\n"
"  b\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4014.md:13
msgid ""
"The above example returns a value `b` of type `Y` on line 2, which is not"
" the same as the return type `X` of the function."
msgstr ""

#: ../../language/error_codes/E4014.md:18
msgid ""
"Please make sure to return a value of the same type as the return type of"
" the function."
msgstr ""

#: ../../language/error_codes/E4014.md:21
msgid "For instance, in the example above, you may write:"
msgstr ""

#: ../../language/error_codes/E4014.md:23
msgid ""
"fn fst[X, Y] (a: X, b: Y) -> X {\n"
"  a\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4015.md:1
msgid "E4015"
msgstr ""

#: ../../language/error_codes/E4015.md:3
msgid "Type has no method with the specified name."
msgstr ""

#: ../../language/error_codes/E4015.md:7
msgid "let hey = \"hey\".upper()\n"
msgstr ""

#: ../../language/error_codes/E4015.md:11
msgid ""
"The above example tries to call an inexistent method `upper()` on a "
"string literal, giving the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4015.md:14
msgid "Type String has no method upper.\n"
msgstr ""

#: ../../language/error_codes/E4015.md:20
msgid ""
"This is usually a typo or a misunderstanding of the methods available. "
"Please make sure to use the correct method name:"
msgstr ""

#: ../../language/error_codes/E4015.md:23
msgid "let hey = \"hey\".to_upper()\n"
msgstr ""

#: ../../language/error_codes/E4016.md:1
msgid "E4016"
msgstr ""

#: ../../language/error_codes/E4016.md:3
msgid ""
"Please implement the required method for the type to use the infix "
"operator."
msgstr ""

#: ../../language/error_codes/E4016.md:7
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = s + s\n"
msgstr ""

#: ../../language/error_codes/E4016.md:14
msgid ""
"The example above tries to use the infix operator `+` on a type `S` that "
"does not implement the required method `op_add`, giving the following "
"error on line 4:"
msgstr ""

#: ../../language/error_codes/E4016.md:18
msgid ""
"Please implement the method op_add for the type S to use the infix "
"operator \"+\".\n"
msgstr ""

#: ../../language/error_codes/E4016.md:24
msgid "Implement the required method for the type `S`:"
msgstr ""

#: ../../language/error_codes/E4016.md:26
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = s + s\n"
"\n"
"fn S::op_add(self : S, other : S) -> S {\n"
"  { v: self.v + other.v }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4017.md:1
msgid "E4017"
msgstr ""

#: ../../language/error_codes/E4017.md:3
msgid "Method of type is ambiguous, it may come from multiple traits."
msgstr ""

#: ../../language/error_codes/E4017.md:7
msgid ""
"struct S { v : Int } derive(Show)\n"
"\n"
"trait Tee { to_string(Self) -> String }\n"
"\n"
"impl Tee for S with to_string(_self) { \"Tee\" }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = s.to_string()\n"
msgstr ""

#: ../../language/error_codes/E4017.md:18
msgid ""
"The example above tries to call the method `to_string` on a type `S`, but"
" the method name comes from both `Show` and `Tee` traits, giving the "
"following error on line 8:"
msgstr ""

#: ../../language/error_codes/E4017.md:22
msgid ""
"Method to_string of type S is ambiguous, it may come from trait Tee or "
"Show\n"
msgstr ""

#: ../../language/error_codes/E4017.md:28
msgid "Disambiguate the method by specifying the trait it comes from:"
msgstr ""

#: ../../language/error_codes/E4017.md:30
msgid ""
"struct S { v : Int } derive(Show)\n"
"\n"
"trait Tee { to_string(Self) -> String }\n"
"\n"
"impl Tee for S with to_string(_self) { \"Tee\" }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = Tee::to_string(s)\n"
msgstr ""

#: ../../language/error_codes/E4018.md:1
msgid "E4018"
msgstr ""

#: ../../language/error_codes/E4018.md:3
msgid "Cannot resolve trait for the given type."
msgstr ""

#: ../../language/error_codes/E4018.md:7
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = Show::to_string(s)\n"
msgstr ""

#: ../../language/error_codes/E4018.md:14
msgid ""
"The example above tries to call the method `to_string` from the `Show` "
"trait on a type `S`, but since `S` does not implement that trait, it "
"gives the following error on line 4:"
msgstr ""

#: ../../language/error_codes/E4018.md:18
msgid "Type S does not implement trait Show: method output is missing\n"
msgstr ""

#: ../../language/error_codes/E4018.md:24
msgid "Implement the `Show` trait for the type `S`:"
msgstr ""

#: ../../language/error_codes/E4018.md:26
msgid ""
"struct S { v : Int }\n"
"\n"
"let s : S = { v: 3 }\n"
"let t = Show::to_string(s)\n"
"\n"
"impl Show for S with output(self, logger) {\n"
"  logger.write_object(self.v)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4019.md:1
msgid "E4019"
msgstr ""

#: ../../language/error_codes/E4019.md:3
msgid "The label is declared twice in this function."
msgstr ""

#: ../../language/error_codes/E4019.md:7
msgid ""
"fn f(g~ : Int, g~ : String) -> Int {\n"
"  g\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4019.md:13
msgid ""
"The above example declares the label `g` twice in the function `f`, which"
" is not allowed and gives the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4019.md:16
msgid "The label g~ is declared twice in this function, first in <FILE>.mbt:1:6\n"
msgstr ""

#: ../../language/error_codes/E4019.md:22
msgid "Rename one of the labels to avoid the conflict:"
msgstr ""

#: ../../language/error_codes/E4019.md:24
msgid ""
"fn f(g~ : Int, h~ : String) -> Int {\n"
"  g\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4020.md:1
msgid "E4020"
msgstr ""

#: ../../language/error_codes/E4020.md:3
msgid "Package not found in the loaded packages."
msgstr ""

#: ../../language/error_codes/E4020.md:7
msgid "let a = @boolean.to_int(true)\n"
msgstr ""

#: ../../language/error_codes/E4020.md:11
msgid ""
"The example above tries to call the method `to_int` in a package "
"`boolean`, but this package is not present in the list of loaded "
"packages, giving the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4020.md:15
msgid "Package \"boolean\" not found in the loaded packages.\n"
msgstr ""

#: ../../language/error_codes/E4020.md:21
msgid "Make sure the package name is valid."
msgstr ""

#: ../../language/error_codes/E4020.md:23
msgid ""
"If it is an external package, make sure that it is mentioned as one of "
"the imported packages in `moon.pkg.json` as well."
msgstr ""

#: ../../language/error_codes/E4020.md:26
msgid ""
"In the above example, the package name should be `@bool` instead of "
"`@boolean`:"
msgstr ""

#: ../../language/error_codes/E4020.md:28
#: ../../language/error_codes/E4021.md:25
msgid "let a = @bool.to_int(true)\n"
msgstr ""

#: ../../language/error_codes/E4021.md:1
msgid "E4021"
msgstr ""

#: ../../language/error_codes/E4021.md:3
msgid "The value identifier is unbound."
msgstr ""

#: ../../language/error_codes/E4021.md:7
msgid "let a = @bool.to_integer(true)\n"
msgstr ""

#: ../../language/error_codes/E4021.md:11
msgid ""
"The example above tries to call the method `to_integer` in a package "
"`@bool`, but this method is not present in the package `@bool`, giving "
"the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4021.md:15
msgid "Value to_integer not found in package `bool`.\n"
msgstr ""

#: ../../language/error_codes/E4021.md:21
msgid "Make sure the identifier is correct."
msgstr ""

#: ../../language/error_codes/E4021.md:23
msgid ""
"In the above example, the method name should be `to_int` instead of "
"`to_integer`:"
msgstr ""

#: ../../language/error_codes/E4023.md:1
msgid "E4023"
msgstr ""

#: ../../language/error_codes/E4023.md:3
msgid "The trait is not found."
msgstr ""

#: ../../language/error_codes/E4023.md:7
msgid "let a = true as &Sh0w\n"
msgstr ""

#: ../../language/error_codes/E4023.md:11
msgid ""
"The example above tries to cast a boolean value to an object of the "
"`Sh0w` trait, but this trait is not found in the current scope, giving "
"the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4023.md:15
msgid "The trait Sh0w is not found.\n"
msgstr ""

#: ../../language/error_codes/E4023.md:21
msgid "Make sure the trait name is correct:"
msgstr ""

#: ../../language/error_codes/E4023.md:23
msgid "let a = true as &Show\n"
msgstr ""

#: ../../language/error_codes/E4024.md:1
msgid "E4024"
msgstr ""

#: ../../language/error_codes/E4024.md:3
msgid "The type/trait is not found."
msgstr ""

#: ../../language/error_codes/E4024.md:7
msgid "let a = Sh0w::to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4024.md:11
msgid ""
"The example above tries to call the method `to_string` from the `Sh0w` "
"type (or trait), but this type (or trait) is not found in the current "
"scope, given the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4024.md:15
msgid "The type/trait Sh0w is not found.\n"
msgstr ""

#: ../../language/error_codes/E4024.md:21
msgid "Make sure the type (or trait) name is correct."
msgstr ""

#: ../../language/error_codes/E4024.md:23
msgid "In the above example, you can choose to use a proper trait name `Show`:"
msgstr ""

#: ../../language/error_codes/E4024.md:25
msgid "let a = Show::to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4024.md:29
msgid "... or a proper type name `Bool`:"
msgstr ""

#: ../../language/error_codes/E4024.md:31
#: ../../language/error_codes/E4025.md:27
msgid "let a = Bool::to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4025.md:1
msgid "E4025"
msgstr ""

#: ../../language/error_codes/E4025.md:3
msgid "Method has been defined for multiple types."
msgstr ""

#: ../../language/error_codes/E4025.md:7
msgid "let a = to_string(true)\n"
msgstr ""

#: ../../language/error_codes/E4025.md:11
msgid ""
"The example above tries to call the method `to_string` on a boolean "
"value, but this method has already been defined for multiple types so "
"that the compiler cannot properly deduce which method to call, giving the"
" following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4025.md:16
msgid ""
"Method to_string has been defined for the following types:\n"
"<FILE>.mbt:<LINE>:<COLUMN> String\n"
"<FILE>.mbt:<LINE>:<COLUMN> Int64\n"
"<SNIP>\n"
msgstr ""

#: ../../language/error_codes/E4025.md:25
msgid "Disambiguate the method by specifying the type it comes from:"
msgstr ""

#: ../../language/error_codes/E4026.md:1
msgid "E4026"
msgstr ""

#: ../../language/error_codes/E4026.md:3
msgid "The field is not found."
msgstr ""

#: ../../language/error_codes/E4026.md:7
msgid ""
"struct T { a : Int }\n"
"fn main {\n"
"  let t = { b: 42 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4026.md:14
msgid ""
"The example above tries to create a record with a field `b`, but no "
"record with such a field is found in the current scope, giving the above "
"error on line 3."
msgstr ""

#: ../../language/error_codes/E4026.md:20
msgid ""
"Make sure a record is available in the current scope, defined with the "
"correct field name:"
msgstr ""

#: ../../language/error_codes/E4026.md:23
msgid ""
"struct T { a : Int }\n"
"fn main {\n"
"  let t = { a: 42 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4026.md:30
msgid "... in the fix above, `t` is inferred to be of type `T`."
msgstr ""

#: ../../language/error_codes/E4027.md:1
msgid "E4027"
msgstr ""

#: ../../language/error_codes/E4027.md:3
msgid "Unused type parameter."
msgstr ""

#: ../../language/error_codes/E4027.md:7
msgid "fn id[T](a: Int) -> Int { a }\n"
msgstr ""

#: ../../language/error_codes/E4027.md:11
msgid ""
"The example above declares a type parameter `T` in the identity function "
"`id`, however `T` is not used anywhere in the function signature, giving "
"the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4027.md:15
msgid "Unused type parameter 'T'\n"
msgstr ""

#: ../../language/error_codes/E4027.md:21
msgid "Make sure the type parameter is used in the function signature:"
msgstr ""

#: ../../language/error_codes/E4027.md:23
msgid "fn id[T](a: T) -> T { a }\n"
msgstr ""

#: ../../language/error_codes/E4028.md:1
msgid "E4028"
msgstr ""

#: ../../language/error_codes/E4028.md:3
msgid "This expression has a type which is not a record."
msgstr ""

#: ../../language/error_codes/E4028.md:7
msgid ""
"struct T { a : Int }\n"
"let a : Int = { a: 42 }\n"
msgstr ""

#: ../../language/error_codes/E4028.md:12
msgid ""
"The example above tries to assign a record to a variable `a` of type "
"`Int`, which is not possible and gives the following error on line 2:"
msgstr ""

#: ../../language/error_codes/E4028.md:15
msgid "This expression has type Int, which is a Int type and not a record.\n"
msgstr ""

#: ../../language/error_codes/E4028.md:21
msgid "Make sure to use the correct type instead:"
msgstr ""

#: ../../language/error_codes/E4028.md:23
msgid ""
"struct T { a : Int }\n"
"let a : T = { a: 42 }\n"
msgstr ""

#: ../../language/error_codes/E4029.md:1
msgid "E4029"
msgstr ""

#: ../../language/error_codes/E4029.md:3
msgid "This expression has a type which is not a variant."
msgstr ""

#: ../../language/error_codes/E4029.md:7
msgid ""
"fn main {\n"
"  fn f {\n"
"    (a, b) => a + b\n"
"  }\n"
"  let a = f(None)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4029.md:16
msgid ""
"The example above tries to call a function `f` with a value `None`, which"
" is a variant of the `Option[_]` type, but `f` only accepts a tuple, "
"giving the following error on line 5:"
msgstr ""

#: ../../language/error_codes/E4029.md:20
msgid ""
"This expression has type (Int, Int), which is a tuple type and not a "
"variant.\n"
msgstr ""

#: ../../language/error_codes/E4029.md:26
msgid "Make sure to use a value of the correct type instead:"
msgstr ""

#: ../../language/error_codes/E4029.md:28
msgid ""
"fn main {\n"
"  fn f {\n"
"    (a, b) => a + b\n"
"  }\n"
"  let a = f((3, 4))\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4030.md:1
msgid "E4030"
msgstr ""

#: ../../language/error_codes/E4030.md:3
msgid "The record type does not have the specified field."
msgstr ""

#: ../../language/error_codes/E4030.md:7
msgid ""
"struct T { a : Int }\n"
"let t : T = { a: 42 }\n"
"let u : T = { ..t, b: 43 }\n"
msgstr ""

#: ../../language/error_codes/E4030.md:13
msgid ""
"The example above tries to assign an updated record with a field `b` to a"
" variable `u` of type `T`, but this field doesn't exist, giving the "
"following error on line 3:"
msgstr ""

#: ../../language/error_codes/E4030.md:17
msgid "The record type T does not have the field b.\n"
msgstr ""

#: ../../language/error_codes/E4030.md:23
msgid "Make sure to use the correct field instead:"
msgstr ""

#: ../../language/error_codes/E4030.md:25
msgid ""
"struct T { a : Int }\n"
"let t : T = { a: 42 }\n"
"let u : T = { ..t, a: 43 }\n"
msgstr ""

#: ../../language/error_codes/E4031.md:1
msgid "E4031"
msgstr ""

#: ../../language/error_codes/E4031.md:3
msgid "The constructor is not found."
msgstr ""

#: ../../language/error_codes/E4031.md:7
msgid ""
"enum U { V }\n"
"let v : U = W\n"
msgstr ""

#: ../../language/error_codes/E4031.md:12
msgid ""
"The example above tries to assign a variant `W` to a variable `v` of type"
" `U`, but this variant doesn't exist, giving the following error on line "
"2:"
msgstr ""

#: ../../language/error_codes/E4031.md:15
msgid "The variant type U does not have the constructor W.\n"
msgstr ""

#: ../../language/error_codes/E4031.md:21
msgid "Make sure to use the correct constructor instead:"
msgstr ""

#: ../../language/error_codes/E4031.md:23
msgid ""
"enum U { V }\n"
"let v : U = V\n"
msgstr ""

#: ../../language/error_codes/E4032.md:1
msgid "E4032"
msgstr ""

#: ../../language/error_codes/E4032.md:3
msgid "The type is undefined."
msgstr ""

#: ../../language/error_codes/E4033.md:1
msgid "E4033"
msgstr ""

#: ../../language/error_codes/E4033.md:3
msgid "There is no record definition with the specified fields."
msgstr ""

#: ../../language/error_codes/E4033.md:7
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  let c = { x: 2, w: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4033.md:14
msgid ""
"The example above tries to assign a record with fields `x` and `w` to a "
"variable `c`, but this field doesn't exist in any known record type, "
"giving the following error on line 3:"
msgstr ""

#: ../../language/error_codes/E4033.md:17
msgid "There is no record definition with the fields: x, w.\n"
msgstr ""

#: ../../language/error_codes/E4033.md:23
msgid "Make sure to use the correct field identifiers instead:"
msgstr ""

#: ../../language/error_codes/E4033.md:25
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  let c = { x: 2, y: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4034.md:1
msgid "E4034"
msgstr ""

#: ../../language/error_codes/E4034.md:3
msgid "Multiple possible record types detected, please add more annotation."
msgstr ""

#: ../../language/error_codes/E4034.md:7
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  struct T { x : Int; y : Int }\n"
"  let c = { x: 2, y: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4034.md:15
msgid ""
"The example above tries to assign a record with fields `x` and `y` to a "
"variable `c`, but this field combination matches both `S` and `T` types, "
"giving the following error on line 4:"
msgstr ""

#: ../../language/error_codes/E4034.md:18
msgid ""
"Multiple possible record types detected: T, S, please add more "
"annotation.\n"
msgstr ""

#: ../../language/error_codes/E4034.md:24
msgid "Disambiguate the record type by adding a type annotation:"
msgstr ""

#: ../../language/error_codes/E4034.md:26
msgid ""
"fn main {\n"
"  struct S { x : Int; y : Int }\n"
"  struct T { x : Int; y : Int }\n"
"  let c : S = { x: 2, y: 1 }\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4036.md:1
msgid "E4036"
msgstr ""

#: ../../language/error_codes/E4036.md:3
msgid "Cannot create values of the read-only type."
msgstr ""

#: ../../language/error_codes/E4036.md:7
msgid ""
"In `lib/lib.mbt`, we declare a struct `R` with a private field "
"`__private`:"
msgstr ""

#: ../../language/error_codes/E4036.md:9
msgid ""
"pub(all) struct R {\n"
"  x : Int\n"
"  priv __private : Int\n"
"}\n"
"\n"
"pub fn R::new(x: Int) -> R {\n"
"  {x, __private: 42}\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4036.md:20
msgid "In `main/main.mbt`, we try to create a value of type `R`:"
msgstr ""

#: ../../language/error_codes/E4036.md:22
msgid "let r : @lib.R = { x: 1, __private: 42 }\n"
msgstr ""

#: ../../language/error_codes/E4036.md:26
msgid "This gives the following error on line 1:"
msgstr ""

#: ../../language/error_codes/E4036.md:28
msgid ""
"Cannot create values of struct type @lib.R because it contains private "
"field(s).\n"
msgstr ""

#: ../../language/error_codes/E4036.md:34
msgid "Construct the value using the public constructor:"
msgstr ""

#: ../../language/error_codes/E4036.md:36
msgid "let r @lib.R = @lib.R::new(1)\n"
msgstr ""

#: ../../language/error_codes/E4037.md:1
msgid "E4037"
msgstr ""

#: ../../language/error_codes/E4037.md:3
msgid "Cannot perform action: package is not imported."
msgstr ""

#: ../../language/error_codes/E4037.md:7
msgid "In `main/main.mbt`, we try to call a function from `@middle`:"
msgstr ""

#: ../../language/error_codes/E4037.md:9
msgid ""
"fn main {\n"
"  let a = @middle.return_Obj().m()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:15
msgid ""
"In `middle/middle.mbt`, we define a function that returns an object of a "
"trait `Obj` defined in `@ty`:"
msgstr ""

#: ../../language/error_codes/E4037.md:18
msgid ""
"pub fn return_Obj() -> &@ty.Obj {\n"
"  @ty.T(42)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:24
msgid "In `ty/ty.mbt`, we define a trait `Obj` and a type `T` that implements it:"
msgstr ""

#: ../../language/error_codes/E4037.md:27
msgid ""
"pub(all) type T Int\n"
"\n"
"pub fn f(self: T) -> Unit {\n"
"  println(self._)\n"
"}\n"
"\n"
"pub(open) trait Obj {\n"
"  f(Self) -> Unit\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:39
msgid "... but in `main/moon.pkg.json` there is no mention of `@ty`:"
msgstr ""

#: ../../language/error_codes/E4037.md:41
msgid ""
"{\n"
"  \"import\": [\"<PACKAGE>/middle\"]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4037.md:47
msgid "This gives the following error on line 2 of `main/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E4037.md:49
msgid ""
"Cannot call method of type &@<PACKAGE>/ty.Obj: package @<PACKAGE>/ty is "
"not imported.\n"
msgstr ""

#: ../../language/error_codes/E4037.md:55
msgid "Make sure that all relevant packages are imported."
msgstr ""

#: ../../language/error_codes/E4037.md:57
msgid ""
"In the above example, this means importing both `@middle` and `@ty` in "
"`main/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4037.md:59
msgid ""
"{\n"
"  \"import\": [\"<PACKAGE>/middle\", \"<PACKAGE>/ty\"]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4038.md:1
msgid "E4038"
msgstr ""

#: ../../language/error_codes/E4038.md:3
msgid "Trait object for the type is not allowed."
msgstr ""

#: ../../language/error_codes/E4038.md:7
msgid ""
"fn main {\n"
"  let a = 3 as &Eq\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4038.md:13
msgid ""
"The example above tries to create an object of the `Eq` trait. This is "
"not allowed, as the trait is not object safe."
msgstr ""

#: ../../language/error_codes/E4038.md:16
msgid "The `Eq` trait is defined as follows:"
msgstr ""

#: ../../language/error_codes/E4038.md:18
msgid ""
"pub(open) trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4038.md:24
msgid "... which is why the following error is given on line 2:"
msgstr ""

#: ../../language/error_codes/E4038.md:26
msgid ""
"Trait object for Eq is not allowed: `Self` occur multiple times in the "
"type of method op_equal\n"
msgstr ""

#: ../../language/error_codes/E4038.md:32
msgid "Use an object-safe trait to create a trait object."
msgstr ""

#: ../../language/error_codes/E4038.md:34
msgid ""
"For a trait to be object-safe, its dispatchable functions must use and "
"only use the `Self` type as the first parameter. For example, `Show` is "
"such a trait:"
msgstr ""

#: ../../language/error_codes/E4038.md:37
msgid ""
"pub(open) trait Show {\n"
"  output(Self, &Logger) -> Unit\n"
"  to_string(Self) -> String\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4039.md:1
msgid "E4039"
msgstr ""

#: ../../language/error_codes/E4039.md:3
msgid "There is no method with the specified name in this trait."
msgstr ""

#: ../../language/error_codes/E4039.md:7
msgid "let a : String = Show::to_str(42)\n"
msgstr ""

#: ../../language/error_codes/E4039.md:11
msgid ""
"The example above tries to call the method `to_str` on the `Show` trait, "
"but the method is not defined in the trait, giving the following error on"
" line 1:"
msgstr ""

#: ../../language/error_codes/E4039.md:14
msgid "There is no method to_str in trait Show\n"
msgstr ""

#: ../../language/error_codes/E4039.md:20
msgid ""
"Make sure that the method name is spelled correctly and that it is "
"defined in the trait:"
msgstr ""

#: ../../language/error_codes/E4039.md:23
msgid "let a : String = Show::to_string(42)\n"
msgstr ""

#: ../../language/error_codes/E4040.md:1
msgid "E4040"
msgstr ""

#: ../../language/error_codes/E4040.md:3
msgid ""
"The type constructor expects a different number of arguments than "
"provided."
msgstr ""

#: ../../language/error_codes/E4040.md:7
msgid "let a : Option = Some(3)\n"
msgstr ""

#: ../../language/error_codes/E4040.md:11
msgid ""
"The example above tries to create an instance of the `Option` type. The "
"`Option` type is a generic type that expects a single type argument, but "
"the example does not provide any type arguments, giving the following "
"error on line 1:"
msgstr ""

#: ../../language/error_codes/E4040.md:16
msgid ""
"The type constructor Option expects 1 argument(s), but is here given 0 "
"argument(s).\n"
msgstr ""

#: ../../language/error_codes/E4040.md:22
msgid "Make sure to provide the correct number of type arguments:"
msgstr ""

#: ../../language/error_codes/E4040.md:24
#: ../../language/error_codes/E4041.md:19
msgid "let a : Option[Int] = Some(3)\n"
msgstr ""

#: ../../language/error_codes/E4041.md:1
msgid "E4041"
msgstr ""

#: ../../language/error_codes/E4041.md:3
msgid "Partial type is not allowed in toplevel declarations."
msgstr ""

#: ../../language/error_codes/E4041.md:7
msgid "let a : Option[_] = Some(3)\n"
msgstr ""

#: ../../language/error_codes/E4041.md:11
msgid ""
"The example above tries to create a top-level instance of the `Option[_]`"
" type. However, partial type annotations are not allowed in toplevel "
"declarations, giving the aforementioned error on line 1."
msgstr ""

#: ../../language/error_codes/E4041.md:17
msgid "Make sure to provide a complete type annotation:"
msgstr ""

#: ../../language/error_codes/E4042.md:1
msgid "E4042"
msgstr ""

#: ../../language/error_codes/E4042.md:3
msgid "Invalid stub type."
msgstr ""

#: ../../language/error_codes/E4043.md:1
msgid "E4043"
msgstr ""

#: ../../language/error_codes/E4043.md:3
msgid "The record field is defined or matched multiple times."
msgstr ""

#: ../../language/error_codes/E4043.md:7
msgid ""
"struct S { a : Int }\n"
"let a : Int = match S::{ a: 2, a: 3 } {\n"
"  { a: 2, a: 3 } => 4\n"
"  _ => 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4043.md:15
#, fuzzy
msgid "The example above tries to:"
msgstr "以下是抽象特征的示例："

#: ../../language/error_codes/E4043.md:17
msgid "Create a record with the field `a` defined multiple times."
msgstr ""

#: ../../language/error_codes/E4043.md:18
msgid "Destructure a record with the field `a` matched multiple times."
msgstr ""

#: ../../language/error_codes/E4043.md:20
msgid "... giving the following error on line 2:"
msgstr ""

#: ../../language/error_codes/E4043.md:22
msgid "The record field a is defined several times.\n"
msgstr ""

#: ../../language/error_codes/E4043.md:26
msgid "... and the following error on line 3:"
msgstr ""

#: ../../language/error_codes/E4043.md:28
msgid "The record field a is matched several times in this pattern.\n"
msgstr ""

#: ../../language/error_codes/E4043.md:34
msgid "Make sure that the record field is defined or matched only once:"
msgstr ""

#: ../../language/error_codes/E4043.md:36
msgid ""
"struct S { a : Int }\n"
"let a : Int = match S::{ a: 2 } {\n"
"  { a: 2 } => 4\n"
"  _ => 5\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4044.md:1
msgid "E4044"
msgstr ""

#: ../../language/error_codes/E4044.md:3
msgid "Record fields are missing. Use `..` to ignore them in patterns."
msgstr ""

#: ../../language/error_codes/E4044.md:7
msgid ""
"struct S { a : Int; b: Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { a: 2 } => 4\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4044.md:15
msgid ""
"The example above tries to match a record with a missing field `b`, "
"giving the following error on line 3:"
msgstr ""

#: ../../language/error_codes/E4044.md:18
msgid "Record fields b are unmatched, use `..` to ignore them.\n"
msgstr ""

#: ../../language/error_codes/E4044.md:24
msgid ""
"Make sure to provide all fields in the pattern, or simply ignore the "
"missing fields using `..`:"
msgstr ""

#: ../../language/error_codes/E4044.md:27
msgid ""
"struct S { a : Int; b: Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { a: 2, b: 3 } => 4\n"
"  { a: 2, .. } => 5\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4045.md:1
msgid "E4045"
msgstr ""

#: ../../language/error_codes/E4045.md:3
msgid "The field is not defined in the record type."
msgstr ""

#: ../../language/error_codes/E4045.md:7
msgid ""
"struct S { a : Int, b : Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { c: 2, .. } => 5\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4045.md:15
msgid ""
"The example above tries to match a record with a nonexistent field `c`, "
"giving the following error on line 3:"
msgstr ""

#: ../../language/error_codes/E4045.md:18
msgid "The fields c is not defined in the record type S.\n"
msgstr ""

#: ../../language/error_codes/E4045.md:24
msgid "Make sure to provide all fields with the correct names in the pattern."
msgstr ""

#: ../../language/error_codes/E4045.md:26
msgid ""
"struct S { a : Int, b : Int }\n"
"let a : Int = match S::{ a: 2, b: 3 } {\n"
"  { a: 2, .. } => 5\n"
"  _ => 6\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4046.md:1
msgid "E4046"
msgstr ""

#: ../../language/error_codes/E4046.md:3
msgid "A public definition cannot depend on private entities."
msgstr ""

#: ../../language/error_codes/E4046.md:7
msgid ""
"priv trait I { m(Self) }\n"
"pub impl I for Int with m(self) {}\n"
msgstr ""

#: ../../language/error_codes/E4046.md:12
msgid ""
"The above example tries to implement a private trait `I` for the type "
"`Int`, but the implementation itself is public, which is not allowed. "
"This gives the following error on line 2:"
msgstr ""

#: ../../language/error_codes/E4046.md:16
msgid "A public definition cannot depend on private trait\n"
msgstr ""

#: ../../language/error_codes/E4046.md:22
msgid "Adjust the visibility of the trait or the implementation to match:"
msgstr ""

#: ../../language/error_codes/E4046.md:24
msgid ""
"trait I { m(Self) -> Unit }\n"
"pub impl I for Int with m(self) {}\n"
msgstr ""

#: ../../language/error_codes/E4046.md:31
msgid ""
"priv trait I { m(Self) -> Unit }\n"
"impl I for Int with m(self) {}\n"
msgstr ""

#: ../../language/error_codes/E4047.md:1
msgid "E4047"
msgstr ""

#: ../../language/error_codes/E4047.md:3
msgid "Package not found when loading packages."
msgstr ""

#: ../../language/error_codes/E4048.md:1
msgid "E4048"
msgstr ""

#: ../../language/error_codes/E4048.md:3
msgid "The package file is in wrong format."
msgstr ""

#: ../../language/error_codes/E4049.md:1
msgid "E4049"
msgstr ""

#: ../../language/error_codes/E4049.md:3
msgid "Magic number mismatch for the package file."
msgstr ""

#: ../../language/error_codes/E4050.md:1
msgid "E4050"
msgstr ""

#: ../../language/error_codes/E4050.md:3
msgid "Definition cycle detected in dependencies."
msgstr ""

#: ../../language/error_codes/E4050.md:5
msgid ""
"The toplevel definitions in a MoonBit package are mutually recursive. "
"This means that the definitions can refer to each other in any order. "
"However, no cycles are allowed in the dependencies between the toplevel "
"variable definitions."
msgstr ""

#: ../../language/error_codes/E4050.md:11
msgid ""
"pub let a : Int = f() // Error: Definition cycle detected : a -> f -> a\n"
"\n"
"fn f() -> Int { // Error: Definition cycle detected : a -> f -> a\n"
"  a\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4050.md:21
msgid ""
"The fix to this error varies depending on the logic of the program. One "
"possible fix is to make the variable definition to use `Ref[_?]`, and "
"initialize the variable later in `init` block of the program."
msgstr ""

#: ../../language/error_codes/E4050.md:25
msgid ""
"pub let a : Ref[Int?] = Ref::new(None)\n"
"\n"
"fn init {\n"
"  a.val = Some(f())\n"
"}\n"
"\n"
"fn f() -> Int {\n"
"  a.val.unwrap()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4051.md:1
msgid "E4051"
msgstr ""

#: ../../language/error_codes/E4051.md:3
msgid "The identifier is declared twice."
msgstr ""

#: ../../language/error_codes/E4051.md:5
msgid ""
"Mutually recursive definitions in MoonBit shall not have the same "
"identifier. This include:"
msgstr ""

#: ../../language/error_codes/E4051.md:8
msgid ""
"All toplevel definitions, including variables, functions, types, traits, "
"etc."
msgstr ""

#: ../../language/error_codes/E4051.md:9
msgid "Locally named functions. (Reported as [E4006](E4006))"
msgstr ""

#: ../../language/error_codes/E4051.md:10
#, fuzzy
msgid "Local types."
msgstr "本地类型"

#: ../../language/error_codes/E4051.md:12
msgid ""
"Note, locally defined variables are not mutually recursive, so they can "
"have the same identifier, and the later definition shadows the previous "
"one."
msgstr ""

#: ../../language/error_codes/E4051.md:17
#, fuzzy
msgid "Toplevel variable definition:"
msgstr "顶层变量绑定"

#: ../../language/error_codes/E4051.md:19
msgid ""
"pub let a = 0\n"
"pub let a = 1 // Error: The toplevel identifier a is declared twice: it "
"was previously defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4051.md:24
#, fuzzy
msgid "Toplevel function definition:"
msgstr "函数定义"

#: ../../language/error_codes/E4051.md:26
msgid ""
"pub fn f() -> Unit {}\n"
"pub fn f() -> Unit {} // Error: The toplevel identifier f is declared "
"twice: it was previously defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4051.md:31
#, fuzzy
msgid "Toplevel type definition:"
msgstr "类型定义"

#: ../../language/error_codes/E4051.md:33
msgid ""
"pub enum A {}\n"
"pub struct A {} // Error: The type A is declared twice: it was previously"
" defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4051.md:38
#, fuzzy
msgid "Local type definition:"
msgstr "类型定义"

#: ../../language/error_codes/E4051.md:40
msgid ""
"pub fn g() -> Unit {\n"
"  struct A {}\n"
"  struct A {} // Error: The local type A is declared twice: it was "
"previously defined at ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4051.md:49
msgid "Rename the identifier to a different name."
msgstr ""

#: ../../language/error_codes/E4051.md:51
msgid ""
"pub let a = 0\n"
"pub let b = 1\n"
msgstr ""

#: ../../language/error_codes/E4051.md:56
msgid ""
"If you want to shadow the previous definition, you can use a block and "
"put the definition in the block."
msgstr ""

#: ../../language/error_codes/E4051.md:59
msgid ""
"pub let a = {\n"
"  let a = 0\n"
"  1\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4052.md:1
msgid "E4052"
msgstr ""

#: ../../language/error_codes/E4052.md:3
msgid "The type/trait name duplicates with a previously defined identifier."
msgstr ""

#: ../../language/error_codes/E4052.md:5
msgid "This can happen when you define a type and a trait with the same name."
msgstr ""

#: ../../language/error_codes/E4052.md:9
msgid ""
"pub type A\n"
"pub trait A {} // Error: The trait A duplicates with type A previously "
"defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4052.md:16
msgid "Rename either the type or the trait to a different name."
msgstr ""

#: ../../language/error_codes/E4052.md:18
msgid ""
"pub type A\n"
"pub trait B {}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:1
msgid "E4053"
msgstr ""

#: ../../language/error_codes/E4053.md:3
msgid "Invalid type for \"self\": must be a type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:5
msgid ""
"This error happens when you want to define a method for implement a trait"
" for a type that is not a type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:8
msgid "Types that **are** type constructors:"
msgstr ""

#: ../../language/error_codes/E4053.md:10
msgid "Tuple: `(Int, Bool)`"
msgstr ""

#: ../../language/error_codes/E4053.md:11
msgid ""
"`enum`s, `struct`s, `trait`s, new types (`type`), and error types "
"(`type!`)."
msgstr ""

#: ../../language/error_codes/E4053.md:13
msgid "Types that **are not** type constructors:"
msgstr ""

#: ../../language/error_codes/E4053.md:15
msgid "Function: `(Int) -> Bool`"
msgstr ""

#: ../../language/error_codes/E4053.md:16
msgid "Type parameter: `T` in `fn f[T](x : T) -> T`"
msgstr ""

#: ../../language/error_codes/E4053.md:20
msgid "Defining a method for a type that is not type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:22
msgid ""
"fn f[T](self : T) -> Int { // Error: Invalid type for \"self\": must be a"
" type constructor.\n"
"  ignore(self)\n"
"  0\n"
"}\n"
"\n"
"fn g(self : (Int) -> Unit) -> Unit { // Error: Invalid type for \"self\":"
" must be a type constructor.\n"
"  self(0)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:33
msgid "Implementing a method for a type that is not a type constructor."
msgstr ""

#: ../../language/error_codes/E4053.md:35
msgid ""
"pub trait A {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"// Without constraints\n"
"impl[X] A for X with f(self : X) -> Int { // Error: Invalid type for "
"\"self\": must be a type constructor.\n"
"  ignore(self)\n"
"  0\n"
"}\n"
"\n"
"// With constraints\n"
"impl[X: Default] A for X with f(self : X) -> Int { // Error: Invalid type"
" for \"self\": must be a type constructor.\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:55
msgid ""
"When you want to define a method for a type that is not a type "
"constructor, you may use new type to wrap the type."
msgstr ""

#: ../../language/error_codes/E4053.md:58
msgid ""
"pub(all) type Wrap[T] T\n"
"\n"
"fn f[T](self : Wrap[T]) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
"\n"
"fn g(self : Wrap[(Int) -> Unit]) -> Unit {\n"
"  (self._)(0)\n"
"}\n"
"\n"
"impl[X] A for Wrap[X] with f(self : Wrap[X]) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:76
msgid ""
"However, this means you may have to wrap the value with `Wrap` every time"
" you want to call the method."
msgstr ""

#: ../../language/error_codes/E4053.md:79
msgid ""
"If you find yourself implementing a trait for a type parameter, you may "
"also want to consider using default implementation for the trait."
msgstr ""

#: ../../language/error_codes/E4053.md:82
msgid ""
"impl A with f(self : Self) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4053.md:89
msgid ""
"If you want to provide the implementation for types with specific "
"constraints, you can add these constraints to the trait definition."
msgstr ""

#: ../../language/error_codes/E4053.md:92
msgid ""
"trait A: Default {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"impl A with f(self : Self) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4054.md:1
msgid "E4054"
msgstr ""

#: ../../language/error_codes/E4054.md:3
msgid ""
"Cannot determine self type of extension method. [Self] does not occur in "
"the signature of the method"
msgstr ""

#: ../../language/error_codes/E4055.md:1
msgid "E4055"
msgstr ""

#: ../../language/error_codes/E4055.md:3
msgid "Field is already declared."
msgstr ""

#: ../../language/error_codes/E4055.md:7
msgid ""
"struct A {\n"
"  a : Int\n"
"  a : Double\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4055.md:16
msgid "Rename the field to a different name."
msgstr ""

#: ../../language/error_codes/E4055.md:18
msgid ""
"struct A {\n"
"  a : Int\n"
"  b : Double\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4056.md:1
msgid "E4056"
msgstr ""

#: ../../language/error_codes/E4056.md:3
msgid "Method has already been defined."
msgstr ""

#: ../../language/error_codes/E4056.md:7
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
"\n"
"fn Point::to_string(self : Point) -> String {\n"
"  \"(\" + self.x.to_string() + \",\" + self.y.to_string() + \")\"\n"
"}\n"
"\n"
"fn Point::to_string(self : Point) -> String {\n"
"  \"<\" + self.x.to_string() + \",\" + self.y.to_string() + \">\"\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4056.md:24
msgid "Remove the duplicate method and keep only one method:"
msgstr ""

#: ../../language/error_codes/E4056.md:26
msgid ""
"struct Point {\n"
"  x: Int\n"
"  y: Int\n"
"}\n"
"\n"
"fn Point::to_string(self : Point) -> String {\n"
"  \"(\" + self.x.to_string() + \",\" + self.y.to_string() + \")\"\n"
"}\n"
"\n"
"// Remove the second Point::to_string method\n"
msgstr ""

#: ../../language/error_codes/E4057.md:1
msgid "E4057"
msgstr ""

#: ../../language/error_codes/E4057.md:3
msgid "The constructor is duplicate."
msgstr ""

#: ../../language/error_codes/E4057.md:7
msgid ""
"enum E {\n"
"  A\n"
"  A(Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4057.md:16
msgid "Rename the constructor to a different name."
msgstr ""

#: ../../language/error_codes/E4057.md:18
msgid ""
"enum E {\n"
"  A\n"
"  B(Int)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:1
msgid "E4059"
msgstr ""

#: ../../language/error_codes/E4059.md:3
msgid "Cannot define method for foreign type."
msgstr ""

#: ../../language/error_codes/E4059.md:5
msgid ""
"Foreign types are types that is not defined in the current package. "
"MoonBit only allows defining methods or implementing traits for types "
"that are defined in the current package."
msgstr ""

#: ../../language/error_codes/E4059.md:11
msgid "In package `a`:"
msgstr ""

#: ../../language/error_codes/E4059.md:13
msgid "pub type A Int\n"
msgstr ""

#: ../../language/error_codes/E4059.md:17
msgid "In package `b`:"
msgstr ""

#: ../../language/error_codes/E4059.md:19
msgid ""
"fn f(self : @a.A) -> Int { // Error: Cannot define method f for foreign "
"type @a.A\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:25
msgid ""
"Defining methods for builtin types, or types in standard library, is "
"another frequent case of this error:"
msgstr ""

#: ../../language/error_codes/E4059.md:28
msgid ""
"fn f(self : Int) -> Int { // Error: Cannot define method f for foreign "
"type Int\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:36
msgid "You can either move the type definition to the current package:"
msgstr ""

#: ../../language/error_codes/E4059.md:38
msgid ""
"pub type A Int\n"
"\n"
"fn f(self : A) -> Int {\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4059.md:46
msgid "Or use new type to wrap the foreign type:"
msgstr ""

#: ../../language/error_codes/E4059.md:48
msgid ""
"pub type WrapA @a.A\n"
"\n"
"fn f(self : WrapA) -> Int {\n"
"  ignore(self._) // Use `._` to access the wrapped value if @a.A is "
"public\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4060.md:1
msgid "E4060"
msgstr ""

#: ../../language/error_codes/E4060.md:3
msgid "Method type mismatch."
msgstr ""

#: ../../language/error_codes/E4060.md:5
msgid ""
"We require the type of implementation to have the exactly the same type "
"as the one defined in the trait. Notably, the following types are **not**"
" considered the same."
msgstr ""

#: ../../language/error_codes/E4060.md:9
msgid ""
"Labelled arguments with different order: `(a~ : Int, b~ : Int) -> Unit` "
"and `(b~ : Int, a~ : Int) -> Unit`."
msgstr ""

#: ../../language/error_codes/E4060.md:11
msgid "Optional arguments: `(a : Int, b? : Int) -> Unit` and `(a : Int) -> Unit`."
msgstr ""

#: ../../language/error_codes/E4060.md:15
msgid ""
"trait A {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"type T Int\n"
"\n"
"impl A for T with f(self : T) -> Int {\n"
"  //              ^\n"
"  // Error: Method f of trait A is expected to have type (T) -> Int,\n"
"  //        it cannot be implemented with type (T) -> Unit\n"
"  ignore(self)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4060.md:32
msgid "Make sure the method type matches the trait method type."
msgstr ""

#: ../../language/error_codes/E4060.md:34
msgid ""
"impl A for T with f(self : T) -> Int {\n"
"  ignore(self)\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:1
msgid "E4061"
msgstr ""

#: ../../language/error_codes/E4061.md:3
msgid "Cannot define method of foreign trait for foreign type."
msgstr ""

#: ../../language/error_codes/E4061.md:5
msgid ""
"Foreign here means that the type or trait is not defined in the current "
"package. MoonBit follows the orphan rule, which means that you can only:"
msgstr ""

#: ../../language/error_codes/E4061.md
#, fuzzy
msgid "Traits"
msgstr "使用特征"

#: ../../language/error_codes/E4061.md
#, fuzzy
msgid "Types"
msgstr "类型"

#: ../../language/error_codes/E4061.md
msgid "Allowed?"
msgstr ""

#: ../../language/error_codes/E4061.md
msgid "Native"
msgstr ""

#: ../../language/error_codes/E4061.md
#, fuzzy
msgid "Yes"
msgstr "字节"

#: ../../language/error_codes/E4061.md
msgid "Foreign"
msgstr ""

#: ../../language/error_codes/E4061.md
msgid "No"
msgstr ""

#: ../../language/error_codes/E4061.md:15
msgid ""
"See the [Access control of methods and trait "
"implementations](../packages.md#access-control-of-methods-and-trait-"
"implementations) section of the MoonBit documentation for more "
"information."
msgstr ""

#: ../../language/error_codes/E4061.md:20
msgid ""
"Suppose you have type `A` and trait `B` defined in package `a` in module "
"`username/hello`:"
msgstr ""

#: ../../language/error_codes/E4061.md:23
#: ../../language/error_codes/E4073.md:16
#: ../../language/error_codes/E4074.md:29
msgid "`a/a.mbt`:"
msgstr ""

#: ../../language/error_codes/E4061.md:25
msgid ""
"pub(all) type A Int\n"
"pub(open) trait B {\n"
"  to_int(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:32
msgid "`a/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4061.md:38
msgid "Now, if you want to implement trait `@a.B` for type `@a.A`:"
msgstr ""

#: ../../language/error_codes/E4061.md:40
#: ../../language/error_codes/E4073.md:28
#: ../../language/error_codes/E4074.md:37
msgid "`b/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4061.md:42
#: ../../language/error_codes/E4073.md:30
#: ../../language/error_codes/E4074.md:39
msgid ""
"{\n"
"  \"import\": [\n"
"    \"username/hello/a\"\n"
"  ]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:50
#: ../../language/error_codes/E4061.md:68
#: ../../language/error_codes/E4073.md:38
#: ../../language/error_codes/E4073.md:55
#: ../../language/error_codes/E4074.md:47
msgid "`b/b.mbt`:"
msgstr ""

#: ../../language/error_codes/E4061.md:52
msgid ""
"impl @a.B for @a.A with to_int(self : @a.A) -> Int {\n"
"  //                    ^~~~~~\n"
"  // Error: Cannot define method to_int of foreign trait @a.B for foreign"
" type @a.A\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4061.md:60
msgid "MoonBit will report an error."
msgstr ""

#: ../../language/error_codes/E4061.md:64
msgid ""
"You can move either the trait or type into the current package where the "
"implementation is in. If that is not possible, you can create a new type "
"over the foreign type and implement the trait for the new type:"
msgstr ""

#: ../../language/error_codes/E4061.md:70
msgid ""
"type WrapA @a.A\n"
"\n"
"impl @a.B for WrapA with to_int(self : WrapA) -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:1
msgid "E4062"
msgstr ""

#: ../../language/error_codes/E4062.md:3
msgid ""
"This `impl` shadows method previously defined. This will result in "
"different implementations for trait inside and outside current package."
msgstr ""

#: ../../language/error_codes/E4062.md:6
msgid ""
"In MoonBit, you can implicitly implement a trait for a type by defining "
"all the methods in that trait. For example, if you have trait like this:"
msgstr ""

#: ../../language/error_codes/E4062.md:9
msgid ""
"trait Coordinated { // use pub(open) when you want to implement it "
"outside current package.\n"
"  x(Self) -> Int\n"
"  y(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:16
msgid "Then, for a type `Point`, you can implement the trait like this:"
msgstr ""

#: ../../language/error_codes/E4062.md:18
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"}\n"
"\n"
"fn x(self : Point) -> Int {\n"
"  self.x\n"
"}\n"
"\n"
"fn y(self : Point) -> Int {\n"
"  self.y\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:33
msgid ""
"However, as you can implement a trait for a type explicitly with `impl`, "
"this may leads to inconsistent behavior when these two implementation "
"have different visibility."
msgstr ""

#: ../../language/error_codes/E4062.md:39
#, fuzzy
msgid "For example, in package `a`:"
msgstr "例如，对于一个枚举"

#: ../../language/error_codes/E4062.md:41
msgid ""
"pub(open) trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"pub type A Int\n"
"\n"
"pub fn A::f(self : A) -> Int {\n"
"  println(\"A::f\")\n"
"  self._\n"
"}\n"
"\n"
"impl T for A with f(self : A) -> Int {\n"
"  //              ^\n"
"  // Error: This `impl` shadows method f of A previously defined at ...\n"
"  //        This will result in different implementations for T inside "
"and outside current package.\n"
"  println(\"impl T for A with f\")\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:62
msgid ""
"If these code were able to pass compilation, then for the function "
"defined in another package:"
msgstr ""

#: ../../language/error_codes/E4062.md:65
msgid ""
"fn probe[T : @a.T](t : T) -> Unit {\n"
"  ignore(t.f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:71
msgid ""
"The output will be `A::f`. However, if the `probe` function is defined in"
" the package `a`:"
msgstr ""

#: ../../language/error_codes/E4062.md:73
msgid ""
"fn probe[T : T](t : T) -> Unit {\n"
"  ignore(t.f())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4062.md:79
msgid "The output will be `impl T for A with f`."
msgstr ""

#: ../../language/error_codes/E4062.md:83
msgid ""
"To fix this error, you need to make sure both the implicitly (`A::f`) and"
" explicitly implementation (`impl`) of the trait have the same "
"visibility."
msgstr ""

#: ../../language/error_codes/E4062.md:86
msgid ""
"// ...\n"
"pub impl T for A with f(self : A) -> Int {\n"
"  println(\"impl T for A with f\")\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4063.md:1
msgid "E4063"
msgstr ""

#: ../../language/error_codes/E4063.md:3
msgid "Type does not implement trait, although an `impl` is defined."
msgstr ""

#: ../../language/error_codes/E4063.md:5
msgid "This error can be further divided into 5 cases:"
msgstr ""

#: ../../language/error_codes/E4063.md:7 ../../language/error_codes/E4063.md:15
#, fuzzy
msgid "Method is missing"
msgstr "方法系统"

#: ../../language/error_codes/E4063.md:8
#, fuzzy
msgid "Implementation is private"
msgstr "实现细节"

#: ../../language/error_codes/E4063.md:9
msgid "Method type mismatch"
msgstr ""

#: ../../language/error_codes/E4063.md:10
msgid "Constraints are not satisfied"
msgstr ""

#: ../../language/error_codes/E4063.md:11
msgid "Method contains unresolved type parameters"
msgstr ""

#: ../../language/error_codes/E4063.md:17
msgid ""
"trait Number {\n"
"  to_int(Self) -> Int\n"
"  to_float(Self) -> Float\n"
"}\n"
"\n"
"type A Int\n"
"\n"
"impl Number for A with to_int(self : A) -> Int {\n"
"//^~~~~~~~~~~~~~~\n"
"// Error: Type A does not implement trait Number, although an `impl` is "
"defined.\n"
"// hint:\n"
"//   method to_float is missing.\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4063.md:36
msgid ""
"Modify the code according to the hint provided along with the error "
"message. For the example above, you can add the missing method `to_float`"
" to type `A`."
msgstr ""

#: ../../language/error_codes/E4063.md:39
msgid ""
"impl Number for A with to_float(self : A) -> Float {\n"
"  self._.to_float()\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4065.md:1
msgid "E4065"
msgstr ""

#: ../../language/error_codes/E4065.md:3
msgid "Overloaded operator should accept the correct number of arguments."
msgstr ""

#: ../../language/error_codes/E4065.md:5
msgid ""
"You can refer to the [Operator Overloading](../methods.md#operator-"
"overloading) section for a list of operators that can be overloaded, and "
"here is a list of number of arguments that each operator should accept:"
msgstr ""

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "Operator"
msgstr "管道运算符"

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "Method Name"
msgstr "方法名称"

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "Number of Arguments"
msgstr "自动填充参数"

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`+`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_add`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "2"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`-`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_sub`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`*`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_mul`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`/`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_div`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`%`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_mod`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "`==`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_equal`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`<<`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_shl`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`>>`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_shr`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`-` (unary)"
msgstr "`-`（一元）"

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_neg`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "1"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "`_[_]`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_get`"
msgstr ""

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "`_[_] = _`"
msgstr "`_[_] = _`（设置项）"

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_set`"
msgstr ""

#: ../../language/error_codes/E4065.md
msgid "3"
msgstr ""

#: ../../language/error_codes/E4065.md
#, fuzzy
msgid "`_[_:_]`"
msgstr "`_[_:_]`（视图）"

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`op_as_view`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`&`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`land`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`|`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`lor`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`^`"
msgstr ""

#: ../../language/error_codes/E4065.md ../../language/methods.md:90
msgid "`lxor`"
msgstr ""

#: ../../language/error_codes/E4065.md:29
msgid ""
"type A Int\n"
"\n"
"fn A::op_add(self : A, other : A, opt? : A) -> A {\n"
"  //  ^~~~~~\n"
"  // Error: overloaded operator \"op_add\" should accept 2 arguments, but"
" it accepts 3 arguments\n"
"  let opt = match opt {\n"
"    None => 0\n"
"    Some(opt) => opt._\n"
"  }\n"
"  return self._ + other._ + opt\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4065.md:45
msgid ""
"Modify the method to match the expected number of arguments of the "
"operator."
msgstr ""

#: ../../language/error_codes/E4065.md:47
#: ../../language/error_codes/E4066.md:24
msgid ""
"fn A::op_add(self : A, other : A) -> A {\n"
"  self._ + other._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4066.md:1
msgid "E4066"
msgstr ""

#: ../../language/error_codes/E4066.md:3
msgid "Overloaded operator has inconsistent parameter type."
msgstr ""

#: ../../language/error_codes/E4066.md:5
msgid ""
"You can refer to the [Operator Overloading](../methods.md#operator-"
"overloading) section for a list of operators that can be overloaded, and "
"respectively their expected signature."
msgstr ""

#: ../../language/error_codes/E4066.md:11
msgid ""
"type A Int\n"
"fn A::op_add(self : A, other : Int) -> A {\n"
"  return self._ + other\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4066.md:20
msgid ""
"Modify the method to match the expected parameter type of the operator. "
"If you use the name for overloaded operators by accident, you can rename "
"the method to a different name."
msgstr ""

#: ../../language/error_codes/E4067.md:1
msgid "E4067"
msgstr ""

#: ../../language/error_codes/E4067.md:3
msgid "Missing main function in the main package."
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4067.md:5
msgid ""
"In MoonBit, packages are divided into two types: main packages and non-"
"main packages. Non-main packages are often used as libraries to provide "
"functionality to other packages. Main packages, on the other hand, are "
"the entry points of the program. Therefore, main package should contains "
"a `main` function serving as the entry point of the program."
msgstr ""

#: ../../language/error_codes/E4067.md:13
#: ../../language/error_codes/E4068.md:13
msgid "Suppose in package `main`:"
msgstr ""

#: ../../language/error_codes/E4067.md:17
#, fuzzy
msgid ""
"{ // Error: Missing main function in the main package.\n"
"  \"is-main\": true\n"
"}\n"
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4067.md:25
msgid ""
"type A Int\n"
"\n"
"pub fn A::to_int(self : A) -> Int {\n"
"  self._\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4067.md:35
#, fuzzy
msgid "You can add a `main` function to the main package:"
msgstr "main 包中缺少 `main` 函数"

#: ../../language/error_codes/E4067.md:39
msgid ""
"// ...\n"
"fn main {\n"
"  let a : A = 42\n"
"  println(a.to_int())\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4067.md:47
msgid ""
"Alternatively, you can set the package to be a non-main package by "
"setting `\"is-main\"` to `false` in the package configuration file."
msgstr ""

#: ../../language/error_codes/E4067.md:52
msgid ""
"{\n"
"  \"is-main\": false\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4068.md:1
msgid "E4068"
msgstr ""

#: ../../language/error_codes/E4068.md:3
msgid "Main function is already defined."
msgstr ""

#: ../../language/error_codes/E4068.md:5
msgid ""
"In MoonBit, a `main` package contains a single `main` function that "
"serves as the entry point of the program. Therefore, you cannot define "
"more than one `main` function in the main package. If you want to have "
"multiple programs to be built as separate binaries, you can use multiple "
"`main` packages within the same module."
msgstr ""

#: ../../language/error_codes/E4068.md:25
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"}\n"
"\n"
"fn main { // Error: Main function is already defined at ...\n"
"  println(\"Hello, World! Again!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4068.md:37
msgid "You can either remove the extra `main` function:"
msgstr ""

#: ../../language/error_codes/E4068.md:39
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"}\n"
"// Remove the extra main function\n"
"//- fn main {\n"
"//-   println(\"Hello, World! Again!\")\n"
"//- }\n"
msgstr ""

#: ../../language/error_codes/E4068.md:49
msgid ""
"Or you can move the extra `main` function to a different package, say "
"`main2`:"
msgstr ""

#: ../../language/error_codes/E4068.md:51
msgid "`main2/moon.pkg.json`:"
msgstr ""

#: ../../language/error_codes/E4068.md:59
msgid "`main2/main.mbt`:"
msgstr ""

#: ../../language/error_codes/E4068.md:61
msgid ""
"fn main {\n"
"  println(\"Hello, World! Again!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4068.md:67
msgid "while keeping the `main/main.mbt` contains only one main function:"
msgstr ""

#: ../../language/error_codes/E4068.md:69
msgid ""
"fn main {\n"
"  println(\"Hello, World!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4069.md:1
msgid "E4069"
msgstr ""

#: ../../language/error_codes/E4069.md:3
msgid "Unexpected main function in the non-main package."
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4069.md:5
msgid ""
"In MoonBit, packages are divided into two types: main packages and non-"
"main packages. Non-main packages are often used as libraries to provide "
"functionality to other packages. Main packages, on the other hand, are "
"the entry points of the program. Therefore, non-main packages should not "
"contain a `main` function."
msgstr ""

#: ../../language/error_codes/E4069.md:10
msgid ""
"Sometimes, people use the main function for testing. In such cases, we "
"recommend using the `test` block to write tests, instead of using the "
"`main` function. See the [test](../introduction.md#test) section of the "
"MoonBit documentation for more information."
msgstr ""

#: ../../language/error_codes/E4069.md:17
msgid "Suppose in package `lib`:"
msgstr ""

#: ../../language/error_codes/E4069.md:21
msgid "{} // \"is-main\" is by default false\n"
msgstr ""

#: ../../language/error_codes/E4069.md:25
msgid "`lib/lib.mbt`:"
msgstr ""

#: ../../language/error_codes/E4069.md:27
#, fuzzy
msgid ""
"fn main { // Error: Unexpected main function in the non-main package.\n"
"  println(\"Hello, world!\")\n"
"}\n"
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4069.md:35
#, fuzzy
msgid "You can remove the `main` function from the non-main package:"
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4069.md:37
msgid ""
"// Remove the main function\n"
"//- fn main {\n"
"//-   println(\"Hello, world!\")\n"
"//- }\n"
msgstr ""

#: ../../language/error_codes/E4069.md:44
msgid ""
"Alternatively, you can set the package to be a main package by setting "
"`\"is-main\"` to `true` in the package configuration file."
msgstr ""

#: ../../language/error_codes/E4069.md:55
msgid "You can also move the `main` function to a different package, say `main`:"
msgstr ""

#: ../../language/error_codes/E4070.md:1
msgid "E4070"
msgstr ""

#: ../../language/error_codes/E4070.md:3
msgid "Unknown intrinsic. This intrinsic is not known to the MoonBit compiler."
msgstr ""

#: ../../language/error_codes/E4070.md:5 ../../language/error_codes/E4071.md:6
msgid ""
"Note all intrinsic is not intended for external use and is subject to "
"change without notice, and we highly recommend **against** using them."
msgstr ""

#: ../../language/error_codes/E4070.md:10
msgid ""
"pub fn my_abort(message : String) -> Unit = \"%abort\"\n"
"// Error: Unknown intrinsic: %abort\n"
"\n"
"fn main {\n"
"  my_abort(\"Abort!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4070.md:21
#, fuzzy
msgid ""
"You may probably want to use the `abort` function from the "
"`moonbitlang/core`:"
msgstr "非 main 包中出现 `main` 函数。"

#: ../../language/error_codes/E4070.md:23
msgid ""
"fn main {\n"
"  abort(\"Abort!\")\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4070.md:29
msgid ""
"If you really need to use the intrinsic, you can check the source code of"
" `moonbitlang/core` for further usage of the corresponding intrinsic."
msgstr ""

#: ../../language/error_codes/E4071.md:1
msgid "E4071"
msgstr ""

#: ../../language/error_codes/E4071.md:3
msgid ""
"Multiple intrinsic is not supported. You have defined a function to use "
"multiple intrinsics."
msgstr ""

#: ../../language/error_codes/E4071.md:11
#, python-format
msgid ""
"type MyArray[T] Array[T]\n"
"\n"
"/// @intrinsic %array.get\n"
"/// @intrinsic %fixedarray.get\n"
"fn MyArray::get[T](self : MyArray[T], index : Int) -> T { // Error: "
"Multiple intrinsic is not unsupported.\n"
"  return self._[index]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4071.md:23
msgid "Remove the extra intrinsic and use only one intrinsic:"
msgstr ""

#: ../../language/error_codes/E4071.md:25
msgid ""
"/// @intrinsic %array.get\n"
"fn MyArray::get[T](self : MyArray[T], index : Int) -> T {\n"
"  return self._[index]\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4071.md:32
msgid ""
"Avoid directly using intrinsics as much as possible, as we may change or "
"remove them in the future. If you really need to use the intrinsic, you "
"can check the source code of `moonbitlang/core` for further usage of the "
"corresponding intrinsic."
msgstr ""

#: ../../language/error_codes/E4072.md:1
msgid "E4072"
msgstr ""

#: ../../language/error_codes/E4072.md:3
msgid "Method of trait already has a default implementation."
msgstr ""

#: ../../language/error_codes/E4072.md:7
msgid ""
"trait T {\n"
"  to_int(Self) -> Int\n"
"}\n"
"\n"
"type A Int\n"
"\n"
"impl T with to_int(self : Self) -> Int {\n"
"  0\n"
"}\n"
"\n"
"impl T with to_int(self : Self) -> Int { // Error: Method to_int of trait"
" T already has a default implementation at\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4072.md:25
#, fuzzy
msgid "Remove the duplicated default implementation of the trait."
msgstr "不能为外来特征定义默认实现。"

#: ../../language/error_codes/E4072.md:27
msgid ""
"impl T with to_int(self : Self) -> Int {\n"
"  0\n"
"}\n"
"\n"
"// Remove this implementation\n"
"// impl T with to_int(self : Self) -> Int {\n"
"//   0\n"
"// }\n"
msgstr ""

#: ../../language/error_codes/E4073.md:1
msgid "E4073"
msgstr ""

#: ../../language/error_codes/E4073.md:3
msgid "Cannot provide default implementation for foreign trait."
msgstr "不能为外来特征定义默认实现。"

#: ../../language/error_codes/E4073.md:5
msgid ""
"This is a corollary of the [orphan rules of traits and types in "
"MoonBit](../packages.md#access-control-of-methods-and-trait-"
"implementations). Default implementation can be seen as implementing the "
"trait for all possible types, which include foreign and native types. "
"Therefore, it is only possible for default implementation to be defined "
"in the package of the trait, otherwise it would violate the orphan rules."
msgstr ""

#: ../../language/error_codes/E4073.md:14
msgid ""
"Suppose you have a trait `T` defined in package `a` in module "
"`username/hello`:"
msgstr ""

#: ../../language/error_codes/E4073.md:18
msgid ""
"// We need the trait to be pub(open) so that it can be implemented from "
"outside.\n"
"pub(open) trait T {\n"
"  f(Self) -> Int\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4073.md:25
msgid ""
"And when you want to define a default implementation for the trait in "
"another package, say `b`:"
msgstr ""

#: ../../language/error_codes/E4073.md:40
msgid ""
"impl @a.T with f(self : Self) -> Int {\n"
"  //           ^\n"
"  // Error: Cannot provide default implementation for foreign trait @a.T\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4073.md:51
msgid ""
"To fix this error, you can move the definition of the trait and the "
"default implementation of this trait into the same package. Say you can "
"move the trait definition into package `b`:"
msgstr ""

#: ../../language/error_codes/E4073.md:57
msgid ""
"pub(open) trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"impl T with f(self : Self) -> Int {\n"
"  ignore(self)\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4074.md:1
msgid "E4074"
msgstr ""

#: ../../language/error_codes/E4074.md:3
msgid "This error code is shared by the following two error messages:"
msgstr ""

#: ../../language/error_codes/E4074.md:5
msgid "Cannot infer the type of variable, please add more type annotation."
msgstr ""

#: ../../language/error_codes/E4074.md:6
msgid "Public definition a must be annotated with its type."
msgstr ""

#: ../../language/error_codes/E4074.md:8
msgid ""
"When defining a toplevel variable using `let`, MoonBit will try to infer "
"its type when the value is literal:"
msgstr ""

#: ../../language/error_codes/E4074.md:11
msgid ""
"pub let forty_two = 42\n"
"pub let float = 1.0\n"
"pub let string = \"Hello, world!\"\n"
"pub let array = [1, 2, 3]\n"
msgstr ""

#: ../../language/error_codes/E4074.md:20
msgid ""
"For \"Cannot infer the type of variable a, please add more type "
"annotation\":"
msgstr ""

#: ../../language/error_codes/E4074.md:22
msgid ""
"let a = 1 + 1 // Error: Cannot infer the type of variable a, please add "
"more type annotation.\n"
msgstr ""

#: ../../language/error_codes/E4074.md:26
msgid ""
"The other error message is more subtle. Say if you have module "
"`username/hello` and package `a`:"
msgstr ""

#: ../../language/error_codes/E4074.md:31
msgid "pub let value = 1.0\n"
msgstr ""

#: ../../language/error_codes/E4074.md:35
#, fuzzy
msgid "And package `b`:"
msgstr "例如，对于一个枚举"

#: ../../language/error_codes/E4074.md:49
msgid ""
"pub let value = @a.value // Error: Public definition a must be annotated "
"with its type.\n"
msgstr ""

#: ../../language/error_codes/E4074.md:55
msgid ""
"These two error can be fixed by explicitly annotating the type of the "
"variable:"
msgstr ""

#: ../../language/error_codes/E4074.md:57
msgid "let a : Int = 1 + 1\n"
msgstr ""

#: ../../language/error_codes/E4074.md:61
msgid "pub let value : Double = @a.value\n"
msgstr ""

#: ../../language/error_codes/E4075.md:1
msgid "E4075"
msgstr ""

#: ../../language/error_codes/E4075.md:3
msgid "Missing type annotation for the parameter."
msgstr ""

#: ../../language/error_codes/E4075.md:5
#, fuzzy
msgid "MoonBit requires all toplevel function to have full type annotation."
msgstr "只有顶层函数可以有带标签的参数。"

#: ../../language/error_codes/E4075.md:9
msgid ""
"fn f(param) -> Unit { // Error: Missing type annotation for the parameter"
" param.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4075.md:16
msgid "Add type annotation for the parameter:"
msgstr ""

#: ../../language/error_codes/E4075.md:18
msgid ""
"fn f(param: Int) -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4075.md:23
msgid "Or if the parameter should be generic:"
msgstr ""

#: ../../language/error_codes/E4075.md:25
msgid ""
"fn f[T](param: T) -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4076.md:1
msgid "E4076"
msgstr ""

#: ../../language/error_codes/E4076.md:3
msgid "Missing type annotation for the return value."
msgstr ""

#: ../../language/error_codes/E4076.md:5
msgid ""
"MoonBit requires all toplevel function to have full type annotation. It "
"is a common mistake for people to forget to include the return type of a "
"function, especially when the function returns `Unit`."
msgstr ""

#: ../../language/error_codes/E4076.md:11
msgid ""
"fn f() { // Error: Missing type annotation for the return value.\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4076.md:18
msgid "Add the return type of the function:"
msgstr ""

#: ../../language/error_codes/E4076.md:20
msgid ""
"fn f() -> Unit {\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4077.md:1
msgid "E4077"
msgstr ""

#: ../../language/error_codes/E4077.md:3
msgid "Don't know how to derive trait for type."
msgstr ""

#: ../../language/error_codes/E4077.md:5
msgid ""
"MoonBit allows you to derive implementation of some pre-defined traits "
"for your types. It means that you cannot have MoonBit automatically "
"derive a trait that you defined yourself."
msgstr ""

#: ../../language/error_codes/E4077.md:11
msgid ""
"trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"type A Int derive(T) // Error: Don't know how to derive trait T for type "
"A\n"
msgstr ""

#: ../../language/error_codes/E4077.md:21
#: ../../language/error_codes/E4078.md:17
msgid "You can implement the trait manually:"
msgstr ""

#: ../../language/error_codes/E4077.md:23
msgid ""
"trait T {\n"
"  f(Self) -> Int\n"
"}\n"
"\n"
"// Remove derive(T)\n"
"type A Int\n"
"\n"
"impl T for A with f(self : A) -> Int {\n"
"  0\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4078.md:1
msgid "E4078"
msgstr ""

#: ../../language/error_codes/E4078.md:3
msgid "Cannot derive trait for type."
msgstr ""

#: ../../language/error_codes/E4078.md:5
msgid ""
"MoonBit allows you to derive implementation of some traits for your "
"types. However, not all types can be automatically derived. For example, "
"you cannot derive a trait for an abstract type."
msgstr ""

#: ../../language/error_codes/E4078.md:11
msgid ""
"type T derive(Hash) // Error: Cannot derive trait Hash for type T: target"
" type is abstract\n"
msgstr ""

#: ../../language/error_codes/E4078.md:19
msgid ""
"type T\n"
"\n"
"impl Hash for T with hash_combine(self : T, hasher: Hasher) {\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/error_codes/E4079.md:1
msgid "E4079"
msgstr ""

#: ../../language/error_codes/E4079.md:3
msgid "Cannot derive trait: method is already defined."
msgstr ""

#: ../../language/error_codes/E4079.md:5
msgid ""
"This error occurs when you try to derive a trait for a type that already "
"has a implementation for the trait."
msgstr ""

#: ../../language/error_codes/E4079.md:10
msgid ""
"impl Show for A with output(self : A, logger : &Logger) -> Unit {\n"
"  logger.write_object(self._)\n"
"}\n"
"\n"
"type A Int derive(Hash, Show) // Error: Cannot derive trait Show for A: "
"method output is already defined at ...\n"
msgstr ""

#: ../../language/error_codes/E4079.md:20
msgid ""
"You can pick either the manual implementation or the derived "
"implementation for the type by removing the other one."
msgstr ""

#: ../../language/error_codes/E4079.md:23
msgid "To use the derived implementation:"
msgstr ""

#: ../../language/error_codes/E4079.md:25
msgid ""
"// Remove the manual implementation\n"
"// impl Show for A with output(self : A, logger : &Logger) -> Unit {\n"
"//   logger.write_object(self._)\n"
"// }\n"
"\n"
"type A Int derive(Hash, Show)\n"
msgstr ""

#: ../../language/error_codes/E4079.md:34
msgid "Or to use the manual implementation:"
msgstr ""

#: ../../language/error_codes/E4079.md:36
msgid ""
"impl Show for A with output(self : A, logger : &Logger) -> Unit {\n"
"  logger.write_object(self._)\n"
"}\n"
"\n"
"type A Int derive(Hash)\n"
msgstr ""

#: ../../language/error_codes/E4080.md:1
msgid "E4080"
msgstr ""

#: ../../language/error_codes/E4080.md:3
msgid "Arity mismatch: incorrect number of arguments provided."
msgstr ""

#: ../../language/error_codes/E4081.md:1
msgid "E4081"
msgstr ""

#: ../../language/error_codes/E4081.md:3
msgid "The identifier is bound more than once in the same pattern."
msgstr ""

#: ../../language/error_codes/E4082.md:1
msgid "E4082"
msgstr ""

#: ../../language/error_codes/E4082.md:3
msgid "Variable is not bound in all patterns."
msgstr ""

#: ../../language/error_codes/E4083.md:1
msgid "E4083"
msgstr ""

#: ../../language/error_codes/E4083.md:3
msgid "The type does not implement `op_as_view` method."
msgstr ""

#: ../../language/error_codes/E4084.md:1
msgid "E4084"
msgstr ""

#: ../../language/error_codes/E4084.md:3
msgid "The label is supplied twice."
msgstr ""

#: ../../language/error_codes/E4085.md:1
msgid "E4085"
msgstr ""

#: ../../language/error_codes/E4085.md:3
msgid "This has no parameter with the given label."
msgstr "给定标签没有参数。"

#: ../../language/error_codes/E4086.md:1
msgid "E4086"
msgstr ""

#: ../../language/error_codes/E4086.md:3
msgid "The labels are required by this function, but not supplied."
msgstr ""

#: ../../language/error_codes/E4087.md:1
msgid "E4087"
msgstr ""

#: ../../language/error_codes/E4087.md:3
msgid "The variable is not mutable."
msgstr ""

#: ../../language/error_codes/E4088.md:1
msgid "E4088"
msgstr ""

#: ../../language/error_codes/E4088.md:3
msgid "The record field is immutable."
msgstr ""

#: ../../language/error_codes/E4089.md:1
msgid "E4089"
msgstr ""

#: ../../language/error_codes/E4089.md:3
msgid "Tuple has no field with the given index."
msgstr ""

#: ../../language/error_codes/E4090.md:1
msgid "E4090"
msgstr ""

#: ../../language/error_codes/E4090.md:3
msgid "Tuples are not mutable."
msgstr ""

#: ../../language/error_codes/E4091.md:1
msgid "E4091"
msgstr ""

#: ../../language/error_codes/E4091.md:3
msgid "The type has no field with the given name."
msgstr ""

#: ../../language/error_codes/E4092.md:1
msgid "E4092"
msgstr ""

#: ../../language/error_codes/E4092.md:3
msgid "Missing annotation for this empty record."
msgstr ""

#: ../../language/error_codes/E4093.md:1
msgid "E4093"
msgstr ""

#: ../../language/error_codes/E4093.md:3
msgid "The type is not a record type."
msgstr ""

#: ../../language/error_codes/E4094.md:1
msgid "E4094"
msgstr ""

#: ../../language/error_codes/E4094.md:3
msgid "Cannot modify a read-only field."
msgstr ""

#: ../../language/error_codes/E4095.md:1
msgid "E4095"
msgstr ""

#: ../../language/error_codes/E4095.md:3
msgid "Integer literal is out of range."
msgstr ""

#: ../../language/error_codes/E4100.md:1
msgid "E4100"
msgstr ""

#: ../../language/error_codes/E4100.md:3
msgid "The type is not a trait."
msgstr ""

#: ../../language/error_codes/E4101.md:1
msgid "E4101"
msgstr ""

#: ../../language/error_codes/E4101.md:3
msgid "Unsupported expression after the pipe operator."
msgstr ""

#: ../../language/error_codes/E4102.md:1
msgid "E4102"
msgstr ""

#: ../../language/error_codes/E4102.md:3
msgid "Outside of a loop."
msgstr ""

#: ../../language/error_codes/E4103.md:1
msgid "E4103"
msgstr ""

#: ../../language/error_codes/E4103.md:3
msgid "This loop has incorrect number of patterns supplied."
msgstr ""

#: ../../language/error_codes/E4104.md:1
msgid "E4104"
msgstr ""

#: ../../language/error_codes/E4104.md:3
msgid ""
"Current loop expects different number of arguments than supplied with "
"`continue`."
msgstr ""

#: ../../language/error_codes/E4105.md:1
msgid "E4105"
msgstr ""

#: ../../language/error_codes/E4105.md:3
msgid "Current loop has result type mismatch with `break` argument."
msgstr ""

#: ../../language/error_codes/E4106.md:1
msgid "E4106"
msgstr ""

#: ../../language/error_codes/E4106.md:3
msgid ""
"Unknown binder in the for-loop steps. Binders in the steps must be "
"declared in the initialization block of the for-loop."
msgstr ""

#: ../../language/error_codes/E4107.md:1
msgid "E4107"
msgstr ""

#: ../../language/error_codes/E4107.md:3
msgid "Name is declared multiple times in this for-loop."
msgstr ""

#: ../../language/error_codes/E4108.md:1
msgid "E4108"
msgstr ""

#: ../../language/error_codes/E4108.md:3
msgid "The loop is expected to yield a value, please add an `else` branch."
msgstr ""

#: ../../language/error_codes/E4109.md:1
msgid "E4109"
msgstr ""

#: ../../language/error_codes/E4109.md:3
msgid "Return must be inside a function."
msgstr ""

#: ../../language/error_codes/E4110.md:1
msgid "E4110"
msgstr ""

#: ../../language/error_codes/E4110.md:3
msgid ""
"The loop is not expected to yield a value, please remove the argument of "
"the `break` or add an `else` branch."
msgstr ""

#: ../../language/error_codes/E4111.md:1
msgid "E4111"
msgstr ""

#: ../../language/error_codes/E4111.md:3
msgid "The usage of break statement is invalid."
msgstr ""

#: ../../language/error_codes/E4112.md:1
msgid "E4112"
msgstr ""

#: ../../language/error_codes/E4112.md:3
msgid "The usage of continue statement is invalid."
msgstr ""

#: ../../language/error_codes/E4113.md:1
msgid "E4113"
msgstr ""

#: ../../language/error_codes/E4113.md:3
msgid "Constructor has no field with the given name."
msgstr ""

#: ../../language/error_codes/E4114.md:1
msgid "E4114"
msgstr ""

#: ../../language/error_codes/E4114.md:3
msgid "Only toplevel functions can have labelled arguments."
msgstr "只有顶层函数可以有带标签的参数。"

#: ../../language/error_codes/E4115.md:1
msgid "E4115"
msgstr ""

#: ../../language/error_codes/E4115.md:3
msgid "Cannot auto-fill parameter of this type."
msgstr ""

#: ../../language/error_codes/E4116.md:1
msgid "E4116"
msgstr ""

#: ../../language/error_codes/E4116.md:3
msgid "Found hole _."
msgstr ""

#: ../../language/error_codes/E4117.md:1
msgid "E4117"
msgstr ""

#: ../../language/error_codes/E4117.md:3
msgid "Function with labelled arguments can only be applied directly."
msgstr ""

#: ../../language/error_codes/E4118.md:1
msgid "E4118"
msgstr ""

#: ../../language/error_codes/E4118.md:3
msgid "Cannot match type with map pattern."
msgstr ""

#: ../../language/error_codes/E4119.md:1
msgid "E4119"
msgstr ""

#: ../../language/error_codes/E4119.md:3
msgid ""
"This function is not a toplevel function, so it cannot have labelled "
"arguments."
msgstr "这个函数不是顶层函数，因此不能有带标签的参数。"

#: ../../language/error_codes/E4120.md:1
msgid "E4120"
msgstr ""

#: ../../language/error_codes/E4120.md:3
msgid ""
"The application might raise errors, but it's not handled. Try adding an "
"infix operator `!` or `?` to the application."
msgstr ""

#: ../../language/error_codes/E4121.md:1
msgid "E4121"
msgstr ""

#: ../../language/error_codes/E4121.md:3
msgid "The attribute cannot be used on this application."
msgstr ""

#: ../../language/error_codes/E4122.md:1
msgid "E4122"
msgstr ""

#: ../../language/error_codes/E4122.md:3
msgid ""
"Invalid raise operation. Can only be used inside a function with error "
"types in its signature."
msgstr ""

#: ../../language/error_codes/E4124.md:1
msgid "E4124"
msgstr ""

#: ../../language/error_codes/E4124.md:3
msgid "The constructor is ambiguous: it may come from multiple types."
msgstr ""

#: ../../language/error_codes/E4125.md:1
msgid "E4125"
msgstr ""

#: ../../language/error_codes/E4125.md:3
msgid "`?` operator cannot be used with `..`."
msgstr ""

#: ../../language/error_codes/E4127.md:1
msgid "E4127"
msgstr ""

#: ../../language/error_codes/E4127.md:3
msgid "Type is not an error type."
msgstr "类型不是错误类型。"

#: ../../language/error_codes/E4128.md:1
msgid "E4128"
msgstr ""

#: ../../language/error_codes/E4128.md:3
msgid "Target of type alias must not be a type parameter."
msgstr ""

#: ../../language/error_codes/E4129.md:1
msgid "E4129"
msgstr ""

#: ../../language/error_codes/E4129.md:3
msgid "Found cycle in type alias."
msgstr ""

#: ../../language/error_codes/E4130.md:1
msgid "E4130"
msgstr ""

#: ../../language/error_codes/E4130.md:3
msgid "`derive` is not allowed for type alias."
msgstr ""

#: ../../language/error_codes/E4131.md:1
msgid "E4131"
msgstr ""

#: ../../language/error_codes/E4131.md:3
msgid "The type alias is a function type, not a type constructor."
msgstr ""

#: ../../language/error_codes/E4132.md:1
msgid "E4132"
msgstr ""

#: ../../language/error_codes/E4132.md:3
msgid "Invalid test parameter. Only one parameter with type `@test.T` is allowed."
msgstr ""

#: ../../language/error_codes/E4133.md:1
msgid "E4133"
msgstr ""

#: ../../language/error_codes/E4133.md:3
msgid "This `for .. in` loop has incorrect number of loop variables."
msgstr ""

#: ../../language/error_codes/E4134.md:1
msgid "E4134"
msgstr ""

#: ../../language/error_codes/E4134.md:3
msgid ""
"The return type of this anonymous function is expected to include an "
"error type. Please add the error type to the return type annotation or "
"use `fn!` instead."
msgstr ""

#: ../../language/error_codes/E4135.md:1
msgid "E4135"
msgstr ""

#: ../../language/error_codes/E4135.md:3
msgid "Inconsistent `impl` of trait: implementations have different constraints."
msgstr ""

#: ../../language/error_codes/E4136.md:1
msgid "E4136"
msgstr ""

#: ../../language/error_codes/E4136.md:3
msgid "This expression has type that is not a newtype."
msgstr ""

#: ../../language/error_codes/E4137.md:1
msgid "E4137"
msgstr ""

#: ../../language/error_codes/E4137.md:3
msgid "Range operators are currently only supported in `for .. in` loops."
msgstr ""

#: ../../language/error_codes/E4138.md:1
msgid "E4138"
msgstr ""

#: ../../language/error_codes/E4138.md:3
msgid ""
"Range operators only support builtin integer types, they cannot be used "
"on this type."
msgstr ""

#: ../../language/error_codes/E4139.md:1
msgid "E4139"
msgstr ""

#: ../../language/error_codes/E4139.md:3
msgid ""
"This expression has type that cannot be implicitly ignored. Use "
"`ignore(...)` or `let _ = ...` to explicitly ignore it."
msgstr ""

#: ../../language/error_codes/E4140.md:1
msgid "E4140"
msgstr ""

#: ../../language/error_codes/E4140.md:3
msgid "Invalid C function name in extern \"C\" declaration."
msgstr ""

#: ../../language/error_codes/E4141.md:1
msgid "E4141"
msgstr ""

#: ../../language/error_codes/E4141.md:3
msgid ""
"This form of application is invalid for this argument, because it is not "
"declared with the correct label."
msgstr ""

#: ../../language/error_codes/E4142.md:1
msgid "E4142"
msgstr ""

#: ../../language/error_codes/E4142.md:3
msgid "This 'const' declaration is not constant."
msgstr ""

#: ../../language/error_codes/E4143.md:1
msgid "E4143"
msgstr ""

#: ../../language/error_codes/E4143.md:3
msgid "Not a valid constant type, only immutable primitive types are allowed."
msgstr ""

#: ../../language/error_codes/E4144.md:1
msgid "E4144"
msgstr ""

#: ../../language/error_codes/E4144.md:3
msgid "This is a constant, not a constructor, it cannot be applied to arguments."
msgstr ""

#: ../../language/error_codes/E4145.md:1
msgid "E4145"
msgstr ""

#: ../../language/error_codes/E4145.md:3
msgid "Cannot implement trait because it is sealed."
msgstr ""

#: ../../language/error_codes/E4146.md:1
msgid "E4146"
msgstr ""

#: ../../language/error_codes/E4146.md:3
msgid "Type is not supported by range pattern."
msgstr ""

#: ../../language/error_codes/E4147.md:1
msgid "E4147"
msgstr ""

#: ../../language/error_codes/E4147.md:3
msgid "Range pattern bounds must satisfy the ordering constraint."
msgstr ""

#: ../../language/error_codes/E4148.md:1
msgid "E4148"
msgstr ""

#: ../../language/error_codes/E4148.md:3
msgid "The label is undeclared."
msgstr ""

#: ../../language/error_codes/E4149.md:1
msgid "E4149"
msgstr ""

#: ../../language/error_codes/E4149.md:3
msgid "Cannot call async function in this context."
msgstr ""

#: ../../language/error_codes/E4150.md:1
msgid "E4150"
msgstr ""

#: ../../language/error_codes/E4150.md:3
msgid "Async function call attribute mismatch."
msgstr ""

#: ../../language/error_codes/index.md:1
msgid "Error Codes Index"
msgstr "错误代码索引"

#: ../../language/error_codes/index.md:4
msgid "The error codes index is currently WIP."
msgstr "该错误代码索引目前正在编写中"

#: ../../language/error_codes/index.md:6
msgid ""
"Many of the entries contains only verify brief description of the error "
"code. You are more than welcomed to expand any of the entries by "
"submitting a PR to [moonbitlang/moonbit-"
"docs](https://github.com/moonbitlang/moonbit-docs)."
msgstr ""
"许多错误条目只有非常简单的描述。我们非常欢迎您通过向 [moonbitlang/moonbit-"
"docs](https://github.com/moonbitlang/moonbit-docs) 提交 Pull Request "
"的方式来扩充条目内容。"

#: ../../language/error_codes/index.md:11
msgid "This page lists all error codes produced by the MoonBit compiler."
msgstr "此页面列出了所有 MoonBit 编译器会报告的错误"

#: ../../language/ffi-and-wasm-host.md:1
msgid "Foreign Function Interface(FFI)"
msgstr "外部函数接口(FFI)"

#: ../../language/ffi-and-wasm-host.md:3
msgid ""
"What we've introduced is about describing pure computation. In reality, "
"you'll need to interact with the real world. However, the \"world\" is "
"different for each backend (C, JS, Wasm, WasmGC) and is sometimes based "
"on runtime ([Wasmtime](https://wasmtime.dev/), Deno, Browser, etc.)."
msgstr "我们已经介绍的是纯粹的计算。在现实中，需要与真实世界互动。然而，对于每个后端（C、JS、Wasm、WasmGC），“世界”是不同的，并且基于运行时（[Wasmtime](https://wasmtime.dev/)、Deno、浏览器等）。"

#: ../../language/ffi-and-wasm-host.md:7
msgid ""
"You can use foreign function in MoonBit through FFI to interact with the "
"hosting runtime when embedded inside the browser or command line "
"applications through [Wasmtime](https://wasmtime.dev/) or similar "
"projects."
msgstr ""
"当嵌入到浏览器，或通过 [Wasmtime](https://wasmtime.dev/) "
"嵌入到命令行应用程序中时，可以通过外部函数接口(FFI)在 MoonBit 中使用外部函数与宿主运行时进行交互。"

#: ../../language/ffi-and-wasm-host.md:9
msgid "Init function"
msgstr "`init` 函数"

#: ../../language/ffi-and-wasm-host.md:11
msgid ""
"For WebAssembly backend, it is compiled as [start "
"function](https://webassembly.github.io/spec/core/syntax/modules.html"
"#start-function), meaning that it will be executed **before** the "
"instance is available, and the FFIs that relies on the instance's "
"exportations can not be used at this stage; for JavaScript backend, it "
"means that it will be executed during the importation stage."
msgstr ""
"对于 WebAssembly 后端，它被编译为 [start "
"函数](https://webassembly.github.io/spec/core/syntax/modules.html#start-"
"function)，这意味着它将在实例可用之前执行，并且依赖于实例的导出的外部函数接口(FFI)在这个阶段不能使用；对于 JavaScript "
"后端，这意味着它将在导入阶段执行。"

#: ../../language/ffi-and-wasm-host.md:14
msgid "Declare Foreign Reference"
msgstr "声明外部引用"

#: ../../language/ffi-and-wasm-host.md:16
msgid "You can declare a foreign reference type like this:"
msgstr "您可以像这样声明一个外部引用类型："

#: ../../language/ffi-and-wasm-host.md:18
msgid "type Canvas_ctx\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:22
msgid ""
"This will be a type that represents a reference to a foreign object, a "
"`CanvasRenderingContext2D` object held by the hosting JavaScript runtime "
"in this example."
msgstr ""
"这将是一个表示对外部对象的引用的类型，在这个例子中，它是由宿主 JavaScript 运行时持有的 "
"`CanvasRenderingContext2D` 对象。"

#: ../../language/ffi-and-wasm-host.md:24
msgid "Declare Foreign Function"
msgstr "声明外部函数"

#: ../../language/ffi-and-wasm-host.md:26
msgid ""
"You can either import a function with module name and function name or "
"writing an inline function."
msgstr "您可以通过模块名和函数名导入一个函数，也可以编写一个内联函数。"

#: ../../language/ffi-and-wasm-host.md:28
msgid "Import function"
msgstr "导入函数"

#: ../../language/ffi-and-wasm-host.md:30
msgid "You can declare a foreign function like this:"
msgstr "您可以像这样声明一个外部函数："

#: ../../language/ffi-and-wasm-host.md:32
msgid "fn cos(d : Double) -> Double = \"Math\" \"cos\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:36
msgid ""
"It's similar to a normal function definition except that the function "
"body is replaced with two strings."
msgstr "它与普通函数定义类似，只是函数体被替换为两个字符串。"

#: ../../language/ffi-and-wasm-host.md:38
msgid ""
"For Wasm(GC) backend, these two strings are used to identify the specific"
" function from a Wasm import object, the first string is the module name,"
" and the second string is the function name."
msgstr "对于 Wasm(GC) 后端，这两个字符串用于从 Wasm 导入对象中识别特定函数，第一个字符串是模块名，第二个字符串是函数名。"

#: ../../language/ffi-and-wasm-host.md:40
msgid ""
"For JS backend, these two strings are used to call a static function in "
"the global namespace. The example above becomes similar to `const cos = "
"(d) => Math.cos(d)`."
msgstr "对于 JS 后端，这两个字符串用于调用全局命名空间中的静态函数。上面的例子类似于 `const cos = (d) => Math.cos(d)`。"

#: ../../language/ffi-and-wasm-host.md:42
msgid "Inline function"
msgstr "内联函数"

#: ../../language/ffi-and-wasm-host.md:44
msgid ""
"You can also declare inline functions where the function body is replaced"
" with one string."
msgstr "您还可以声明内联函数，其中函数体被替换为一个字符串。"

#: ../../language/ffi-and-wasm-host.md:46
msgid ""
"For Wasm(GC) backend, you may declare it as a Wasm function without name "
"(which will be generated afterwards):"
msgstr "对于 Wasm(GC) 后端，您可以将其声明为一个没有名称的 Wasm 函数（稍后将生成名称）："

#: ../../language/ffi-and-wasm-host.md:48
msgid ""
"extern \"wasm\" fn abs(d : Double) -> Double =\n"
"  #|(func (param f64) (result f64))\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:53
msgid "and for JS backend, you may declare it as a lambda expression:"
msgstr "对于 JS 后端，您可以将其声明为一个 lambda 表达式："

#: ../../language/ffi-and-wasm-host.md:55
msgid ""
"extern \"js\" fn abs(d : Double) -> Double =\n"
"  #|(d) => Math.abs(d)\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:60
msgid "After declaration, you can use foreign functions like regular functions."
msgstr "声明后，您可以像普通函数一样使用外部函数。"

#: ../../language/ffi-and-wasm-host.md:62
msgid ""
"For multi-backend project, you may implement backend specific code in the"
" files that ends with `.wasm.mbt` `.wasm-gc.mbt` and `.js.mbt`. Check out"
" [link options](</toolchain/moon/package.md#link-options>) for details."
msgstr ""
"对于多后端项目，您可以在以 `.wasm.mbt` `.wasm-gc.mbt` 和 `.js.mbt` "
"结尾的文件中实现特定于后端的代码。有关详细信息，请查看[链接选项](</toolchain/moon/package.md#link-"
"options>)。"

#: ../../language/ffi-and-wasm-host.md:64
msgid ""
"You may also declare a foreign function that will be invoked upon a "
"foreign object by using the foreign reference type like this:"
msgstr "您还可以声明一个外部函数，该函数将通过使用外部引用类型在外部对象上调用，如下所示："

#: ../../language/ffi-and-wasm-host.md:66
msgid "fn begin_path(self: Canvas_ctx) = \"canvas\" \"begin_path\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:70
msgid ""
"and apply it to a previously owned reference normally such as "
"`context.begin_path()`."
msgstr "然后将其应用于以前拥有的引用，例如 `context.begin_path()`。"

#: ../../language/ffi-and-wasm-host.md:72
msgid "Export functions"
msgstr "导出函数"

#: ../../language/ffi-and-wasm-host.md:74
msgid ""
"Functions that are not methods nor polymorphic functions can be exported "
"if they are public and if the link configuration appears in the "
"`moon.pkg.json` of the package:"
msgstr "如果函数既不是方法也不是多态函数，则可以导出它们，前提是它们是公共的，并且链接配置出现在包的 `moon.pkg.json` 中："

#: ../../language/ffi-and-wasm-host.md:76
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ]\n"
"    },\n"
"    \"js\": {\n"
"      \"exports\": [ \"add\", \"fib:test\" ],\n"
"      \"format\": \"esm\"\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:93
msgid ""
"Each backend has a separate definition. For JS backend, a `format` option"
" is used to specify whether the generated JavaScript file should be "
"released as an ES Module (`esm`), a CommonJS module (`cjs`), or an "
"immediately invoked function expression (`iife`)."
msgstr ""
"每个后端都有单独的定义。对于 JS 后端，`format` 选项用于指定生成的 JavaScript 文件是作为 ES 模块 "
"(`esm`)、CommonJS 模块 (`cjs`) 还是立即调用的函数表达式 (`iife`) 发布。"

#: ../../language/ffi-and-wasm-host.md:95
msgid ""
"The example above will export function `add` and `fib`, and the function "
"`fib` will be exported with the name of `test`."
msgstr "上面的例子将导出函数 `add` 和 `fib`，函数 `fib` 将以 `test` 的名称导出。"

#: ../../language/ffi-and-wasm-host.md:97
msgid "Use compiled Wasm"
msgstr "使用编译后的 Wasm"

#: ../../language/ffi-and-wasm-host.md:99
msgid ""
"To use the compiled Wasm, you need to initialize the Wasm module with the"
" host functions so as to meet the needs of the foreign functions, and "
"then use the exported functions provided by the Wasm module."
msgstr "要使用编译后的 Wasm，您需要使用宿主函数初始化 Wasm 模块，以满足外部函数的需求，然后使用 Wasm 模块提供的导出函数。"

#: ../../language/ffi-and-wasm-host.md:101
msgid "Provide host functions"
msgstr "提供宿主函数"

#: ../../language/ffi-and-wasm-host.md:103
msgid ""
"To use the compiled Wasm, you must provide **All** declared foreign "
"functions in Wasm import object."
msgstr "要使用编译后的 Wasm，您必须在 Wasm 导入对象中提供**所有**声明的外部函数。"

#: ../../language/ffi-and-wasm-host.md:105
msgid "For example, to use wasm compiled from above code snippet in JavaScript:"
msgstr "例如，在 JavaScript 中使用上面代码片段编译的 wasm："

#: ../../language/ffi-and-wasm-host.md:107
msgid ""
"WebAssembly.instantiateStreaming(fetch(\"xxx.wasm\"), {\n"
"  Math: {\n"
"    cos: (d) => Math.cos(d),\n"
"  },\n"
"});\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:115
msgid ""
"Check out the documentation such as [MDN](https://developer.mozilla.org"
"/en-US/docs/WebAssembly) or the manual of runtime that you're using to "
"embed the Wasm."
msgstr ""
"查看文档，例如 [MDN](https://developer.mozilla.org/en-US/docs/WebAssembly) "
"或您用于嵌入 Wasm 的运行时的手册。"

#: ../../language/ffi-and-wasm-host.md:118
msgid ""
"In order to passing closure to host, we need to add `make_closure` into "
"`moonbit:ffi`. e.g. "
"[onclick](https://html.spec.whatwg.org/multipage/webappapis.html#handler-"
"onclick)"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:121
msgid ""
"type MouseEvent \n"
"type Window \n"
"fn onclick(self : Window, e : (MouseEvent) -> Unit) = \"Window\" "
"\"onclick\"\n"
"pub fn print_hello(self : Window) -> Unit {\n"
"  self.onclick(fn (_){ println(\"hello\")})\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:130
msgid ""
"let importObject = { \n"
"  Window : {\n"
"    onclick : (w : Window, f : (e : MouseEvent) => void ) => w.onclick = "
"f \n"
"  },\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"  \"moonbit:ffi\": {\n"
"    make_closure: (funcref, closure) => funcref.bind(null, closure)\n"
"  } \n"
"}\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    obj.instance.exports[\"print_hello\"](window);\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:149
msgid "Example: Smiling face"
msgstr "示例：笑脸"

#: ../../language/ffi-and-wasm-host.md:151
msgid ""
"Let's walk through a full example to draw a smiling face using Canvas API"
" in MoonBit. Suppose you created a new project with `moon new draw`"
msgstr ""
"让我们通过一个完整的示例来使用 Canvas API 在 MoonBit 中绘制一个笑脸。假设您使用 `moon new draw` "
"创建了一个新项目"

#: ../../language/ffi-and-wasm-host.md:153
msgid ""
"// We first declare a type representing the context of canvas\n"
"type Canvas_ctx\n"
"\n"
"// We then declare the foreign function interfaces\n"
"fn begin_path(self : Canvas_ctx) = \"canvas\" \"beginPath\"\n"
"fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : "
"Double,\n"
"    end_angle : Double, counterclockwise : Bool) = \"canvas\" \"arc\"\n"
"fn move_to(self : Canvas_ctx, x : Int, y : Int) = \"canvas\" \"moveTo\"\n"
"fn stroke(self : Canvas_ctx) = \"canvas\" \"stroke\"\n"
"\n"
"fn get_pi() -> Double = \"math\" \"PI\"\n"
"let pi : Double = get_pi()\n"
"\n"
"// We then apply these functions to define the drawing function upon the "
"context\n"
"pub fn draw(self : Canvas_ctx) -> Unit {\n"
"  self.begin_path()\n"
"  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle\n"
"  self.move_to(110, 75)\n"
"  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)\n"
"  self.move_to(65, 65)\n"
"  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye\n"
"  self.move_to(95, 65)\n"
"  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye\n"
"  self.stroke()\n"
"}\n"
"\n"
"// We also demonstrate the `println` functionality here\n"
"pub fn display_pi() -> Unit {\n"
"  println(\"PI: \\{pi}\")\n"
"}\n"
msgstr ""
"// 首先声明一个表示 canvas 上下文的类型\n"
"type Canvas_ctx\n"

#: ../../language/ffi-and-wasm-host.md:186
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:199
msgid ""
"Build the project using `moon build`. We recommend using Wasm with GC "
"integration whenever possible (which is the default). If the environment "
"does not support the GC feature, use the `--target wasm` option instead."
msgstr ""
"使用 `moon build` 构建项目。我们建议尽可能使用 Wasm GC（这是默认值）。如果环境不支持 GC 特性，请改用 `--target"
" wasm` 选项。"

#: ../../language/ffi-and-wasm-host.md:201
msgid "We now can use it from JavaScript."
msgstr "现在我们可以从 JavaScript 中使用它。"

#: ../../language/ffi-and-wasm-host.md:203
msgid ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // import object for defining the FFI\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // Pass the JS object as parameter to draw the smiling face\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // Display the value of PI\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"
msgstr ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // 用于定义 FFI 的导入对象\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // 将 JS 对象作为参数传递以绘制笑脸\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // 显示 PI 的值\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"

#: ../../language/ffi-and-wasm-host.md:230
msgid ""
"For import object, we need to provide all the FFI used in the previously "
"defined program: the canvas rendering API, the math API and finally, an "
"API for printing to the console used by the `println` or `print` "
"function."
msgstr ""
"对于导入对象，我们需要提供先前定义的程序中使用的所有 FFI：canvas 渲染 API、math API 和最后，用于 `println` 或 "
"`print` 函数的打印到控制台的 API。"

#: ../../language/ffi-and-wasm-host.md:232
msgid ""
"As of the canvas rendering API and the math API, we can use the following"
" code to convert the methods of objects into function calls that accept "
"the object as the first parameter, and convert the constant properties of"
" objects into functions that returns the value:"
msgstr ""
"至于 canvas 渲染 API 和 math "
"API，我们可以使用以下代码将对象的方法转换为接受对象作为第一个参数的函数调用，并将对象的常量属性转换为返回值的函数："

#: ../../language/ffi-and-wasm-host.md:234
msgid ""
"function prototype_to_ffi(prototype) {\n"
"  return Object.fromEntries(\n"
"    Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"      .filter(([_key, value]) => value.value)\n"
"      .map(([key, value]) => {\n"
"        if (typeof value.value == 'function')\n"
"          return [key, Function.prototype.call.bind(value.value)]\n"
"        // TODO: it is also possible to convert properties into getters "
"and setters\n"
"        else\n"
"          return [key, () => value.value]\n"
"      })\n"
"  );\n"
"}\n"
"\n"
"const importObject = {\n"
"  canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"  math: prototype_to_ffi(Math),\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:256
msgid ""
"As of the printing service, we can provide the following closure so that "
"it buffers the bytes of string until it needs to be logged to the "
"console:"
msgstr "至于打印服务，我们可以提供以下闭包，以便它缓冲字符串的字节，直到需要将其记录到控制台："

#: ../../language/ffi-and-wasm-host.md:258
msgid ""
"const [log, flush] = (() => {\n"
"  var buffer = [];\n"
"  function flush() {\n"
"    if (buffer.length > 0) {\n"
"      console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"      buffer = [];\n"
"    }\n"
"  }\n"
"  function log(ch) {\n"
"    if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"    else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"    else { buffer.push(ch); }\n"
"  }\n"
"  return [log, flush]\n"
"})();\n"
"\n"
"const importObject = {\n"
"  // ...\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"}\n"
"\n"
"// ...\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    // ...\n"
"    flush()\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:291
msgid "Now, we put them together, so this is our final complete `index.html`:"
msgstr "现在，我们将它们放在一起，这是我们最终的完整 `index.html`："

#: ../../language/ffi-and-wasm-host.md:293
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"\n"
"<head></head>\n"
"\n"
"<body>\n"
"  <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  <script>\n"
"    function prototype_to_ffi(prototype) {\n"
"      return Object.fromEntries(\n"
"        Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"          .filter(([_key, value]) => value.value)\n"
"          .map(([key, value]) => {\n"
"            if (typeof value.value == 'function')\n"
"              return [key, Function.prototype.call.bind(value.value)]\n"
"            else\n"
"              return [key, () => value.value]\n"
"          })\n"
"      );\n"
"    }\n"
"\n"
"    const [log, flush] = (() => {\n"
"      var buffer = [];\n"
"      function flush() {\n"
"        if (buffer.length > 0) {\n"
"          console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"          buffer = [];\n"
"        }\n"
"      }\n"
"      function log(ch) {\n"
"        if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"        else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"        else { buffer.push(ch); }\n"
"      }\n"
"      return [log, flush]\n"
"    })();\n"
"\n"
"\n"
"\n"
"    const importObject = {\n"
"      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"      math: prototype_to_ffi(Math),\n"
"      spectest: {\n"
"        print_char: log\n"
"      },\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"          flush()\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</body>\n"
"\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:358
msgid ""
"Make sure that `draw.wasm` and `index.html` are in the same folder, then "
"start a http server at this folder. For example, using Python:"
msgstr "确保 `draw.wasm` 和 `index.html` 在同一个文件夹中，然后在此文件夹中启动一个 http 服务器。例如，使用 Python："

#: ../../language/ffi-and-wasm-host.md:360
msgid "python3 -m http.server 8080\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:364
msgid ""
"Goto [http://localhost:8080](http://localhost:8080) in your browser, "
"there should be a smile face on the screen and an output on the console:"
msgstr ""
"在浏览器中转到 "
"[http://localhost:8080](http://localhost:8080)，屏幕上应该有一个笑脸，控制台上应该有一个输出："

#: ../../language/ffi-and-wasm-host.md:366
msgid ""
"![A smile face webpage with browser devtools "
"open](../imgs/smile_face_with_log.png)"
msgstr "![带有笑脸的浏览器开发工具的网页](../imgs/smile_face_with_log.png)"

#: ../../language/ffi-and-wasm-host.md:366
msgid "A smile face webpage with browser devtools open"
msgstr "带有笑脸的浏览器开发工具的网页"

#: ../../language/fundamentals.md:1
msgid "Fundamentals"
msgstr "基础"

#: ../../language/fundamentals.md:3
msgid "Built-in Data Structures"
msgstr "内置数据结构"

#: ../../language/fundamentals.md:5
msgid "Boolean"
msgstr "布尔值"

#: ../../language/fundamentals.md:7
msgid ""
"MoonBit has a built-in boolean type, which has two values: `true` and "
"`false`. The boolean type is used in conditional expressions and control "
"structures."
msgstr "MoonBit 有一个内置的布尔类型，它有两个值：`true` 和 `false`。布尔类型用于条件表达式和控制结构。"

#: ../../language/fundamentals.md:9
msgid ""
"let a = true\n"
"let b = false\n"
"let c = a && b\n"
"let d = a || b\n"
"let e = not(a)\n"
msgstr ""

#: ../../language/fundamentals.md:16
msgid "Number"
msgstr "数字"

#: ../../language/fundamentals.md:18
msgid "MoonBit have integer type and floating point type:"
msgstr "MoonBit 有整数类型和浮点类型："

#: ../../language/fundamentals.md:9
msgid "type"
msgstr "类型"

#: ../../language/fundamentals.md:9 ../../language/fundamentals.md:117
msgid "description"
msgstr "描述"

#: ../../language/fundamentals.md:9
msgid "example"
msgstr "示例"

#: ../../language/fundamentals.md:9
msgid "`Int16`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "16-bit signed integer"
msgstr "16 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`(42 : Int16)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit signed integer"
msgstr "32 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`42`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Int64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit signed integer"
msgstr "64 位有符号整数"

#: ../../language/fundamentals.md:9
msgid "`1000L`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt16`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "16-bit unsigned integer"
msgstr "16 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`(14 : UInt16)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit unsigned integer"
msgstr "32 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14U`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`UInt64`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit unsigned integer"
msgstr "64 位无符号整数"

#: ../../language/fundamentals.md:9
msgid "`14UL`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Double`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "64-bit floating point, defined by IEEE754"
msgstr "64 位浮点数，由 IEEE754 定义"

#: ../../language/fundamentals.md:9
msgid "`3.14`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`Float`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "32-bit floating point"
msgstr "32 位浮点数"

#: ../../language/fundamentals.md:9
msgid "`(3.14 : Float)`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "`BigInt`"
msgstr ""

#: ../../language/fundamentals.md:9
msgid "represents numeric values larger than other types"
msgstr "表示比其他类型更大的数值"

#: ../../language/fundamentals.md:9
msgid "`10000000000000000000000N`"
msgstr ""

#: ../../language/fundamentals.md:32
msgid ""
"MoonBit also supports numeric literals, including decimal, binary, octal,"
" and hexadecimal numbers."
msgstr "MoonBit 还支持数字字面量，包括十进制、二进制、八进制和十六进制数字。"

#: ../../language/fundamentals.md:34
msgid ""
"To improve readability, you may place underscores in the middle of "
"numeric literals such as `1_000_000`. Note that underscores can be placed"
" anywhere within a number, not just every three digits."
msgstr "为了提高可读性，您可以在数字字面量中间放置下划线，例如 `1_000_000`。请注意，下划线可以放在数字中的任何位置，而不仅仅是每三位数字。"

#: ../../language/fundamentals.md:36
msgid "Decimal numbers can have underscore between the numbers."
msgstr "十进制数之间可以有下划线。"

#: ../../language/fundamentals.md:38
msgid ""
"By default, an int literal is signed 32-bit number. For unsigned numbers,"
" a postfix `U` is needed; for 64-bit numbers, a postfix `L` is needed."
msgstr "默认情况下，整数字面量是有符号的 32 位数字。对于无符号数字，需要后缀 `U`；对于 64 位数字，需要后缀 `L`。"

#: ../../language/fundamentals.md:40
msgid ""
"let a = 1234\n"
"let b : Int = 1_000_000 + a\n"
"let unsigned_num       : UInt   = 4_294_967_295U\n"
"let large_num          : Int64  = 9_223_372_036_854_775_807L\n"
"let unsigned_large_num : UInt64 = 18_446_744_073_709_551_615UL\n"
msgstr ""

#: ../../language/fundamentals.md:47
msgid ""
"A binary number has a leading zero followed by a letter \"B\", i.e. "
"`0b`/`0B`. Note that the digits after `0b`/`0B` must be `0` or `1`."
msgstr "二进制数有一个前导零，后跟字母 \"B\"，即 `0b`/`0B`。请注意，`0b`/`0B` 后的数字必须是 `0` 或 `1`。"

#: ../../language/fundamentals.md:50
msgid ""
"let bin = 0b110010\n"
"let another_bin = 0B110010\n"
msgstr ""

#: ../../language/fundamentals.md:57
msgid ""
"An octal number has a leading zero followed by a letter \"O\", i.e. "
"`0o`/`0O`. Note that the digits after `0o`/`0O` must be in the range from"
" `0` through `7`:"
msgstr "八进制数有一个前导零，后跟字母 \"O\"，即 `0o`/`0O`。请注意，`0o`/`0O` 后的数字必须在 `0` 到 `7` 的范围内："

#: ../../language/fundamentals.md:60
msgid ""
"let octal = 0o1234\n"
"let another_octal = 0O1234\n"
msgstr ""

#: ../../language/fundamentals.md:67
msgid ""
"A hexadecimal number has a leading zero followed by a letter \"X\", i.e. "
"`0x`/`0X`. Note that the digits after the `0x`/`0X` must be in the range "
"`0123456789ABCDEF`."
msgstr ""
"十六进制数有一个前导零，后跟字母 \"X\"，即 `0x`/`0X`。请注意，`0x`/`0X` 后的数字必须在 "
"`0123456789ABCDEF` 范围内。"

#: ../../language/fundamentals.md:70
msgid ""
"let hex = 0XA\n"
"let another_hex = 0xA_B_C\n"
msgstr ""

#: ../../language/fundamentals.md:77
msgid ""
"A floating-point number literal is 64-bit floating-point number. To "
"define a float, type annotation is needed."
msgstr "浮点数字面量是 64 位浮点数。要定义一个浮点数，需要类型注释。"

#: ../../language/fundamentals.md:79
msgid ""
"let double = 3.14 // Double\n"
"let float : Float = 3.14\n"
"let float2 = (3.14 : Float)\n"
msgstr ""

#: ../../language/fundamentals.md:86
msgid ""
"A 64-bit floating-point number can also be defined using hexadecimal "
"format:"
msgstr "64 位浮点数也可以使用十六进制格式定义："

#: ../../language/fundamentals.md:88
msgid "let hex_double = 0x1.2P3 // (1.0 + 2 / 16) * 2^(+3) == 9\n"
msgstr ""

#: ../../language/fundamentals.md:95
msgid "Overloaded literal"
msgstr "重载字面量"

#: ../../language/fundamentals.md:97
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"literal, and there is no need to specify the type of number via letter "
"postfix:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载字面量，无需通过字母后缀指定数字的类型："

#: ../../language/fundamentals.md:99
msgid ""
"let int : Int = 42\n"
"let uint : UInt = 42\n"
"let int64 : Int64 = 42\n"
"let double : Double = 42\n"
"let float : Float = 42\n"
"let bigint : BigInt = 42\n"
msgstr ""

#: ../../language/fundamentals.md:106
msgid "String"
msgstr "字符串"

#: ../../language/fundamentals.md:108
msgid ""
"`String` holds a sequence of UTF-16 code units. You can use double quotes"
" to create a string, or use `#|` to write a multi-line string."
msgstr "`String` 包含一系列 UTF-16 码点。您可以使用双引号创建字符串，或使用 `#|` 编写多行字符串。"

#: ../../language/fundamentals.md:110
msgid ""
"let a = \"兔rabbit\"\n"
"println(a[0])\n"
"println(a[1])\n"
"let b =\n"
"  #| Hello\n"
"  #| MoonBit\\n\n"
"  #|\n"
"println(b)\n"
msgstr ""

#: ../../language/fundamentals.md:117
msgid ""
"'兔'\n"
"'r'\n"
" Hello\n"
" MoonBit\\n\n"
"\n"
msgstr ""

#: ../../language/fundamentals.md:121
msgid ""
"In double quotes string, a backslash followed by certain special "
"characters forms an escape sequence:"
msgstr "在双引号字符串中，反斜杠后跟某些特殊字符形成转义序列："

#: ../../language/fundamentals.md:117
msgid "escape sequences"
msgstr "转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\n`,`\\r`,`\\t`,`\\b`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "New line, Carriage return, Horizontal tab, Backspace"
msgstr "换行，回车，水平制表符，退格"

#: ../../language/fundamentals.md:117
msgid "`\\\\`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Backslash"
msgstr "反斜杠"

#: ../../language/fundamentals.md:117
msgid "`\\x41`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Hexadecimal escape sequence"
msgstr "十六进制转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\o102`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Octal escape sequence"
msgstr "八进制转义序列"

#: ../../language/fundamentals.md:117
msgid "`\\u5154`,`\\u{1F600}`"
msgstr ""

#: ../../language/fundamentals.md:117
msgid "Unicode escape sequence"
msgstr "Unicode 转义序列"

#: ../../language/fundamentals.md:131
msgid ""
"MoonBit supports string interpolation. It enables you to substitute "
"variables within interpolated strings. This feature simplifies the "
"process of constructing dynamic strings by directly embedding variable "
"values into the text. Variables used for string interpolation must "
"support the `to_string` method."
msgstr ""
"MoonBit "
"支持字符串插值。它允许您在插值字符串中替换变量。此功能通过直接将变量值嵌入文本来简化构建动态字符串的过程。用于字符串插值的变量必须支持 "
"`to_string` 方法。"

#: ../../language/fundamentals.md:133
msgid ""
"let x = 42\n"
"println(\"The answer is \\{x}\")\n"
msgstr ""

#: ../../language/fundamentals.md:140
msgid ""
"Multi-line strings do not support interpolation by default, but you can "
"enable interpolation for a specific line by changing the leading `#|` to "
"`$|`:"
msgstr "多行字符串默认不支持插值，但您可以通过将前导 `#|` 更改为 `$|` 来为特定行启用插值："

#: ../../language/fundamentals.md:142
msgid ""
"let lang = \"MoonBit\"\n"
"let str =\n"
"  #| Hello\n"
"  #| ---\n"
"  $| \\{lang}\\n\n"
"  #| ---\n"
"println(str)\n"
msgstr ""

#: ../../language/fundamentals.md:149
msgid ""
" Hello\n"
" ---\n"
" MoonBit\n"
"\n"
" ---\n"
msgstr ""

#: ../../language/fundamentals.md:153
msgid "Char"
msgstr "字符"

#: ../../language/fundamentals.md:155
msgid "`Char` represents a Unicode code point."
msgstr "`Char` 表示一个 Unicode 码点。"

#: ../../language/fundamentals.md:157
msgid ""
"let a : Char = 'A'\n"
"let b = '\\x41'\n"
"let c = '兔'\n"
"let zero = '\\u{30}'\n"
"let zero = '\\u0030'\n"
msgstr ""

#: ../../language/fundamentals.md:164
msgid "Byte(s)"
msgstr "字节"

#: ../../language/fundamentals.md:166
msgid ""
"A byte literal in MoonBit is either a single ASCII character or a single "
"escape enclosed in single quotes `'`, and preceded by the character `b`. "
"Byte literals are of type `Byte`. For example:"
msgstr ""
"MoonBit 中的字节字面量是一个 ASCII 字符或一个转义字符，用单引号 `'` 括起来，并在前面加上字符 `b`。字节字面量的类型是 "
"`Byte`。例如："

#: ../../language/fundamentals.md:168
msgid ""
"fn main {\n"
"  let b1 : Byte = b'a'\n"
"  println(b1.to_int())\n"
"  let b2 = b'\\xff'\n"
"  println(b2.to_int())\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:176
msgid ""
"97\n"
"255\n"
msgstr ""

#: ../../language/fundamentals.md:180
msgid ""
"A `Bytes` is an immutable sequence of bytes. Similar to byte, bytes "
"literals have the form of `b\"...\"`. For example:"
msgstr "`Bytes` 是不可修改的字节序列。与字节类似，字节序列字面量的形式是 `b\"...\"`。例如："

#: ../../language/fundamentals.md:182
msgid ""
"test {\n"
"  let b1 : Bytes = b\"abcd\"\n"
"  let b2 = b\"\\x61\\x62\\x63\\x64\"\n"
"  assert_eq!(b1, b2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:188
msgid ""
"A `@buffer.T` is a constructor for bytes that comes with methods for "
"writing different kinds of data. For example:"
msgstr "`@buffer.T` 是字节序列的构造器，它带有用于写入不同类型数据的方法。例如："

#: ../../language/fundamentals.md:190
msgid ""
"test \"buffer 1\" {\n"
"  let buf : @buffer.T = @buffer.new()\n"
"  buf.write_bytes(b\"Hello\")\n"
"  buf.write_byte(b'!')\n"
"  assert_eq!(buf.contents(), b\"Hello!\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:196
msgid "Tuple"
msgstr "元组"

#: ../../language/fundamentals.md:198
msgid ""
"A tuple is a collection of finite values constructed using round brackets"
" `()` with the elements separated by commas `,`. The order of elements "
"matters; for example, `(1,true)` and `(true,1)` have different types. "
"Here's an example:"
msgstr ""
"元组是使用圆括号 `()` 构造的有限值集合，元素之间用逗号 `,` 分隔。元素的顺序很重要；例如，`(1,true)` 和 `(true,1)`"
" 有不同的类型。以下是一个示例："

#: ../../language/fundamentals.md:200
msgid ""
"fn main {\n"
"  fn pack(\n"
"    a : Bool,\n"
"    b : Int,\n"
"    c : String,\n"
"    d : Double\n"
"  ) -> (Bool, Int, String, Double) {\n"
"    (a, b, c, d)\n"
"  }\n"
"\n"
"  let quad = pack(false, 100, \"text\", 3.14)\n"
"  let (bool_val, int_val, str, float_val) = quad\n"
"  println(\"\\{bool_val} \\{int_val} \\{str} \\{float_val}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:208
msgid "false 100 text 3.14\n"
msgstr ""

#: ../../language/fundamentals.md:212
msgid "Tuples can be accessed via pattern matching or index:"
msgstr "元组可以通过模式匹配或索引访问："

#: ../../language/fundamentals.md:214
msgid ""
"test {\n"
"  let t = (1, 2)\n"
"  let (x1, y1) = t\n"
"  let x2 = t.0\n"
"  let y2 = t.1\n"
"  assert_eq!(x1, x2)\n"
"  assert_eq!(y1, y2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:220
msgid "Ref"
msgstr ""

#: ../../language/fundamentals.md:222
msgid "A `Ref[T]` is a mutable reference containing a value `val` of type `T`."
msgstr "`Ref[T]` 是一个包含类型 `T` 的值 `val` 的可变引用。"

#: ../../language/fundamentals.md:224
msgid ""
"It can be constructed using `{ val : x }`, and can be accessed using "
"`ref.val`. See [struct](#struct) for detailed explanation."
msgstr "可以使用 `{ val : x }` 构造它，并可以使用 `ref.val` 访问它。有关详细说明，请参见[结构体](#struct)。"

#: ../../language/fundamentals.md:226
msgid ""
"let a : Ref[Int] = { val : 100 }\n"
"\n"
"test {\n"
"  a.val = 200\n"
"  assert_eq!(a.val, 200)\n"
"  a.val += 1\n"
"  assert_eq!(a.val, 201)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:232
msgid "Option and Result"
msgstr "Option 和 Result"

#: ../../language/fundamentals.md:234
msgid ""
"`Option` and `Result` are the most common types to represent a possible "
"error or failure in MoonBit."
msgstr "`Option` 和 `Result` 是 MoonBit 中表示可能的错误或失败的最常见类型。"

#: ../../language/fundamentals.md:236
msgid ""
"`Option[T]` represents a possibly missing value of type `T`. It can be "
"abbreviated as `T?`."
msgstr "`Option[T]` 表示可能缺失的类型 `T` 的值。它可以缩写为 `T?`。"

#: ../../language/fundamentals.md:237
msgid ""
"`Result[T, E]` represents either a value of type `T` or an error of type "
"`E`."
msgstr "`Result[T, E]` 表示类型 `T` 的值或类型 `E` 的错误。"

#: ../../language/fundamentals.md:239
msgid "See [enum](#enum) for detailed explanation."
msgstr "有关详细说明，请参见[枚举](#enum)。"

#: ../../language/fundamentals.md:241
msgid ""
"test {\n"
"  let a : Option[Int] = None\n"
"  let b : Option[Int] = Some(42)\n"
"  let c : Result[Int, String] = Ok(42)\n"
"  let d : Result[Int, String] = Err(\"error\")\n"
"  match a {\n"
"    Some(_) => assert_true!(false)\n"
"    None => assert_true!(true)\n"
"  }\n"
"  match d {\n"
"    Ok(_) => assert_true!(false)\n"
"    Err(_) => assert_true!(true)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:247
msgid "Array"
msgstr "数组"

#: ../../language/fundamentals.md:249
msgid ""
"An array is a finite sequence of values constructed using square brackets"
" `[]`, with elements separated by commas `,`. For example:"
msgstr "数组是使用方括号 `[]` 构造的有限值序列，元素之间用逗号 `,` 分隔。例如："

#: ../../language/fundamentals.md:251
msgid "let numbers = [1, 2, 3, 4]\n"
msgstr ""

#: ../../language/fundamentals.md:258
msgid ""
"You can use `numbers[x]` to refer to the xth element. The index starts "
"from zero."
msgstr "您可以使用 `numbers[x]` 来引用第 x 个元素。索引从零开始。"

#: ../../language/fundamentals.md:260
msgid ""
"test {\n"
"  let numbers = [1, 2, 3, 4]\n"
"  let a = numbers[2]\n"
"  numbers[3] = 5\n"
"  let b = a + numbers[3]\n"
"  assert_eq!(b, 8)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:267
msgid "There are `Array[T]` and `FixedArray[T]`:"
msgstr "有 `Array[T]` 和 `FixedArray[T]`："

#: ../../language/fundamentals.md:269
msgid "`Array[T]` can grow in size, while"
msgstr "`Array[T]` 可以增长，而"

#: ../../language/fundamentals.md:270
msgid ""
"`FixedArray[T]` has a fixed size, thus it needs to be created with "
"initial value."
msgstr "`FixedArray[T]` 有固定的大小，因此需要使用初始值创建。"

#: ../../language/fundamentals.md:273
msgid "A common pitfall is creating `FixedArray` with the same initial value:"
msgstr "一个常见的陷阱是使用相同的初始值创建 `FixedArray`："

#: ../../language/fundamentals.md:275
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::make(10, FixedArray::make(10, 0))"
"\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:282
msgid ""
"This is because all the cells reference to the same object (the "
"`FixedArray[Int]` in this case). One should use `FixedArray::makei()` "
"instead which creates an object for each index."
msgstr ""
"这是因为所有单元格引用相同的对象（在这种情况下是 `FixedArray[Int]`）。应该使用 "
"`FixedArray::makei()`，它为每个索引创建一个对象。"

#: ../../language/fundamentals.md:284
msgid ""
"test {\n"
"  let two_dimension_array = FixedArray::makei(\n"
"    10, \n"
"    fn (_i) { FixedArray::make(10, 0) }\n"
"  )\n"
"  two_dimension_array[0][5] = 10\n"
"  assert_eq!(two_dimension_array[5][5], 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:292
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"array, otherwise `Array[T]` is created:"
msgstr "当期望的类型已知时，MoonBit 可以自动重载数组，否则将创建 `Array[T]`："

#: ../../language/fundamentals.md:295
msgid ""
"let fixed_array_1 : FixedArray[Int] = [1, 2, 3]\n"
"let fixed_array_2 = ([1, 2, 3] : FixedArray[Int])\n"
"let array_3 = [1, 2, 3] // Array[Int]\n"
msgstr ""

#: ../../language/fundamentals.md:301
msgid "ArrayView"
msgstr ""

#: ../../language/fundamentals.md:303
msgid ""
"Analogous to `slice` in other languages, the view is a reference to a "
"specific segment of collections. You can use `data[start:end]` to create "
"a view of array `data`, referencing elements from `start` to `end` "
"(exclusive). Both `start` and `end` indices can be omitted."
msgstr ""
"类似于其他语言中的 `slice`，视图是对集合的特定段的引用。您可以使用 `data[start:end]` 创建数组 `data` "
"的视图，引用从 `start` 到 `end`（不包括）的元素。`start` 和 `end` 索引都可以省略。"

#: ../../language/fundamentals.md:308
msgid ""
"test {\n"
"  let xs = [0, 1, 2, 3, 4, 5]\n"
"  let s1 : ArrayView[Int] = xs[2:]\n"
"  inspect!(s1, content=\"[2, 3, 4, 5]\")\n"
"  inspect!(xs[:4], content=\"[0, 1, 2, 3]\")\n"
"  inspect!(xs[2:5], content=\"[2, 3, 4]\")\n"
"  inspect!(xs[:], content=\"[0, 1, 2, 3, 4, 5]\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:314
msgid "Map"
msgstr "Map"

#: ../../language/fundamentals.md:316
msgid ""
"MoonBit provides a hash map data structure that preserves insertion order"
" called `Map` in its standard library. `Map`s can be created via a "
"convenient literal syntax:"
msgstr "MoonBit 在其标准库中提供了一个保留插入顺序的哈希映射数据结构，称为 `Map`。`Map` 可以通过方便的字面量语法创建："

#: ../../language/fundamentals.md:319
msgid "let map : Map[String, Int] = { \"x\": 1, \"y\": 2, \"z\": 3 }\n"
msgstr ""

#: ../../language/fundamentals.md:325
msgid ""
"Currently keys in map literal syntax must be constant. `Map`s can also be"
" destructed elegantly with pattern matching, see [Map Pattern](#map-"
"pattern)."
msgstr "目前，映射字面量语法中的键必须是常量。`Map` 也可以通过模式匹配优雅地解构，参见 [Map 模式](#map-pattern)。"

#: ../../language/fundamentals.md:327
msgid "Json literal"
msgstr "Json 字面量"

#: ../../language/fundamentals.md:329
msgid ""
"MoonBit supports convenient json handling by overloading literals. When "
"the expected type of an expression is `Json`, number, string, array and "
"map literals can be directly used to create json data:"
msgstr ""
"MoonBit 通过重载字面量支持方便的 json 处理。当表达式的期望类型是 `Json` 时，数字、字符串、数组和映射字面量可以直接用于创建 "
"json 数据："

#: ../../language/fundamentals.md:332
msgid ""
"let moon_pkg_json_example : Json = {\n"
"  \"import\": [\"moonbitlang/core/builtin\", "
"\"moonbitlang/core/coverage\"],\n"
"  \"test-import\": [\"moonbitlang/core/random\"],\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:338
msgid "Json values can be pattern matched too, see [Json Pattern](#json-pattern)."
msgstr "Json 值也可以进行模式匹配，参见 [Json 模式](#json-pattern)。"

#: ../../language/fundamentals.md:340
msgid "Functions"
msgstr "函数"

#: ../../language/fundamentals.md:342
msgid ""
"Functions take arguments and produce a result. In MoonBit, functions are "
"first-class, which means that functions can be arguments or return values"
" of other functions. MoonBit's naming convention requires that function "
"names should not begin with uppercase letters (A-Z). Compare for "
"constructors in the `enum` section below."
msgstr ""
"函数接受参数并产生结果。在 MoonBit 中，函数是一等公民，这意味着函数可以是其他函数的参数或返回值。MoonBit "
"的命名约定要求函数名不应以大写字母（A-Z）开头。请参见下面的 `enum` 部分中的构造器。"

#: ../../language/fundamentals.md:344
msgid "Top-Level Functions"
msgstr "顶层函数"

#: ../../language/fundamentals.md:346
msgid ""
"Functions can be defined as top-level or local. We can use the `fn` "
"keyword to define a top-level function that sums three integers and "
"returns the result, as follows:"
msgstr "函数可以定义为顶级或局部。我们可以使用 `fn` 关键字定义一个顶级函数，它将三个整数相加并返回结果，如下所示："

#: ../../language/fundamentals.md:348
msgid ""
"fn add3(x : Int, y : Int, z : Int) -> Int {\n"
"  x + y + z\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:354
msgid ""
"Note that the arguments and return value of top-level functions require "
"**explicit** type annotations."
msgstr "请注意，顶级函数的参数和返回值需要**显式**类型注释。"

#: ../../language/fundamentals.md:356
msgid "Local Functions"
msgstr "局部函数"

#: ../../language/fundamentals.md:358
msgid ""
"Local functions can be named or anonymous. Type annotations can be "
"omitted for local function definitions: they can be automatically "
"inferred in most cases. For example:"
msgstr "局部函数可以是命名的或匿名的。局部函数定义可以省略类型注释：在大多数情况下，它们可以自动推断。例如："

#: ../../language/fundamentals.md:360
msgid ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // named as `inc`\n"
"    x + 1\n"
"  }\n"
"  // anonymous, instantly applied to integer literal 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"
msgstr ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // 命名为 `inc`\n"
"    x + 1\n"
"  }\n"
"  // 匿名，立即应用于整数字面量 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"

#: ../../language/fundamentals.md:366
msgid ""
"There's also a form called **matrix function** that make use of [pattern "
"matching](#pattern-matching):"
msgstr "还有一种称为**矩阵函数**的形式，它使用[模式匹配](#pattern-matching)："

#: ../../language/fundamentals.md:368
msgid ""
"let extract : (Int?, Int) -> Int = fn {\n"
"  Some(x), _ => x\n"
"  None, default => default\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:374
msgid ""
"Functions, whether named or anonymous, are _lexical closures_: any "
"identifiers without a local binding must refer to bindings from a "
"surrounding lexical scope. For example:"
msgstr "函数，无论是命名的还是匿名的，都是 _词法闭包_：没有局部绑定的任何标识符必须引用来自周围词法范围的绑定。例如："

#: ../../language/fundamentals.md:376
msgid ""
"let global_y = 3\n"
"\n"
"fn local_2(x : Int) -> (Int, Int) {\n"
"  fn inc() {\n"
"    x + 1\n"
"  }\n"
"\n"
"  fn four() {\n"
"    global_y + 1\n"
"  }\n"
"\n"
"  (inc(), four())\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_2(3), (4, 4))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:382
msgid "Function Applications"
msgstr "函数应用"

#: ../../language/fundamentals.md:384
msgid "A function can be applied to a list of arguments in parentheses:"
msgstr "函数可以应用于括号中的参数列表："

#: ../../language/fundamentals.md:386
msgid "add3(1, 2, 7)\n"
msgstr ""

#: ../../language/fundamentals.md:390
msgid ""
"This works whether `add3` is a function defined with a name (as in the "
"previous example), or a variable bound to a function value, as shown "
"below:"
msgstr "无论 `add3` 是一个使用名称定义的函数（如前面的示例）还是绑定到函数值的变量，都可以工作，如下所示："

#: ../../language/fundamentals.md:392
msgid ""
"test {\n"
"  let add3 = fn(x, y, z) { x + y + z }\n"
"  assert_eq!(add3(1, 2, 7), 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:398
msgid ""
"The expression `add3(1, 2, 7)` returns `10`. Any expression that "
"evaluates to a function value is applicable:"
msgstr "表达式 `add3(1, 2, 7)` 返回 `10`。任何求值为函数值的表达式都是可应用的："

#: ../../language/fundamentals.md:400
msgid ""
"test {\n"
"  let f = fn(x) { x + 1 }\n"
"  let g = fn(x) { x + 2 }\n"
"  let w = (if true { f } else { g })(3)\n"
"  assert_eq!(w, 4)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:407
msgid "Labelled arguments"
msgstr "带标签的参数"

#: ../../language/fundamentals.md:409
msgid ""
"**Top-level** functions can declare labelled argument with the syntax "
"`label~ : Type`. `label` will also serve as parameter name inside "
"function body:"
msgstr "**顶层**函数可以使用语法 `label~ : Type` 声明带标签的参数。`label` 也将作为函数体内的参数名："

#: ../../language/fundamentals.md:411
msgid ""
"fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {\n"
"  arg1 + arg2\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:417
msgid ""
"Labelled arguments can be supplied via the syntax `label=arg`. "
"`label=label` can be abbreviated as `label~`:"
msgstr "可以通过语法 `label=arg` 提供带标签的参数。`label=label` 可以缩写为 `label~`："

#: ../../language/fundamentals.md:419
msgid ""
"test {\n"
"  let arg1 = 1\n"
"  assert_eq!(labelled_1(arg2=2, arg1~), 3)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:425
msgid ""
"Labelled function can be supplied in any order. The evaluation order of "
"arguments is the same as the order of parameters in function declaration."
msgstr "带标签的函数可以以任何顺序提供。参数的求值顺序与函数声明中参数的顺序相同。"

#: ../../language/fundamentals.md:427
msgid "Optional arguments"
msgstr "可选参数"

#: ../../language/fundamentals.md:429
msgid ""
"A labelled argument can be made optional by supplying a default "
"expression with the syntax `label~ : Type = default_expr`. If this "
"argument is not supplied at call site, the default expression will be "
"used:"
msgstr ""
"可以通过语法 `label~ : Type = default_expr` "
"提供默认值，使带标签的参数可以省略。如果在调用时未提供此参数，则将使用默认表达式："

#: ../../language/fundamentals.md:431
msgid ""
"fn optional(opt~ : Int = 42) -> Int {\n"
"  opt\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(optional(), 42)\n"
"  assert_eq!(optional(opt=0), 0)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:437
msgid ""
"The default expression will be evaluated every time it is used. And the "
"side effect in the default expression, if any, will also be triggered. "
"For example:"
msgstr "默认表达式每次使用时都会被求值。并且默认表达式中的副作用（如果有）也会被触发。例如："

#: ../../language/fundamentals.md:439
msgid ""
"fn incr(counter~ : Ref[Int] = { val: 0 }) -> Ref[Int] {\n"
"  counter.val = counter.val + 1\n"
"  counter\n"
"}\n"
"\n"
"test {\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  let counter : Ref[Int] = { val: 0 }\n"
"  inspect!(incr(counter~), content=\"{val: 1}\")\n"
"  inspect!(incr(counter~), content=\"{val: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:445
msgid ""
"If you want to share the result of default expression between different "
"function calls, you can lift the default expression to a toplevel `let` "
"declaration:"
msgstr "如果要在不同的函数调用之间共享默认表达式的结果，可以将默认表达式提升到顶层 `let` 声明："

#: ../../language/fundamentals.md:447
msgid ""
"let default_counter : Ref[Int] = { val: 0 }\n"
"\n"
"fn incr_2(counter~ : Ref[Int] = default_counter) -> Int {\n"
"  counter.val = counter.val + 1\n"
"  counter.val\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(incr_2(), 1)\n"
"  assert_eq!(incr_2(), 2)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:453
msgid ""
"Default expression can depend on the value of previous arguments. For "
"example:"
msgstr "默认表达式可以依赖于先前参数的值。例如："

#: ../../language/fundamentals.md:455
msgid ""
"fn sub_array[X](\n"
"  xs : Array[X],\n"
"  offset~ : Int,\n"
"  len~ : Int = xs.length() - offset\n"
") -> Array[X] {\n"
"  xs[offset:offset + len].iter().to_array()\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1), [2, 3])\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1, len=1), [2])\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:462
msgid "Automatically insert `Some` when supplying optional arguments"
msgstr "在提供可选参数时自动插入 `Some`"

#: ../../language/fundamentals.md:464
msgid ""
"It is quite often optional arguments have type `T?` with `None` as "
"default value. In this case, passing the argument explicitly requires "
"wrapping a `Some`, which is ugly:"
msgstr "通常可选参数的类型为 `T?`，默认值为 `None`。在这种情况下，显式传递参数需要包装一个 `Some`，这很丑："

#: ../../language/fundamentals.md:468
msgid ""
"fn ugly_constructor(width~ : Int? = None, height~ : Int? = None) -> Image"
" {\n"
"  ...\n"
"}\n"
"\n"
"let img : Image = ugly_constructor(width=Some(1920), height=Some(1080))\n"
msgstr ""

#: ../../language/fundamentals.md:474
msgid ""
"Fortunately, MoonBit provides a special kind of optional arguments to "
"solve this problem. Optional arguments declared with `label? : T` has "
"type `T?` and `None` as default value. When supplying this kind of "
"optional argument directly, MoonBit will automatically insert a `Some`:"
msgstr ""
"幸运的是，MoonBit 提供了一种特殊类型的可选参数来解决这个问题。使用 `label? : T` 声明的可选参数的类型为 `T?`，默认值为 "
"`None`。在直接提供这种可选参数时，MoonBit 将自动插入 `Some`："

#: ../../language/fundamentals.md:478
msgid ""
"fn nice_constructor(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"let img2 : Image = nice_constructor(width=1920, height=1080)\n"
msgstr ""

#: ../../language/fundamentals.md:484
msgid ""
"Sometimes, it is also useful to pass a value of type `T?` directly, for "
"example when forwarding optional argument. MoonBit provides a syntax "
"`label?=value` for this, with `label?` being an abbreviation of "
"`label?=label`:"
msgstr ""
"有时，直接传递类型为 `T?` 的值也很有用，例如在转发可选参数时。MoonBit 为此提供了一个语法 `label?=value`，并且 "
"`label?` 是 `label?=label` 的缩写："

#: ../../language/fundamentals.md:488
msgid ""
"fn image(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"fn fixed_width_image(height? : Int) -> Image {\n"
"  image(width=1920, height?)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:494
msgid "Autofill arguments"
msgstr "自动填充参数"

#: ../../language/fundamentals.md:496
msgid ""
"MoonBit supports filling specific types of arguments automatically at "
"different call site, such as the source location of a function call. To "
"declare an autofill argument, simply declare an optional argument with "
"`_` as default value. Now if the argument is not explicitly supplied, "
"MoonBit will automatically fill it at the call site."
msgstr ""
"MoonBit 支持在调用时自动填充特定类型的参数，例如函数调用的源位置。要声明一个自动填充参数，只需将一个可选参数声明为 `_` "
"作为默认值。现在，如果未显式提供参数，MoonBit 将在调用时自动填充它。"

#: ../../language/fundamentals.md:500
msgid ""
"Currently MoonBit supports two types of autofill arguments, `SourceLoc`, "
"which is the source location of the whole function call, and `ArgsLoc`, "
"which is a array containing the source location of each argument, if any:"
msgstr ""
"目前 MoonBit 支持两种类型的自动填充参数，`SourceLoc`，它是整个函数调用的源位置，以及 "
"`ArgsLoc`，它是一个数组，包含每个参数的源位置（如果有）："

#: ../../language/fundamentals.md:503
msgid ""
"fn f(_x : Int, loc~ : SourceLoc = _, args_loc~ : ArgsLoc = _) -> String {"
"\n"
"  $|loc of whole function call: \\{loc}\n"
"  $|loc of arguments: \\{args_loc}\n"
"  // loc of whole function call: <filename>:7:3-7:10\n"
"  // loc of arguments: [Some(<filename>:7:5-7:6), "
"Some(<filename>:7:8-7:9), None, None]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:509
msgid ""
"Autofill arguments are very useful for writing debugging and testing "
"utilities."
msgstr "自动填充参数非常有用，用于编写调试和测试工具。"

#: ../../language/fundamentals.md:511
msgid "Control Structures"
msgstr "控制结构"

#: ../../language/fundamentals.md:513
msgid "Conditional Expressions"
msgstr "条件表达式"

#: ../../language/fundamentals.md:515
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional `else` clause or `else if` clause."
msgstr "条件表达式由条件、结果和可选的 `else` 子句或 `else if` 子句组成。"

#: ../../language/fundamentals.md:517
msgid ""
"if x == y {\n"
"  expr1\n"
"} else if x == z {\n"
"  expr2\n"
"} else {\n"
"  expr3\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:524
msgid "The curly brackets around the consequent are required."
msgstr "结果周围的大括号是必需的。"

#: ../../language/fundamentals.md:526
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and"
" the return values of the consequent and the else clause must be of the "
"same type. Here is an example:"
msgstr "请注意，条件表达式在 MoonBit 中始终返回一个值，结果和 else 子句的返回值必须是相同的类型。以下是一个示例："

#: ../../language/fundamentals.md:528
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/fundamentals.md:535
msgid "The `else` clause can only be omitted if the return value has type `Unit`."
msgstr "`else` 子句只有在返回值的类型为 `Unit`的时候省略。"

#: ../../language/fundamentals.md:537
msgid "Match Expression"
msgstr "匹配表达式"

#: ../../language/fundamentals.md:539
msgid ""
"The `match` expression is similar to conditional expression, but it uses "
"[pattern matching](#pattern-matching) to decide which consequent to "
"evaluate and extracting variables at the same time."
msgstr "`match` 表达式类似于条件表达式，但它使用[模式匹配](#pattern-matching)来决定要评估哪个结果，并同时提取变量。"

#: ../../language/fundamentals.md:541
msgid ""
"fn decide_sport(weather : String, humidity : Int) -> String {\n"
"  match weather {\n"
"    \"sunny\" => \"tennis\"\n"
"    \"rainy\" => if humidity > 80 { \"swimming\" } else { \"football\" }\n"
"    _ => \"unknown\"\n"
"  }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(decide_sport(\"sunny\", 0), \"tennis\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:548
msgid ""
"If a possible condition is omitted, the compiler will issue a warning, "
"and the program will terminate if that case were reached."
msgstr "如果省略了可能的条件，编译器将发出警告；如果真的出现该情况，程序将终止。"

#: ../../language/fundamentals.md:550
msgid "Guard Statement"
msgstr "卫语句"

#: ../../language/fundamentals.md:552
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing "
"the subsequent statements and returns. If the condition is not satisfied "
"(i.e., false), the code in the `else` block is executed and its "
"evaluation result is returned (the subsequent statements are skipped)."
msgstr ""
"`guard` 语句用于检查指定的不变量。如果不变量的条件得到满足，程序将继续执行后续语句。如果条件不满足（即为假），则执行 `else` "
"块中的代码且返回其值（并跳过后续语句）。"

#: ../../language/fundamentals.md:557
msgid ""
"fn guarded_get(array : Array[Int], index : Int) -> Int? {\n"
"  guard index >= 0 && index < array.length() else { None }\n"
"  Some(array[index])\n"
"}\n"
"\n"
"test {\n"
"  inspect!(guarded_get([1, 2, 3], -1), content=\"None\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:564
msgid "Guarded Let"
msgstr "卫语句与赋值绑定"

#: ../../language/fundamentals.md:566
msgid ""
"The `let` statement can be used with [pattern matching](#pattern-"
"matching). However, `let` statement can only handle one case. And `guard "
"let` can solve this issue."
msgstr ""
"`let` 语句可以与[模式匹配](#pattern-matching)一起使用。但是，`let` 语句只能处理一种情况。`guard let` "
"可以解决这个问题。"

#: ../../language/fundamentals.md:568
msgid ""
"In the following example, `getProcessedText` assumes that the input "
"`path` points to resources that are all plain text, and it uses the "
"`guard` statement to ensure this invariant. Compared to using a `match` "
"statement, the subsequent processing of `text` can have one less level of"
" indentation."
msgstr ""
"在以下示例中，`getProcessedText` 假设输入的 `path` 指向的资源都是纯文本，并使用 `guard` "
"语句来确保这个不变量。与使用 `match` 语句相比，`text` 的后续处理可以少一级缩进。"

#: ../../language/fundamentals.md:572
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String\n"
") -> String!Error {\n"
"  guard let Some(PlainText(text)) = resources[path] else {\n"
"    None => fail!(\"\\{path} not found\")\n"
"    Some(Folder(_)) => fail!(\"\\{path} is a folder\")\n"
"    Some(JsonConfig(_)) => fail!(\"\\{path} is a json config\")\n"
"  }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:578
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr "如果省略了 `else` 部分，程序将在 `guard` 语句中指定的条件不为真或无法匹配时终止。"

#: ../../language/fundamentals.md:581
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard let Some(x) = expr\n"
"// <=> guard let Some(x) = expr else { _ => panic() }\n"
msgstr ""

#: ../../language/fundamentals.md:588
msgid "While loop"
msgstr "While 循环"

#: ../../language/fundamentals.md:590
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code "
"repeatedly as long as a condition is true. The condition is evaluated "
"before executing the block of code. The `while` loop is defined using the"
" `while` keyword, followed by a condition and the loop body. The loop "
"body is a sequence of statements. The loop body is executed as long as "
"the condition is true."
msgstr ""
"在 MoonBit 中，`while` 循环可用于在条件为真时重复执行一段代码块。在执行代码块之前，将评估条件。使用 `while` 关键字定义 "
"`while` 循环，后跟条件和循环体。循环体是一系列语句。只要条件为真，就会执行循环体。"

#: ../../language/fundamentals.md:592
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:600
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/fundamentals.md:604
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you "
"to exit the current loop, while using `continue` skips the remaining part"
" of the current iteration and proceeds to the next iteration."
msgstr ""
"循环体支持 `break` 和 `continue`。使用 `break` 可以退出当前循环，而使用 `continue` "
"则跳过当前迭代的剩余部分并继续下一次迭代。"

#: ../../language/fundamentals.md:606
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:614
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/fundamentals.md:618
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the"
" loop will end."
msgstr "`while` 循环还支持可选的 `else` 子句。当循环条件变为假时，将执行 `else` 子句，然后循环将结束。"

#: ../../language/fundamentals.md:620
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:628
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:632
msgid ""
"When there is an `else` clause, the `while` loop can also return a value."
" The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value"
" of the `else` clause."
msgstr ""
"当有 `else` 子句时，`while` 循环还可以返回一个值。返回值是 `else` 子句的评估结果。在这种情况下，如果使用 `break` "
"退出循环，需要在 `break` 后提供一个返回值，该返回值应与 `else` 子句的返回值类型相同。"

#: ../../language/fundamentals.md:634
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:642
msgid "5\n"
msgstr ""

#: ../../language/fundamentals.md:646
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:654
msgid "7\n"
msgstr ""

#: ../../language/fundamentals.md:658
msgid "For Loop"
msgstr "For 循环"

#: ../../language/fundamentals.md:660
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by"
" variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. "
"For example, the code below creates a new variable binding `i`, which has"
" a scope throughout the entire loop and is immutable. This makes it "
"easier to write clear code and reason about it:"
msgstr ""
"MoonBit 还支持 C 风格的 For 循环。关键字 `for` "
"后跟由分号分隔的变量初始化子句、循环条件和更新子句。它们不需要用括号括起来。例如，下面的代码创建了一个新的变量绑定 "
"`i`，它在整个循环中都有作用域且是不可变的。这使得编写清晰的代码并对其进行推理更容易："

#: ../../language/fundamentals.md:663
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:671
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/fundamentals.md:675
msgid "The variable initialization clause can create multiple bindings:"
msgstr "变量初始化子句可以创建多个绑定："

#: ../../language/fundamentals.md:677
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:684
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In "
"other words, in the example above, the update clause does not execute `i "
"= i + 1`, `j = j + 1` sequentially, but rather increments `i` and `j` at "
"the same time. Therefore, when reading the values of the binding "
"variables in the update clause, you will always get the values updated in"
" the previous iteration."
msgstr ""
"应该注意，在更新子句中，当有多个绑定变量时，语义是同时更新它们。换句话说，在上面的示例中，更新子句不会按顺序执行 `i = i + 1`，`j ="
" j + 1`，而是同时递增 `i` 和 `j`。因此，在更新子句中读取绑定变量的值时，总是会得到上一次迭代中更新的值。"

#: ../../language/fundamentals.md:686
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are "
"all optional. For example, the following two are infinite loops:"
msgstr "变量初始化子句、循环条件和更新子句都是可选的。例如，以下两个是无限循环："

#: ../../language/fundamentals.md:688
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:695
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. "
"Like the `while` loop, the `for` loop can also return a value using the "
"`break` and `else` clauses."
msgstr ""
"`for` 循环还支持 `continue`、`break` 和 `else` 子句。与 `while` 循环一样，`for` 循环也可以使用 "
"`break` 和 `else` 子句返回一个值。"

#: ../../language/fundamentals.md:697
msgid ""
"The `continue` statement skips the remaining part of the current "
"iteration of the `for` loop (including the update clause) and proceeds to"
" the next iteration. The `continue` statement can also update the binding"
" variables of the `for` loop, as long as it is followed by expressions "
"that match the number of binding variables, separated by commas."
msgstr ""
"`continue` 语句跳过当前 `for` 循环的剩余部分（包括更新子句）并继续下一次迭代。`continue` 语句还可以更新 `for` "
"循环的绑定变量，只要后面跟着与绑定变量数量匹配的表达式，用逗号分隔。"

#: ../../language/fundamentals.md:699
msgid ""
"For example, the following program calculates the sum of even numbers "
"from 1 to 6:"
msgstr "例如，以下程序计算从 1 到 6 的偶数之和："

#: ../../language/fundamentals.md:701
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:709
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/fundamentals.md:713
msgid "`for .. in` loop"
msgstr "`for .. in` 循环"

#: ../../language/fundamentals.md:715
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr "MoonBit 支持通过 `for .. in` 循环语法遍历不同数据结构和序列的元素："

#: ../../language/fundamentals.md:717
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:724
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard"
" library. Any type with a method `.iter() : Iter[T]` can be traversed "
"using `for .. in`. For more information of the `Iter` type, see "
"[Iterator](#iterator) below."
msgstr ""
"`for .. in` 循环被转换为在 MoonBit 标准库中使用 `Iter`。任何具有方法 `.iter() : Iter[T]` "
"的类型都可以使用 `for .. in` 进行遍历。有关 `Iter` 类型的更多信息，请参见下面的[迭代器](#iterator)。"

#: ../../language/fundamentals.md:727
msgid ""
"`for .. in` loop also supports iterating through a sequence of integers, "
"such as:"
msgstr "`for .. in` 循环还支持遍历整数序列，例如："

#: ../../language/fundamentals.md:729
msgid ""
"test {\n"
"  let mut i = 0\n"
"  for j in 0..<10 {\n"
"    i += j\n"
"  }\n"
"  assert_eq!(i, 45)\n"
"  let mut k = 0\n"
"  for l in 0..=10 {\n"
"    k += l\n"
"  }\n"
"  assert_eq!(k, 55)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:736
msgid ""
"In addition to sequences of a single value, MoonBit also supports "
"traversing sequences of two values, such as `Map`, via the `Iter2` type "
"in MoonBit's standard library. Any type with method `.iter2() : Iter2[A, "
"B]` can be traversed using `for .. in` with two loop variables:"
msgstr ""
"除了单个值的序列外，MoonBit 还支持通过 MoonBit 标准库中的 `Iter2` 类型遍历两个值的序列，例如 `Map`。任何具有方法 "
"`.iter2() : Iter2[A, B]` 的类型都可以使用两个循环变量的 `for .. in` 进行遍历："

#: ../../language/fundamentals.md:739
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:746
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr "另一个使用两个循环变量的 `for .. in` 的示例是在遍历数组时跟踪数组索引："

#: ../../language/fundamentals.md:748
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:756
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/fundamentals.md:760
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr "`for .. in` 循环的主体支持诸如 `return`、`break` 和错误处理等控制流操作："

#: ../../language/fundamentals.md:762
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:770
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/fundamentals.md:774
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr "如果循环变量未使用，可以使用 `_` 忽略它。"

#: ../../language/fundamentals.md:776
msgid "Functional loop"
msgstr "函数式循环"

#: ../../language/fundamentals.md:778
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to "
"write loops in a functional style."
msgstr "函数式循环是 MoonBit 中的一个强大功能，它使您可以以函数式风格编写循环。"

#: ../../language/fundamentals.md:780
msgid ""
"A functional loop consumes arguments and returns a value. It is defined "
"using the `loop` keyword, followed by its arguments and the loop body. "
"The loop body is a sequence of clauses, each of which consists of a "
"pattern and an expression. The clause whose pattern matches the input "
"will be executed, and the loop will return the value of the expression. "
"If no pattern matches, the loop will panic. Use the `continue` keyword "
"with arguments to start the next iteration of the loop. Use the `break` "
"keyword with arguments to return a value from the loop. The `break` "
"keyword can be omitted if the value is the last expression in the loop "
"body."
msgstr ""
"函数式循环接收参数并返回一个值。它使用 `loop` "
"关键字定义，后跟其参数和循环体。循环体是一系列子句，每个子句由模式和表达式组成。与输入匹配的模式的子句将会被执行，并且循环将返回表达式的值。如果没有对应的模式，程序会中止。使用"
" `continue` 关键字和参数进入循环的下一次迭代。使用 `break` "
"关键字和参数从循环中返回一个值。如果值是循环体中的最后一个表达式，则可以省略 `break` 关键字。"

#: ../../language/fundamentals.md:782
msgid ""
"test {\n"
"  fn sum(xs : @immut/list.T[Int]) -> Int {\n"
"    loop xs, 0 {\n"
"      Nil, acc => break acc // <=> Nil, acc => acc\n"
"      Cons(x, rest), acc => continue rest, x + acc\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq!(sum(Cons(1, Cons(2, Cons(3, Nil)))), 6)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:789
msgid ""
"Currently in `loop exprs { ... }`, `exprs` is nonempty list, while `for {"
" ... }` is accepted for infinite loop."
msgstr "目前在 `loop exprs { ... }` 中，`exprs` 是非空列表，而 `for { ... }` 用于无限循环。"

#: ../../language/fundamentals.md:792
msgid "Labelled Continue/Break"
msgstr ""

#: ../../language/fundamentals.md:794
msgid ""
"When a loop is labelled, it can be referenced from a `break` or "
"`continue` from within a nested loop. For example:"
msgstr ""

#: ../../language/fundamentals.md:797
msgid ""
"test \"break label\" {\n"
"  let mut count = 0\n"
"  let xs = [1, 2, 3]\n"
"  let ys = [4, 5, 6]\n"
"  let res = outer~: for i in xs {\n"
"    for j in ys {\n"
"      count = count + i\n"
"      break outer~ j\n"
"    }\n"
"  } else {\n"
"    -1\n"
"  }\n"
"  assert_eq!(res, 4)\n"
"  assert_eq!(count, 1)\n"
"}\n"
"\n"
"test \"continue label\" {\n"
"  let mut count = 0\n"
"  let init = 10\n"
"  let res =outer~: loop init {\n"
"    0 => 42\n"
"    i => {\n"
"      for {\n"
"        count = count + 1\n"
"        continue outer~ i - 1\n"
"      }\n"
"    }\n"
"  }\n"
"  assert_eq!(res, 42)\n"
"  assert_eq!(count, 10)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:803
msgid "Iterator"
msgstr "迭代器"

#: ../../language/fundamentals.md:805
msgid ""
"An iterator is an object that traverse through a sequence while providing"
" access to its elements. Traditional OO languages like Java's "
"`Iterator<T>` use `next()` `hasNext()` to step through the iteration "
"process, whereas functional languages (JavaScript's `forEach`, Lisp's "
"`mapcar`) provides a high-order function which takes an operation and a "
"sequence then consumes the sequence with that operation being applied to "
"the sequence. The former is called _external iterator_ (visible to user) "
"and the latter is called _internal iterator_ (invisible to user)."
msgstr ""
"迭代器是一个对象，它在遍历序列的同时提供对其元素的访问。传统的面向对象语言如 Java 的 `Iterator<T>` 使用 `next()` "
"`hasNext()` 来遍历迭代过程，而函数式语言（JavaScript 的 `forEach`，Lisp 的 "
"`mapcar`）提供了一个高阶函数，该函数接受一个操作和一个序列，然后使用该操作应用于序列。前者称为_外部迭代器_（对用户可见），后者称为_内部迭代器_（对用户不可见）。"

#: ../../language/fundamentals.md:813
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator "
"implementation. Almost all built-in sequential data structures have "
"implemented `Iter`:"
msgstr "内置类型 `Iter[T]` 是 MoonBit 的内部迭代器实现。几乎所有内置的顺序数据结构都已经实现了 `Iter`："

#: ../../language/fundamentals.md:816
msgid ""
"///|\n"
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(fn { x => (x & 1) == 0 }).collect()\n"
"}\n"
"\n"
"///|\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::op_mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:822
msgid "Commonly used methods include:"
msgstr "常用的方法包括："

#: ../../language/fundamentals.md:824
msgid ""
"`each`: Iterates over each element in the iterator, applying some "
"function to each element."
msgstr "`each`: 遍历迭代器中的每个元素，对每个元素应用某个函数。"

#: ../../language/fundamentals.md:825
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr "`fold`: 使用给定的函数，从给定的初始值开始，对迭代器的元素进行“折叠”。"

#: ../../language/fundamentals.md:826
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr "`collect`: 将迭代器的元素收集到一个数组中。"

#: ../../language/fundamentals.md:828
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a "
"predicate function."
msgstr "`filter`: （惰性）根据谓词函数过滤迭代器的元素。"

#: ../../language/fundamentals.md:829
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr "`map`: （惰性）使用映射函数转换迭代器的元素。"

#: ../../language/fundamentals.md:830
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the "
"elements of the second iterator to the first."
msgstr "`concat`: （惰性）通过将第二个迭代器的元素附加到第一个迭代器，将两个迭代器合并为一个。"

#: ../../language/fundamentals.md:832
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. "
"Array. But what makes `Iter` special is that any method that constructs a"
" new `Iter` is _lazy_ (i.e. iteration doesn't start on call because it's "
"wrapped inside a function), as a result of no allocation for intermediate"
" value. That's what makes `Iter` superior for traversing through "
"sequence: no extra cost. MoonBit encourages user to pass an `Iter` across"
" functions instead of the sequence object itself."
msgstr ""
"像 `filter` `map` 这样的方法在序列对象（例如 Array）上非常常见。但是，`Iter` 的不同之处在于，任何构造新 `Iter`"
" 的方法都是**惰性**的（即在调用时不会开始迭代，因为它被包装在一个函数内），因此不会为中间值分配内存。这就是使 `Iter` "
"优于遍历序列的原因：没有额外的成本。MoonBit 鼓励用户将 `Iter` 传递给函数，而不是传递序列对象本身。"

#: ../../language/fundamentals.md:840
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement "
"`Iter`, namely, a function that returns an `Iter[S]`. Take `Bytes` as an "
"example:"
msgstr ""
"预定义的序列结构如 `Array` 及其迭代器应该足够使用。但是，为了在自定义序列（元素类型为 `S`）中使用这些方法，我们需要实现 "
"`Iter`，即返回 `Iter[S]` 的函数。以 `Bytes` 为例："

#: ../../language/fundamentals.md:845
msgid ""
"///|\n"
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"    for byte in data {\n"
"      guard let IterContinue = visit(byte) else { x => break x }\n"
"\n"
"    } else {\n"
"      IterContinue\n"
"    }\n"
"  })\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:851
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the "
"only main difference being the code block that actually does the "
"iteration."
msgstr "几乎所有 `Iter` 实现都与 `Bytes` 的实现相同，唯一的主要区别是实际执行迭代的代码块。"

#: ../../language/fundamentals.md:854
msgid "Implementation details"
msgstr "实现细节"

#: ../../language/fundamentals.md:856
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration"
" which consists any of the 2 states:"
msgstr ""
"类型 `Iter[T]` 基本上是 `((T) -> IterResult) -> IterResult` "
"的类型别名，它是一个高阶函数，接受一个操作，`IterResult` 是一个枚举对象，用于跟踪当前迭代的状态，包含以下 2 种状态："

#: ../../language/fundamentals.md:861
msgid "`IterEnd`: marking the end of an iteration"
msgstr "`IterEnd`: 标记迭代结束"

#: ../../language/fundamentals.md:862
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr "`IterContinue`: 标记迭代结束尚未到达，暗示迭代将在此状态继续。"

#: ../../language/fundamentals.md:864
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use "
"it to transform `Iter[T]` itself to a new state of type `IterResult`. "
"Whether that state being `IterEnd` `IterContinue` depends on the "
"function."
msgstr ""
"简单来说，`Iter[T]` 接受一个函数 `(T) -> IterResult` 并使用它将 `Iter[T]` 本身转换为类型为 "
"`IterResult` 的新状态。"

#: ../../language/fundamentals.md:868
msgid ""
"Iterator provides a unified way to iterate through data structures, and "
"they can be constructed at basically no cost: as long as `fn(yield)` "
"doesn't execute, the iteration process doesn't start."
msgstr "迭代器提供了一种统一的遍历数据结构的方式，它们基本上可以无成本地构建：只要 `fn(yield)` 不执行，迭代过程就不会开始。"

#: ../../language/fundamentals.md:872
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all"
" sorts of `Iter` methods might be visually pleasing, but do notice the "
"heavy work underneath the abstraction."
msgstr "`Iter::run()` 在在内部触发迭代。链接各种 `Iter` 方法可能看起来很美观，但请注意抽象层下面的繁重工作。"

#: ../../language/fundamentals.md:876
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no "
"way to stop unless the end is reached. Methods such as `count()` which "
"counts the number of elements in a iterator looks like an `O(1)` "
"operation but actually has linear time complexity. Carefully use "
"iterators or performance issue might occur."
msgstr ""
"因此，与外部迭代器不同，一旦迭代开始，除非到达末尾，否则无法停止。诸如 `count()` 这样的方法，它计算迭代器中元素的数量看起来像是一个 "
"`O(1)` 操作，但实际上具有线性时间复杂度。请谨慎使用迭代器，否则可能会出现性能问题。"

#: ../../language/fundamentals.md:882
msgid "Custom Data Types"
msgstr "自定义数据类型"

#: ../../language/fundamentals.md:884
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr "创建新数据类型有两种方法：`struct` 和 `enum`。"

#: ../../language/fundamentals.md:886
msgid "Struct"
msgstr "结构体"

#: ../../language/fundamentals.md:888
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed "
"by field names. A struct can be constructed using a struct literal, which"
" is composed of a set of labeled values and delimited with curly "
"brackets. The type of a struct literal can be automatically inferred if "
"its fields exactly match the type definition. A field can be accessed "
"using the dot syntax `s.f`. If a field is marked as mutable using the "
"keyword `mut`, it can be assigned a new value."
msgstr ""
"在 MoonBit "
"中，结构体类似于元组，但其字段由字段名称索引。可以使用结构体字面量构造结构体，结构体字面量由一组带标签的值组成，并用大括号括起来。如果结构体的字段与类型定义完全匹配，那么结构体字面量的类型可以自动推断。可以使用点语法"
" `s.f` 访问字段。如果使用关键字 `mut` 标记字段为可变的，则可以为其分配新值。"

#: ../../language/fundamentals.md:890
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:896
msgid ""
"fn main {\n"
"  let u = User::{ id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  //! u.id = 10\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:904
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/fundamentals.md:908
msgid "Constructing Struct with Shorthand"
msgstr "使用简写构造结构体"

#: ../../language/fundamentals.md:910
msgid ""
"If you already have some variable like `name` and `email`, it's redundant"
" to repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr "如果已经有一些变量，如 `name` 和 `email`，在构造结构体时重复这些名称是多余的。可以使用简写，它的行为完全相同："

#: ../../language/fundamentals.md:912
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = User::{ id: 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:919
msgid ""
"If there's no other struct that has the same fields, it's redundant to "
"add the struct's name when constructing it:"
msgstr "如果没有其他具有相同字段的结构体，在构造结构体时添加结构体的名称是多余的："

#: ../../language/fundamentals.md:921
msgid "let u2 = { id : 0, name, email }\n"
msgstr ""

#: ../../language/fundamentals.md:928
msgid "Struct Update Syntax"
msgstr "结构体更新语法"

#: ../../language/fundamentals.md:930
msgid ""
"It's useful to create a new struct based on an existing one, but with "
"some fields updated."
msgstr "可以用这个语法来根据现有结构体创建一个新的结构体，但只更新部分字段。"

#: ../../language/fundamentals.md:932
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"    $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:940
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/fundamentals.md:944
msgid "Enum"
msgstr "枚举"

#: ../../language/fundamentals.md:946
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr "枚举类型类似于函数式语言中的代数数据类型。熟悉 C/C++ 的用户可能更喜欢称其为标记联合。"

#: ../../language/fundamentals.md:948
msgid ""
"An enum can have a set of cases (constructors). Constructor names must "
"start with capitalized letter. You can use these names to construct "
"corresponding cases of an enum, or checking which branch an enum value "
"belongs to in pattern matching:"
msgstr "枚举可以有一组情况（构造函数）。构造函数的名称必须以大写字母开头。可以使用这些名称来构造枚举的相应情况，或在模式匹配中检查枚举值属于哪个分支："

#: ../../language/fundamentals.md:950
msgid ""
"/// An enum type that represents the ordering relation between two "
"values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""
"/// 一个枚举类型，表示两个值之间的顺序关系，\n"
"/// 有三种情况 \"Smaller\"、\"Greater\" 和 \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"

#: ../../language/fundamentals.md:956
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""
"/// 比较两个整数之间的顺序关系\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // 当创建一个枚举时，如果目标类型已知，\n"
"    // 可以直接写构造函数名称\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // 但是当目标类型未知时，\n"
"    // 你总是可以使用 `TypeName::Constructor` 来创建一个枚举\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// 输出一个类型为 `Relation` 的值\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // 使用模式匹配来决定 `r` 属于哪种情况\n"
"  match r {\n"
"    // 在模式匹配期间，如果类型已知，\n"
"    // 写构造函数的名称就足够了\n"
"    Smaller => println(\"smaller!\")\n"
"    // 但是你也可以在模式匹配中使用 `TypeName::Constructor` 语法\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:963
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:971
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/fundamentals.md:975
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr "枚举情况也可以携带额外数据。以下是使用枚举定义整数列表类型的示例："

#: ../../language/fundamentals.md:977
msgid ""
"enum List {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of "
"the list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, List)\n"
"}\n"
msgstr ""
"enum List {\n"
"  Nil\n"
"  // 构造函数 `Cons` 携带额外的数据：列表的第一个元素，\n"
"  // 和列表的其余部分\n"
"  Cons(Int, List)\n"
"}\n"

#: ../../language/fundamentals.md:983
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 除了将额外数据绑定到变量之外，\n"
"// 你还可以继续匹配构造函数内部的额外数据。\n"
"// 以下是一个函数，用于判断列表是否只包含一个元素\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // 此分支仅匹配形状为 `Cons(_, Nil)` 的值，\n"
"    // 即长度为 1 的列表\n"
"    Cons(_, Nil) => true\n"
"    // 使用 `_` 匹配其他所有情况\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // 在模式匹配带有额外数据的枚举时，\n"
"  // 除了决定值属于哪种情况\n"
"  // 你还可以提取该情况内部的额外数据\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // 这里 `x` 和 `xs` 定义了新变量\n"
"    // 而不是引用现有变量，\n"
"    // 如果 `l` 是一个 `Cons`，那么 `Cons` 的额外数据\n"
"    // （第一个元素和列表的其余部分）\n"
"    // 将绑定到 `x` 和 `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:990
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""
"fn main {\n"
"  // 使用 `Cons` 创建值时，必须提供 `Cons` 的额外数据\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"

#: ../../language/fundamentals.md:998
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/fundamentals.md:1002
msgid "Constructor with labelled arguments"
msgstr "构造器与带标签参数"

#: ../../language/fundamentals.md:1004
msgid "Enum constructors can have labelled argument:"
msgstr "枚举构造器可以有带标签的参数："

#: ../../language/fundamentals.md:1006
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""
"enum E {\n"
"  // `x` 和 `y` 是有标签参数\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"

#: ../../language/fundamentals.md:1012
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""
"// 使用有标签参数的构造函数进行模式匹配\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` 是 `x=x` 的缩写\n"
"    // 未匹配的有标签参数可以通过 `..` 省略\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1019
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1027
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/fundamentals.md:1031
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr "也可以像在模式匹配中访问结构体字段一样访问构造函数的有标签参数："

#: ../../language/fundamentals.md:1033
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc."
"\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // 对于通过 `Point(..) as p` 定义的变量，\n"
"    // 编译器知道它必须是构造函数 `Point`，\n"
"    // 因此可以通过 `p.x`、`p.y` 等直接访问 `Point` 的字段。\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
"\n"

#: ../../language/fundamentals.md:1039
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with!(p2))\n"
"    println(p1.distance_with!(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1047
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/fundamentals.md:1051
msgid "Constructor with mutable fields"
msgstr "构造器与可变字段"

#: ../../language/fundamentals.md:1053
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr "也可以为构造器定义可变字段。这对于定义命令式数据结构特别有用："

#: ../../language/fundamentals.md:1055
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree"
"\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""
"// 使用可变二叉搜索树实现的集合。\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// 带有亲指针的可变二叉搜索树\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // 只有带标签的参数可以是可变的\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// 将一个新元素插入到二叉搜索树中。\n"
"// 返回新的树\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // 修改构造器的字段\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // 在这里创建的 `node` 和 `node.left` 之间的循环\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // 树不为空，所以新的树就是原来的树\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"

#: ../../language/fundamentals.md:1061
msgid "Newtype"
msgstr "Newtype"

#: ../../language/fundamentals.md:1063
msgid "MoonBit supports a special kind of enum called newtype:"
msgstr "MoonBit 支持一种特殊的枚举称为 newtype："

#: ../../language/fundamentals.md:1065
msgid ""
"// `UserId` is a fresh new type different from `Int`, \n"
"// and you can define new methods for `UserId`, etc.\n"
"// But at the same time, the internal representation of `UserId` \n"
"// is exactly the same as `Int`\n"
"type UserId Int\n"
"\n"
"type UserName String\n"
msgstr ""
"// `UserId` 是一个与 `Int` 不同的全新类型，\n"
"// 你可以为 `UserId` 定义新方法等。\n"
"// 但与此同时，`UserId` 的内部表示\n"
"// 与 `Int` 完全相同\n"
"type UserId Int\n"
"\n"
"type UserName String\n"

#: ../../language/fundamentals.md:1071
msgid ""
"Newtypes are similar to enums with only one constructor (with the same "
"name as the newtype itself). So, you can use the constructor to create "
"values of newtype, or use pattern matching to extract the underlying "
"representation of a newtype:"
msgstr ""
"Newtype 类似于只有一个构造函数的枚举（与 newtype 本身的名称相同）。因此，可以使用构造函数创建 newtype "
"的值，或使用模式匹配提取 newtype 的底层表示："

#: ../../language/fundamentals.md:1073
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserName = UserName(\"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserName(uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1081
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/fundamentals.md:1085
msgid ""
"Besides pattern matching, you can also use `._` to extract the internal "
"representation of newtypes:"
msgstr "除了模式匹配，还可以使用 `._` 提取 newtype 的内部表示："

#: ../../language/fundamentals.md:1087
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let uid : Int = id._\n"
"  println(uid)\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1095
msgid "1\n"
msgstr ""

#: ../../language/fundamentals.md:1099
msgid "Type alias"
msgstr "类型别名"

#: ../../language/fundamentals.md:1100
msgid "MoonBit supports type alias via the syntax `typealias Name = TargetType`:"
msgstr "MoonBit 支持使用语法 `typealias Name = TargetType` 定义类型别名："

#: ../../language/fundamentals.md:1102
msgid ""
"pub typealias Index = Int\n"
"\n"
"// type alias are private by default\n"
"typealias MapString[X] = Map[String, X]\n"
msgstr ""
"pub typealias Index = Int\n"
"\n"
"// 类型别名默认为私有\n"
"typealias MapString[X] = Map[String, X]\n"

#: ../../language/fundamentals.md:1108
msgid ""
"Unlike all other kinds of type declaration above, type alias does not "
"define a new type, it is merely a type macro that behaves exactly the "
"same as its definition. So for example one cannot define new methods or "
"implement traits for a type alias."
msgstr "与上面所有其他类型声明不同，类型别名不定义新类型，它只是一个行为与其定义完全相同的类型宏。因此，例如，不能为类型别名定义新方法或实现特征。"

#: ../../language/fundamentals.md:1113
msgid "Type alias can be used to perform incremental code refactor."
msgstr "类型别名可用于执行增量代码重构。"

#: ../../language/fundamentals.md:1115
msgid ""
"For example, if you want to move a type `T` from `@pkgA` to `@pkgB`, you "
"can leave a type alias `typealias T = @pkgB.T` in `@pkgA`, and "
"**incrementally** port uses of `@pkgA.T` to `@pkgB.T`. The type alias can"
" be removed after all uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr ""
"例如，如果要将类型 `T` 从 `@pkgA` 移动到 `@pkgB`，可以在 `@pkgA` 中留下一个类型别名 `typealias T = "
"@pkgB.T`，"

#: ../../language/fundamentals.md:1120
msgid "Local types"
msgstr "本地类型"

#: ../../language/fundamentals.md:1122
msgid ""
"Moonbit supports declaring structs/enums/newtypes at the top of a "
"toplevel function, which are only visible within the current toplevel "
"function. These local types can use the generic parameters of the "
"toplevel function but cannot introduce additional generic parameters "
"themselves. Local types can derive methods using derive, but no "
"additional methods can be defined manually. For  example:"
msgstr ""
"Moonbit "
"支持在顶层函数的顶部声明结构体/枚举/newtype，这些类型仅在当前顶层函数中可见。这些本地类型可以使用顶层函数的泛型参数，但不能引入额外的泛型参数。本地类型可以使用"
" derive 派生方法，但不能手动定义额外的方法。例如："

#: ../../language/fundamentals.md:1129
msgid ""
"fn toplevel[T: Show](x: T) -> Unit {\n"
"  enum LocalEnum {\n"
"    A(T)\n"
"    B(Int)\n"
"  } derive(Show)\n"
"  struct LocalStruct {\n"
"    a: (String, T)\n"
"  } derive(Show)\n"
"  type LocalNewtype T derive(Show)\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1135
msgid "Currently, local types do not support being declared as error types."
msgstr "目前，本地类型不支持声明为错误类型。"

#: ../../language/fundamentals.md:1137
msgid "Pattern Matching"
msgstr "模式匹配"

#: ../../language/fundamentals.md:1139
msgid ""
"Pattern matching allows us to match on specific pattern and bind data "
"from data structures."
msgstr "模式匹配允许我们匹配特定模式并从数据结构中绑定数据。"

#: ../../language/fundamentals.md:1141
msgid "Simple Patterns"
msgstr "简单模式"

#: ../../language/fundamentals.md:1143
msgid "We can pattern match expressions against"
msgstr "我们可以将表达式与以下内容进行模式匹配："

#: ../../language/fundamentals.md:1145
msgid "literals, such as boolean values, numbers, chars, strings, etc"
msgstr "字面量，例如布尔值、数字、字符、字符串等"

#: ../../language/fundamentals.md:1146
msgid "constants"
msgstr "常量"

#: ../../language/fundamentals.md:1147
msgid "structs"
msgstr "结构体"

#: ../../language/fundamentals.md:1148
msgid "enums"
msgstr "枚举"

#: ../../language/fundamentals.md:1149
msgid "arrays"
msgstr "数组"

#: ../../language/fundamentals.md:1150
msgid "maps"
msgstr "键值对"

#: ../../language/fundamentals.md:1151
msgid "JSONs"
msgstr "JSON"

#: ../../language/fundamentals.md:1153
msgid ""
"and so on. We can define identifiers to bind the matched values so that "
"they can be used later."
msgstr "等等。我们可以定义标识符来绑定匹配的值，以便稍后使用。"

#: ../../language/fundamentals.md:1155
msgid ""
"const ONE = 1\n"
"\n"
"fn match_int(x : Int) -> Unit {\n"
"  match x {\n"
"    0 => println(\"zero\")\n"
"    ONE => println(\"one\")\n"
"    value => println(value)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1162
msgid ""
"We can use `_` as wildcards for the values we don't care about, and use "
"`..` to ignore remaining fields of struct or enum, or array (see [array "
"pattern](#array-pattern))."
msgstr ""
"我们可以使用 `_` 作为我们不关心的值的通配符，并使用 `..` 忽略结构体或枚举的剩余字段，或数组（参见 [数组模式](#array-"
"pattern)）。"

#: ../../language/fundamentals.md:1164
msgid ""
"struct Point3D {\n"
"  x : Int\n"
"  y : Int\n"
"  z : Int\n"
"}\n"
"\n"
"fn match_point3D(p : Point3D) -> Unit {\n"
"  match p {\n"
"    { x: 0, .. } => println(\"on yz-plane\")\n"
"    _ => println(\"not on yz-plane\")\n"
"  }\n"
"}\n"
"\n"
"enum Point[T] {\n"
"  Point2D(Int, Int, name~: String, payload~ : T)\n"
"}\n"
"\n"
"fn match_point[T](p : Point[T]) -> Unit {\n"
"  match p {\n"
"    //! Point2D(0, 0) => println(\"2D origin\")\n"
"    Point2D(0, 0, ..) => println(\"2D origin\")\n"
"    Point2D(_) => println(\"2D point\")\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1171
msgid ""
"We can use `as` to give a name to some pattern, and we can use `|` to "
"match several cases at once. A variable name can only be bound once in a "
"single pattern, and the same set of variables should be bound on both "
"sides of `|` patterns."
msgstr ""
"我们可以使用 `as` 为某些模式命名，可以使用 `|` 一次匹配多个情况。在单个模式中，变量名只能绑定一次，并且在 `|` "
"模式的两侧应绑定相同的变量集。"

#: ../../language/fundamentals.md:1173
msgid ""
"match expr {\n"
"  //! Add(e1, e2) | Lit(e1) => ...\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1180
msgid "Array Pattern"
msgstr "数组模式"

#: ../../language/fundamentals.md:1182
msgid ""
"For `Array`, `FixedArray` and `ArrayView`, MoonBit allows using array "
"pattern."
msgstr "对于 `Array`、`FixedArray` 和 `ArrayView`，MoonBit 允许使用数组模式。"

#: ../../language/fundamentals.md:1184
msgid "Array pattern have the following forms:"
msgstr "数组模式有以下形式："

#: ../../language/fundamentals.md:1186
msgid "`[]` : matching for an empty data structure"
msgstr "`[]`：匹配空数据结构"

#: ../../language/fundamentals.md:1187
msgid "`[pa, pb, pc]` : matching for known number of elements, 3 in this example"
msgstr "`[pa, pb, pc]`：匹配已知数量的元素，在此示例中为 3 个"

#: ../../language/fundamentals.md:1188
msgid ""
"`[pa, ..]` : matching for known number of elements, followed by unknown "
"number of elements"
msgstr "`[pa, ..]`：匹配已知数量的元素，后跟未知数量的元素"

#: ../../language/fundamentals.md:1189
msgid ""
"`[.., pa]` : matching for known number of elements, preceded by unknown "
"number of elements"
msgstr "`[.., pa]`：匹配已知数量的元素，前面是未知数量的元素"

#: ../../language/fundamentals.md:1191
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  let [a, b, ..] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  let [.., a, b] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1197
msgid "Range Pattern"
msgstr "范围模式"

#: ../../language/fundamentals.md:1198
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the"
" value falls in a specific range."
msgstr "对于内置整数类型和 `Char`，MoonBit 允许匹配值是否落在特定范围内。"

#: ../../language/fundamentals.md:1200
msgid ""
"Range patterns have the form `a..<b` or `a..=b`, where `..<` means the "
"upper bound is exclusive, and `..=` means inclusive upper bound. `a` and "
"`b` can be one of:"
msgstr ""
"范围模式的形式为 `a..<b` 或 `a..=b`，其中 `..<` 表示上限是排他的，`..=` 表示包含上限。`a` 和 `b` "
"可以是以下之一："

#: ../../language/fundamentals.md:1203
msgid "literal"
msgstr "字面量"

#: ../../language/fundamentals.md:1204
msgid "named constant declared with `const`"
msgstr "使用 `const` 声明的常量"

#: ../../language/fundamentals.md:1205
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr "`_`，表示此模式在此侧没有限制"

#: ../../language/fundamentals.md:1207
msgid "Here are some examples:"
msgstr "以下是一些示例："

#: ../../language/fundamentals.md:1209
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1216
msgid "Map Pattern"
msgstr "Map 模式"

#: ../../language/fundamentals.md:1218
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a "
"map pattern, the `key : value` syntax will match if `key` exists in the "
"map, and match the value of `key` with pattern `value`. The `key? : "
"value` syntax will match no matter `key` exists or not, and `value` will "
"be matched against `map[key]` (an optional)."
msgstr ""
"MoonBit 允许在类似 map 的数据结构上方便地进行匹配。在 map 模式内，`key : value` 语法将在 map 中存在 "
"`key` 时匹配，并将 `key` 的值与模式 `value` 匹配。`key? : value` 语法将无论 `key` "
"是否存在都匹配，`value` 将与 `map[key]`（一个可选项）匹配。"

#: ../../language/fundamentals.md:1222
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _ } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" "
"exists in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""
"match map {\n"
"  // 仅在 `map` 中存在 \"b\" 时匹配\n"
"  { \"b\": _ } => ...\n"
"  // 仅在 `map` 中不存在 \"b\" 且 \"a\" 存在于 `map` 时匹配。\n"
"  // 匹配时，将 `map` 中的 \"a\" 的值绑定到 `x`\n"
"  { \"b\"? : None, \"a\": x } => ...\n"
"  // 编译器报告缺失的情况：{ \"b\"? : None, \"a\"? : None }\n"
"}\n"

#: ../../language/fundamentals.md:1229
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V` (see [method and"
" trait](./methods.md))."
msgstr ""
"要使用 map 模式匹配数据类型 `T`，`T` 必须具有某种类型 `K` 和 `V` 的方法 `op_get(Self, K) -> "
"Option[V]`（请参见 [方法和特征](./methods.md)）。"

#: ../../language/fundamentals.md:1230
msgid "Currently, the key part of map pattern must be a literal or constant"
msgstr "目前，map 模式的键部分必须是字面量或常量"

#: ../../language/fundamentals.md:1231
msgid "Map patterns are always open: unmatched keys are silently ignored"
msgstr "Map 模式始终是开放的：未匹配的键会被静默忽略"

#: ../../language/fundamentals.md:1232
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched"
" at most once"
msgstr "Map 模式将编译为高效的代码：每个键最多只会被获取一次"

#: ../../language/fundamentals.md:1234
msgid "Json Pattern"
msgstr "Json 模式"

#: ../../language/fundamentals.md:1236
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly, together with constructors:"
msgstr "当匹配的值具有类型 `Json` 时，可以直接使用字面量模式，以及构造函数："

#: ../../language/fundamentals.md:1238
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports } => ...\n"
"  { \"version\": Number(i), \"import\": Array(imports)} => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1245
msgid "Generics"
msgstr "泛型"

#: ../../language/fundamentals.md:1247
msgid ""
"Generics are supported in top-level function and data type definitions. "
"Type parameters can be introduced within square brackets. We can rewrite "
"the aforementioned data type `List` to add a type parameter `T` to obtain"
" a generic version of lists. We can then define generic functions over "
"lists like `map` and `reduce`."
msgstr ""
"泛型在顶层函数和数据类型定义中受支持。可以在方括号内引入类型参数。我们可以重写上述数据类型 `List`，添加类型参数 `T` "
"以获得列表的通用版本。然后，我们可以定义列表上的通用函数，如 `map` 和 `reduce`。"

#: ../../language/fundamentals.md:1249
msgid ""
"enum List[T] {\n"
"  Nil\n"
"  Cons(T, List[T])\n"
"}\n"
"\n"
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1253
msgid "Special Syntax"
msgstr "特殊语法"

#: ../../language/fundamentals.md:1255
msgid "Pipe operator"
msgstr "管道运算符"

#: ../../language/fundamentals.md:1257
msgid ""
"MoonBit provides a convenient pipe operator `|>`, which can be used to "
"chain regular function calls:"
msgstr "moonbit提供了一个方便的管道运算符`|>`，可以用于链接常规函数调用："

#: ../../language/fundamentals.md:1259
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> Array::push(5) // <=> Array::push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/fundamentals.md:1266
msgid "Cascade Operator"
msgstr "级联运算符"

#: ../../language/fundamentals.md:1268
msgid ""
"The cascade operator `..` is used to perform a series of mutable "
"operations on the same value consecutively. The syntax is as follows:"
msgstr "级联运算符`..`用于连续对同一值执行一系列可变操作。 语法如下："

#: ../../language/fundamentals.md:1271
msgid "x..f()\n"
msgstr ""

#: ../../language/fundamentals.md:1278
msgid "`x..f()..g()` is equivalent to `{x.f(); x.g(); x}`."
msgstr "`x..f()..g()` 等价于 `{x.f(); x.g(); x}`。"

#: ../../language/fundamentals.md:1280
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has "
"methods like `write_string`, `write_char`, `write_object`, etc., we often"
" need to perform a series of operations on the same `StringBuilder` "
"value:"
msgstr "考虑以下情况：对于具有诸如`write_string`，`write_char`，`write_object`等方法的`StringBuilder`类型，我们经常需要对同一`StringBuilder`值执行一系列操作："

#: ../../language/fundamentals.md:1284
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1291
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed "
"to return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used"
" for consecutive operations without the need to modify the return type of"
" the methods."
msgstr ""
"为了避免重复输入`builder`，其方法通常设计为返回`self`本身，允许使用`.`运算符链接操作。 "
"为了区分不可变和可变操作，在MoonBit中，对于所有返回`Unit`的方法，可以使用级联运算符进行连续操作，而无需修改方法的返回类型。"

#: ../../language/fundamentals.md:1297
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/fundamentals.md:1304
msgid "Is Expression"
msgstr "Is 表达式"

#: ../../language/fundamentals.md:1306
msgid ""
"The `is` expression tests whether a value conforms to a specific pattern."
" It returns a `Bool` value and can be used anywhere a boolean value is "
"expected, for example:"
msgstr "`is` 表达式测试值是否符合特定模式。它返回一个 `Bool` 值，并可以在期望布尔值的任何地方使用，例如："

#: ../../language/fundamentals.md:1310
msgid ""
"fn is_none[T](x : T?) -> Bool {\n"
"  x is None\n"
"}\n"
"\n"
"fn start_with_lower_letter(s: String) -> Bool {\n"
"  s is ['a'..='z', ..]\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1317
msgid ""
"Pattern binders introduced by `is` expressions can be used in two "
"contexts:"
msgstr "通过 `is` 表达式绑定的标识符可以在两个上下文中使用："

#: ../../language/fundamentals.md:1319
msgid ""
"In boolean AND expressions (`&&`): binders introduced in the left-hand "
"expression can be used in the right-hand expression"
msgstr "在与表达式（`&&`）中：左侧表达式中绑定的标识符可以在右侧表达式中使用"

#: ../../language/fundamentals.md:1323
msgid ""
"fn f(x : Int?) -> Bool {\n"
"  x is Some(v) && v >= 0\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1330
msgid ""
"In `if` conditions and their corresponding branches: if the condition is "
"a sequence of boolean expressions `e1 && e2 && ...`, the binders "
"introduced in the `is` expression can be used in the branch of the `if` "
"expression."
msgstr ""
"在 `if` 条件及其对应的分支中：如果条件是一系列布尔表达式 `e1 && e2 && ...`，则可以在 `if` 表达式的分支中使用 "
"`is` 表达式中绑定的标识符。"

#: ../../language/fundamentals.md:1335
msgid ""
"fn g(x : Array[Int?]) -> Unit {\n"
"  if x is [v, .. rest] && v is Some(i) && i is 0..=10 {\n"
"    println(v)\n"
"    println(i)\n"
"    println(rest)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/fundamentals.md:1342
msgid "TODO syntax"
msgstr "TODO 语法"

#: ../../language/fundamentals.md:1344
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of"
" code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr "`todo`语法(`...`)是一种特殊构造，用于标记尚未实现或用于未来功能的占位符代码段。 例如："

#: ../../language/fundamentals.md:1346
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/index.md:1
msgid "MoonBit Language"
msgstr "MoonBit（月兔）编程语言"

#: ../../language/index.md:3
msgid ""
"MoonBit is an end-to-end programming language toolchain for cloud and "
"edge computing using WebAssembly. The IDE environment is available at "
"[https://try.moonbitlang.com](https://try.moonbitlang.com) without any "
"installation; it does not rely on any server either."
msgstr ""
"MoonBit是一个用于云和边缘计算的 WebAssembly 端到端编程语言工具链。无需安装即可在 "
"[https://try.moonbitlang.cn](https://try.moonbitlang.cn) 上使用 IDE "
"环境；它也不依赖任何服务器。"

#: ../../language/index.md:5
msgid "**Status and aimed timeline**"
msgstr "**状态**"

#: ../../language/index.md:7
msgid "MoonBit is currently in beta-preview. We expect to reach 1.0 in 2025."
msgstr "MoonBit 目前处于 beta-preview 阶段。我们预计在 2025 年达到 1.0 版本。"

#: ../../language/index.md:9
msgid ""
"When MoonBit reaches beta, it means any backwards-incompatible changes "
"will be seriously evaluated and MoonBit _can_ be used in production(very "
"rare compiler bugs). MoonBit is developed by a talented full time team "
"who had extensive experience in building language toolchains, so we will "
"grow much faster than the typical language ecosystem, you won't wait long"
" to use MoonBit in your production."
msgstr ""
"当 MoonBit 达到 beta 阶段后，任何不兼容的更改将受到严格评估，MoonBit "
"将可以用于生产（只有非常罕见的编译器错误）。MoonBit "
"由一支才华横溢的全职团队开发，他们在构建语言工具链方面拥有丰富的经验，因此我们将比典型的语言生态系统发展得更快，您不必等太久就可以在生产中使用 "
"MoonBit。"

#: ../../language/index.md:11
msgid "**Main advantages**"
msgstr "**主要优势**"

#: ../../language/index.md:13
msgid "Generate significantly smaller WASM output than any existing solutions."
msgstr "生成比现有解决方案明显更小的 Wasm 文件。"

#: ../../language/index.md:14
msgid "Much faster runtime performance."
msgstr "更高的运行时性能。"

#: ../../language/index.md:15
msgid "State of the art compile-time performance."
msgstr "先进的编译时性能。"

#: ../../language/index.md:16
msgid "Simple but practical, data-oriented language design."
msgstr "简单且实用的数据导向语言设计。"

#: ../../language/index.md:19
msgid "[Download this section in Markdown](path:/download/language/summary.md)"
msgstr "[下载本章节的 Markdown 版本](path:/download/language/summary.md)"

#: ../../language/introduction.md:1
msgid "Introduction"
msgstr "概述"

#: ../../language/introduction.md:3
msgid "A MoonBit program consists of top-level definitions including:"
msgstr "一个 MoonBit 程序由顶层定义组成，包括："

#: ../../language/introduction.md:5
msgid "type definitions"
msgstr "类型定义"

#: ../../language/introduction.md:6
msgid "function definitions"
msgstr "函数定义"

#: ../../language/introduction.md:7
msgid "constant definitions and variable bindings"
msgstr "常数定义和变量绑定"

#: ../../language/introduction.md:8
msgid "`init` functions, `main` function and/or `test` blocks."
msgstr "`init` 函数，`main` 函数和/或 `test` 块。"

#: ../../language/introduction.md:10
msgid "Expressions and Statements"
msgstr "表达式和语句"

#: ../../language/introduction.md:12
msgid ""
"MoonBit distinguishes between statements and expressions. In a function "
"body, only the last clause should be an expression, which serves as a "
"return value. For example:"
msgstr "MoonBit 区分语句和表达式。在函数体中，只有最后一个子句应该是一个表达式，它作为返回值。例如："

#: ../../language/introduction.md:14
msgid ""
"fn foo() -> Int {\n"
"  let x = 1\n"
"  x + 1\n"
"}\n"
"\n"
"fn bar() -> Int {\n"
"  let x = 1\n"
"  //! x + 1\n"
"  x + 2\n"
"}"
msgstr ""

#: ../../language/introduction.md:28
msgid "Expressions include:"
msgstr "表达式包括："

#: ../../language/introduction.md:30
msgid ""
"Value literals (e.g. Boolean values, numbers, characters, strings, "
"arrays, tuples, structs)"
msgstr "值字面量（例如布尔值、数字、字符、字符串、数组、元组、结构体）"

#: ../../language/introduction.md:31
msgid "Arithmetical, logical, or comparison operations"
msgstr "算术、逻辑或比较操作"

#: ../../language/introduction.md:32
msgid ""
"Accesses to array elements (e.g. `a[0]`), struct fields (e.g `r.x`), "
"tuple components (e.g. `t.0`), etc."
msgstr "访问数组元素（例如 `a[0]`），结构体字段（例如 `r.x`），元组组件（例如 `t.0`）等。"

#: ../../language/introduction.md:33
msgid "Variables and (capitalized) enum constructors"
msgstr "变量和枚举构造器"

#: ../../language/introduction.md:34
msgid "Anonymous local function definitions"
msgstr "匿名本地函数定义"

#: ../../language/introduction.md:35
msgid "`match`, `if`, `loop` expressions, etc."
msgstr "`match`，`if`，`loop` 表达式等。"

#: ../../language/introduction.md:37
msgid "Statements include:"
msgstr "语句包括："

#: ../../language/introduction.md:39
msgid "Named local function definitions"
msgstr "命名本地函数定义"

#: ../../language/introduction.md:40
msgid "Local variable bindings"
msgstr "本地变量绑定"

#: ../../language/introduction.md:41
msgid "Assignments"
msgstr "赋值"

#: ../../language/introduction.md:42
msgid "`return` statements"
msgstr "`return` 语句"

#: ../../language/introduction.md:43
msgid "Any expression whose return type is `Unit`, (e.g. `ignore`)"
msgstr "任何返回类型为 `Unit` 的表达式（例如 `ignore`）"

#: ../../language/introduction.md:45
msgid ""
"A code block can contain multiple statements and one expression, and the "
"value of the expression is the value of the code block."
msgstr "代码块可以包含多个语句和一个表达式，表达式的值是代码块的值。"

#: ../../language/introduction.md:47
msgid "Variable Binding"
msgstr "变量绑定"

#: ../../language/introduction.md:49
msgid ""
"A variable can be declared as mutable or immutable using `let mut` or "
"`let`, respectively. A mutable variable can be reassigned to a new value,"
" while an immutable one cannot."
msgstr "变量可以使用 `let mut` 或 `let` 声明为可变或不可变。可变变量可以重新赋值为新值，而不可变变量则不能。"

#: ../../language/introduction.md:51
msgid "A constant can only be declared at top level and cannot be changed."
msgstr "常量只能在顶层声明，不能更改。"

#: ../../language/introduction.md:53
msgid ""
"let zero = 0\n"
"\n"
"const ZERO = 0\n"
"\n"
"fn main {\n"
"  //! const ZERO = 0 \n"
"  let mut i = 10\n"
"  i = 20\n"
"  println(i + zero + ZERO)\n"
"}"
msgstr ""

#: ../../language/introduction.md:68
msgid "A top level variable binding"
msgstr "顶层变量绑定"

#: ../../language/introduction.md:69
msgid ""
"requires **explicit** type annotation (unless defined using literals such"
" as string, byte or numbers)"
msgstr "需要 **显式** 类型注释（除非使用字符串、字节或数字等字面量定义）"

#: ../../language/introduction.md:70
msgid "can't be mutable (use `Ref` instead)"
msgstr "不能是可变的（使用 `Ref` 代替）"

#: ../../language/introduction.md:74
msgid "Naming conventions"
msgstr "命名约定"

#: ../../language/introduction.md:76
msgid ""
"Variables, functions should start with lowercase letters `a-z` and can "
"contain letters, numbers, underscore, and other non-ascii unicode chars. "
"It is recommended to name them with snake_case."
msgstr ""
"变量、函数应以小写字母 `a-z` 开头，可以包含字母、数字、下划线和其他非 ASCII 的 Unicode 字符。建议使用 snake_case"
" 命名。"

#: ../../language/introduction.md:79
msgid ""
"Constants, types should start with uppercase letters `A-Z` and can "
"contain letters, numbers, underscore, and other non-ascii unicode chars. "
"It is recommended to name them with PascalCase or SCREAMING_SNAKE_CASE."
msgstr ""
"常量、类型应以大写字母 `A-Z` 开头，可以包含字母、数字、下划线和其他非 ASCII 的 Unicode 字符。建议使用 PascalCase"
" 或 SCREAMING_SNAKE_CASE 命名。"

#: ../../language/introduction.md:82
msgid "Program entrance"
msgstr "程序入口"

#: ../../language/introduction.md:84
msgid "`init` and `main`"
msgstr "`init` 和 `main`"

#: ../../language/introduction.md:85
msgid ""
"There is a specialized function called `init` function. The `init` "
"function is special:"
msgstr "有一个专门的函数称为 `init` 函数。`init` 函数是特殊的："

#: ../../language/introduction.md:87
msgid "It has no parameter list nor return type."
msgstr "它没有参数列表也没有返回类型。"

#: ../../language/introduction.md:88
msgid "There can be multiple `init` functions in the same package."
msgstr "同一个包中可以有多个 `init` 函数。"

#: ../../language/introduction.md:89
msgid ""
"An `init` function can't be explicitly called or referred to by other "
"functions.  Instead, all `init` functions will be implicitly called when "
"initializing a package. Therefore, `init` functions should only consist "
"of statements."
msgstr "`init` 函数不能被显式调用或被其他函数引用。相反，所有 `init` 函数将在初始化包时隐式调用。因此，`init` 函数应该只包含语句。"

#: ../../language/introduction.md:92
msgid ""
"fn init {\n"
"  let x = 1\n"
"  println(x)\n"
"}"
msgstr ""

#: ../../language/introduction.md:100
msgid ""
"There is another specialized function called `main` function. The `main` "
"function is the main entrance of the program, and it will be executed "
"after the initialization stage."
msgstr "还有另一个专门的函数称为 `main` 函数。`main` 函数是程序的主入口，它将在初始化阶段之后执行。"

#: ../../language/introduction.md:102
msgid "Same as the `init` function, it has no parameter list nor return type."
msgstr "与 `init` 函数相同，它没有参数列表也没有返回类型。"

#: ../../language/introduction.md:104
msgid ""
"fn main {\n"
"  let x = 2\n"
"  println(x)\n"
"}"
msgstr ""

#: ../../language/introduction.md:112
msgid "The previous two code snippets will print the following at runtime:"
msgstr "前两个代码片段将在运行时打印以下内容："

#: ../../language/introduction.md:114
msgid ""
"1\n"
"2\n"
msgstr ""

#: ../../language/introduction.md:119
msgid ""
"Only packages that are `main` packages can define such `main` function. "
"Check out [build system tutorial](/toolchain/moon/tutorial) for detail."
msgstr "只有 `main` 包的包才能定义这样的 `main` 函数。查看[构建系统教程](/toolchain/moon/tutorial)了解详情。"

#: ../../language/introduction.md:121
msgid "moon.pkg.json"
msgstr ""

#: ../../language/introduction.md:121
msgid ""
"{\n"
"  \"is-main\": true\n"
"}"
msgstr ""

#: ../../language/introduction.md:126
msgid "`test`"
msgstr ""

#: ../../language/introduction.md:128
msgid ""
"There's also a top-level structure called `test` block. A `test` block "
"defines inline tests, such as:"
msgstr "还有一个称为 `test` 块的顶级结构。`test` 块定义内联测试，例如："

#: ../../language/introduction.md:130 ../../language/tests.md:11
msgid ""
"test \"test_name\" {\n"
"  assert_eq!(1 + 1, 2)\n"
"  assert_eq!(2 + 2, 4)\n"
"  inspect!([1, 2, 3], content=\"[1, 2, 3]\")\n"
"}\n"
msgstr ""

#: ../../language/introduction.md:136
msgid ""
"The following contents will use `test` block and `main` function to "
"demonstrate the execution result, and we assume that all the `test` "
"blocks pass unless stated otherwise."
msgstr "以下内容将使用 `test` 块和 `main` 函数来演示执行结果。我们假设所有 `test` 块都通过测试，除非另有说明。"

#: ../../language/methods.md:1
msgid "Method and Trait"
msgstr "方法和特征"

#: ../../language/methods.md:3
msgid "Method system"
msgstr "方法系统"

#: ../../language/methods.md:5
msgid ""
"MoonBit supports methods in a different way from traditional object-"
"oriented languages. A method in MoonBit is just a toplevel function "
"associated with a type constructor. There are two ways to define a "
"method:"
msgstr "MoonBit 支持方法的方式与传统的面向对象语言不同。MoonBit 中的方法只是与类型构造器关联的顶层函数。方法可以用两种方式来定义："

#: ../../language/methods.md:8
msgid ""
"`fn method_name(self : SelfType, ..)`, where the method belongs to "
"`SelfType`. The name of the first parameter must be `self` here"
msgstr ""
"`fn method_name(self : SelfType, ..)`，如此定义的方法属于类型 `SelfType`。方法的第一个参数必须叫作"
" `self`"

#: ../../language/methods.md:9
msgid ""
"`fn SelfTypeName::method_name(...)`, where the method belongs to "
"`SelfTypeName`"
msgstr "`fn SelfTypeName::method_name(...)`，如此定义的方法属于类型 `SelfTypeName`"

#: ../../language/methods.md:11
msgid ""
"enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"fn length[X](self : List[X]) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"fn List::length_qualified[X](xs : List[X]) -> Int {\n"
"  ...\n"
"}\n"
msgstr ""
"enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"fn length[X](self : List[X]) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"fn List::length_qualified[X](xs : List[X]) -> Int {\n"
"  ...\n"
"}\n"

#: ../../language/methods.md:17
msgid ""
"The difference between these two syntax is: the syntax `fn "
"method_name(self : T, ..)` defines a regular function. So the defined "
"method can be involked directly, just like regular functions. In the `fn "
"T::method_name(..)` syntax, however, the method is defined in the small "
"namespace `T`, and must be involked using qualified syntax "
"`T::method_name(..)`:"
msgstr ""
"这两种定义方式的区别是：`fn method_name(self : T, ..)` "
"定义出的方法是一个普通的函数，因此它可以像普通函数一样直接调用。`fn T::method_name(..)` 定义出的方法处在命名空间 `T` "
"内，因此调用它时，必须使用 `T::method_name(..)` 的形式。"

#: ../../language/methods.md:23
msgid ""
"  let l : List[Int] = Nil\n"
"  println(length(l))\n"
"  println(List::length_qualified(l))\n"
msgstr ""

#: ../../language/methods.md:29
msgid ""
"Unlike regular functions, methods defined using the "
"`TypeName::method_name` syntax support overloading: different types can "
"define methods of the same name, because each method lives in a different"
" name space:"
msgstr "用 `TypeName::method_name` 形式定义出的方法支持重载：由于不同类型的方法处于不同的命名空间中，不同的类型可以定义同名的方法。"

#: ../../language/methods.md:32
msgid ""
"struct T1 {\n"
"  x1 : Int\n"
"}\n"
"\n"
"fn T1::default() -> T1 {\n"
"  { x1: 0 }\n"
"}\n"
"\n"
"struct T2 {\n"
"  x2 : Int\n"
"}\n"
"\n"
"fn T2::default() -> T2 {\n"
"  { x2: 0 }\n"
"}\n"
"\n"
"test {\n"
"  let t1 = T1::default()\n"
"  let t2 = T2::default()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:39
msgid ""
"When the first parameter of a method is also the type it belongs to, "
"methods can be called using dot syntax `x.method(...)`. MoonBit "
"automatically finds the correct method based on the type of `x`, there is"
" no need to write the type name and even the package name of the method:"
msgstr ""
"当方法的第一个参数也是它所属的类型时，可以使用点语法 `x.method(...)` 调用方法。MoonBit 根据 `x` "
"的类型自动找到正确的方法，无需编写方法的类型名称甚至包名称："

#: ../../language/methods.md:41
msgid ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn concat[X](self : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn concat[X](self : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"

#: ../../language/methods.md:47
msgid "using package with alias list"
msgstr "以别名 list 使用包"

#: ../../language/methods.md:47
msgid ""
"  // assume `xs` is a list of lists, all the following three lines are "
"equivalent\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"
msgstr ""
"  // 假设 `xs` 是一个列表的列表，那么下面三种写法是等价的：\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"

#: ../../language/methods.md:54
msgid "API design guideline"
msgstr "接口设计指南"

#: ../../language/methods.md:55
msgid ""
"Since there are two ways to define methods, and both allow dot syntax, a "
"natural question is which syntax to choose when designing the API of a "
"package. The rule here is:"
msgstr "既然有两种不同的方式来定义方法，并且两种方式都能使用 `.` 语法调用，那么在设计一个包的接口时，应该如何选择呢？MoonBit 推荐的选择是："

#: ../../language/methods.md:59
msgid ""
"if the package exports only one primary type, or if a method is "
"intuitively unambiguous in the package, use the `fn f(self : T, ..)` "
"syntax"
msgstr "如果一个包只有一个主要的公开类型，或者某个方法在这个包的语境下没有歧义，使用 `fn f(self : T, ..)` 的形式来定义方法"

#: ../../language/methods.md:62
msgid "otherwise, use the qualified `fn T::f(..)` syntax"
msgstr "否则，使用 `fn T::f(..)` 来定义方法，以显式消除歧义"

#: ../../language/methods.md:64
msgid "Operator Overloading"
msgstr "运算符重载"

#: ../../language/methods.md:66
msgid ""
"MoonBit supports operator overloading of builtin operators via methods. "
"The method name corresponding to a operator `<op>` is `op_<op>`. For "
"example:"
msgstr "MoonBit 支持通过方法对内置运算符进行运算符重载。与运算符 `<op>` 对应的方法名是 `op_<op>`。例如："

#: ../../language/methods.md:68
msgid ""
"struct T {\n"
"  x : Int\n"
"}\n"
"\n"
"fn op_add(self : T, other : T) -> T {\n"
"  { x: self.x + other.x }\n"
"}\n"
"\n"
"test {\n"
"  let a = { x: 0 }\n"
"  let b = { x: 2 }\n"
"  assert_eq!((a + b).x, 2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:74
msgid "Another example about `op_get` and `op_set`:"
msgstr "关于 `op_get` 和 `op_set` 的另一个例子："

#: ../../language/methods.md:76
msgid ""
"struct Coord {\n"
"  mut x : Int\n"
"  mut y : Int\n"
"} derive(Show)\n"
"\n"
"fn op_get(self : Coord, key : String) -> Int {\n"
"  match key {\n"
"    \"x\" => self.x\n"
"    \"y\" => self.y\n"
"  }\n"
"}\n"
"\n"
"fn op_set(self : Coord, key : String, val : Int) -> Unit {\n"
"  match key {\n"
"    \"x\" => self.x = val\n"
"    \"y\" => self.y = val\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/methods.md:82
msgid ""
"fn main {\n"
"  let c = { x: 1, y: 2 }\n"
"  println(c)\n"
"  println(c[\"y\"])\n"
"  c[\"x\"] = 23\n"
"  println(c)\n"
"  println(c[\"x\"])\n"
"}\n"
msgstr ""

#: ../../language/methods.md:90
msgid ""
"{x: 1, y: 2}\n"
"2\n"
"{x: 23, y: 2}\n"
"23\n"
msgstr ""

#: ../../language/methods.md:94
msgid "Currently, the following operators can be overloaded:"
msgstr "目前，可以重载以下运算符："

#: ../../language/methods.md:90
msgid "Operator Name"
msgstr "运算符名称"

#: ../../language/methods.md:90
msgid "`=`"
msgstr ""

#: ../../language/methods.md:90
msgid "`_[_]` (get item)"
msgstr "`_[_]`（获取项）"

#: ../../language/methods.md:90
msgid "`_[_] = _` (set item)"
msgstr "`_[_] = _`（设置项）"

#: ../../language/methods.md:90
msgid "`_[_:_]` (view)"
msgstr "`_[_:_]`（视图）"

#: ../../language/methods.md:114
msgid ""
"By implementing `op_as_view` method, you can create a view for a user-"
"defined type. Here is an example:"
msgstr "通过实现 `op_as_view` 方法，可以为用户定义的类型创建视图。以下是一个例子："

#: ../../language/methods.md:116
msgid ""
"type DataView String\n"
"\n"
"struct Data {}\n"
"\n"
"fn Data::op_as_view(_self : Data, start~ : Int = 0, end? : Int) -> "
"DataView {\n"
"  \"[\\{start}, \\{end.or(100)})\"\n"
"}\n"
"\n"
"test {\n"
"  let data = Data::{  }\n"
"  inspect!(data[:]._, content=\"[0, 100)\")\n"
"  inspect!(data[2:]._, content=\"[2, 100)\")\n"
"  inspect!(data[:5]._, content=\"[0, 5)\")\n"
"  inspect!(data[2:5]._, content=\"[2, 5)\")\n"
"}\n"
msgstr ""

#: ../../language/methods.md:122
msgid "Trait system"
msgstr "Trait（特征）系统"

#: ../../language/methods.md:124
msgid ""
"MoonBit features a structural trait system for overloading/ad-hoc "
"polymorphism. Traits declare a list of operations, which must be supplied"
" when a type wants to implement the trait. Traits can be declared as "
"follows:"
msgstr "MoonBit 具有用于重载/特殊多态的结构特征系统。特征声明一系列操作，当类型想要实现特征时，必须提供这些操作。特征可以如下声明："

#: ../../language/methods.md:126
msgid ""
"trait I {\n"
"  method_(Int) -> Int\n"
"  method_with_label(Int, label~: Int) -> Int\n"
"  //! method_with_label(Int, label?: Int) -> Int\n"
"}\n"
msgstr ""

#: ../../language/methods.md:132
msgid ""
"In the body of a trait definition, a special type `Self` is used to refer"
" to the type that implements the trait."
msgstr "在特征定义的主体中，使用特殊类型 `Self` 来引用实现特征的类型。"

#: ../../language/methods.md:134
msgid "Extending traits"
msgstr "扩展特征"

#: ../../language/methods.md:136
msgid "A trait can depend on other traits, for example:"
msgstr "特征（子特征）可以依赖于其他特征（超特征），例如："

#: ../../language/methods.md:138
msgid ""
"trait Position {\n"
"  pos(Self) -> (Int, Int)\n"
"}\n"
"trait Draw {\n"
"  draw(Self) -> Unit\n"
"}\n"
"\n"
"trait Object : Position + Draw {}\n"
msgstr ""

#: ../../language/methods.md:144
msgid ""
"To implement the sub trait, one will have to implement the super traits,"
"  and the methods defined in the sub trait."
msgstr "要实现子特征，必须实现子特征和所有超特征中定义的方法。"

#: ../../language/methods.md:147
msgid "Implementing traits"
msgstr "实现特征"

#: ../../language/methods.md:149
msgid ""
"To implement a trait, a type must provide all the methods required by the"
" trait."
msgstr "要实现特征，类型必须提供特征所需的所有方法。"

#: ../../language/methods.md:151
msgid ""
"This allows types to implement a trait implicitly, hence allowing "
"different packages to work together without seeing or depending on each "
"other. For example, the following trait is automatically implemented for "
"builtin number types such as `Int` and `Double`:"
msgstr ""
"这使得类型可以隐式满足特征，从而允许不同的包在不看到或依赖于彼此的情况下运行。例如，内置数字类型（如 `Int` 和 "
"`Double`）自动满足了以下的特征："

#: ../../language/methods.md:154
msgid ""
"trait Number {\n"
"  op_add(Self, Self) -> Self\n"
"  op_mul(Self, Self) -> Self\n"
"}\n"
msgstr ""

#: ../../language/methods.md:160
msgid ""
"**Explicit implementation** for trait methods can be provided via the "
"syntax `impl Trait for Type with method_name(...) { ... }`, for example:"
msgstr ""
"**显式实现**特征方法可以通过语法 `impl Trait for Type with method_name(...) { ... }` "
"提供，例如："

#: ../../language/methods.md:162
msgid ""
"trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// trait implementation with type parameters.\n"
"// `[X : Show]` means the type parameter `X` must implement `Show`,\n"
"// this will be covered later.\n"
"impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"
msgstr ""
"trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// 使用类型参数实现特征。\n"
"// `[X : Show]` 意味着类型参数 `X` 必须实现 `Show`，\n"
"// 我们将稍后介绍。\n"
"impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"

#: ../../language/methods.md:168
msgid ""
"Type annotation can be omitted for trait `impl`: MoonBit will "
"automatically infer the type based on the signature of `Trait::method` "
"and the self type."
msgstr "`impl` 实现的类型注释可以省略：MoonBit 将根据 `Trait::method` 的签名和 self 类型自动推断类型。"

#: ../../language/methods.md:170
msgid ""
"The author of the trait can also define **default implementations** for "
"some methods in the trait, for example:"
msgstr "特征的作者还可以为特征中的某些方法定义**默认实现**，例如："

#: ../../language/methods.md:172
msgid ""
"trait J {\n"
"  f(Self) -> Unit\n"
"  f_twice(Self) -> Unit\n"
"}\n"
"\n"
"impl J with f_twice(self) {\n"
"  self.f()\n"
"  self.f()\n"
"}\n"
msgstr ""

#: ../../language/methods.md:178
msgid ""
"Implementers of trait `I` don't have to provide an implementation for "
"`f_twice`: to implement `I`, only `f` is necessary. They can always "
"override the default implementation with an explicit `impl I for Type "
"with f_twice`, if desired, though."
msgstr ""
" `I` 的类型实现特征时不必为 `f_twice` 提供实现：要实现 `I`，只有 `f` 是必要的。如果需要，他们总是可以显式地用 `impl"
" I for Type with f_twice` 覆盖默认实现。"

#: ../../language/methods.md:181
msgid ""
"If an explicit `impl` or default implementation is not found, trait "
"method resolution falls back to regular methods."
msgstr "如果找不到显式的 `impl` 或默认实现，特征方法解析将回退到常规方法。"

#: ../../language/methods.md:183
msgid "Using traits"
msgstr "使用特征"

#: ../../language/methods.md:185
msgid ""
"When declaring a generic function, the type parameters can be annotated "
"with the traits they should implement, allowing the definition of "
"constrained generic functions. For example:"
msgstr "在声明泛型函数时，可以使用特征注释类型参数，来定义受约束的泛型函数。例如："

#: ../../language/methods.md:187
msgid ""
"fn square[N : Number](x : N) -> N {\n"
"  x * x // <=> x.op_mul(x)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:193
msgid ""
"Without the `Number` requirement, the expression `x * x` in `square` will"
" result in a method/operator not found error. Now, the function `square` "
"can be called with any type that implements `Number`, for example:"
msgstr ""
"如果没有 `Number` 要求，`square` 中的表达式 `x * x` 将产生方法/运算符未找到的错误。现在，函数 `square` "
"可以使用任何实现 `Number` 的类型调用，例如："

#: ../../language/methods.md:195
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Show)\n"
"\n"
"impl Number for Point with op_add(self, other) {\n"
"  { x: self.x + other.x, y: self.y + other.y }\n"
"}\n"
"\n"
"impl Number for Point with op_mul(self, other) {\n"
"  { x: self.x * other.x, y: self.y * other.y }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(square(2), 4)\n"
"  assert_eq!(square(1.5), 2.25)\n"
"  assert_eq!(square(Point::{ x: 2, y: 3 }), { x: 4, y: 9 })\n"
"}\n"
msgstr ""

#: ../../language/methods.md:201
msgid "Invoke trait methods directly"
msgstr "直接调用特征方法"

#: ../../language/methods.md:203
msgid ""
"Methods of a trait can be called directly via `Trait::method`. MoonBit "
"will infer the type of `Self` and check if `Self` indeed implements "
"`Trait`, for example:"
msgstr ""
"可以通过 `Trait::method` 直接调用特征的方法。MoonBit 将推断 `Self` 的类型，并检查 `Self` 是否确实实现了 "
"`Trait`，例如："

#: ../../language/methods.md:205
msgid ""
"test {\n"
"  assert_eq!(Show::to_string(42), \"42\")\n"
"  assert_eq!(Compare::compare(1.0, 2.5), -1)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:211
msgid ""
"Trait implementations can also be invoked via dot syntax, with the "
"following restrictions:"
msgstr "特征实现也可以通过点语法调用，但有以下限制："

#: ../../language/methods.md:213
msgid ""
"if a regular method is present, the regular method is always favored when"
" using dot syntax"
msgstr "如果存在常规方法，使用点语法时总是优先选择常规方法"

#: ../../language/methods.md:214
msgid ""
"only trait implementations that are located in the package of the self "
"type can be invoked via dot syntax"
msgstr "只有位于 self 类型的包中的特征实现才能通过点语法调用"

#: ../../language/methods.md:215
msgid ""
"if there are multiple trait methods (from different traits) with the same"
" name available, an ambiguity error is reported"
msgstr "如果有多个具有相同名称的特征方法（来自不同的特征）可用，将报告歧义错误"

#: ../../language/methods.md:216
msgid ""
"if neither of the above two rules apply, trait `impl`s in current package"
" will also be searched for dot syntax. This allows extending a foreign "
"type locally."
msgstr "如果上述两条规则都不适用，还将在当前包中搜索特征 `impl` 以进行点语法。这允许在本地扩展外部类型。"

#: ../../language/methods.md:218
msgid ""
"these `impl`s can only be called via dot syntax locally, even if they are"
" public."
msgstr "这些 `impl` 只能在本地通过点语法调用，即使它们是公共的。"

#: ../../language/methods.md:220
msgid ""
"The above rules ensures that MoonBit's dot syntax enjoys good property "
"while being flexible. For example, adding a new dependency never break "
"existing code with dot syntax due to ambiguity. These rules also make "
"name resolution of MoonBit extremely simple: the method called via dot "
"syntax must always come from current package or the package of the type!"
msgstr ""
"上述规则确保了 MoonBit 的点语法具有良好的特性，同时也具有灵活性。例如，由于歧义，添加新依赖关系永远不会破坏现有的点语法代码。这些规则还使"
" MoonBit 的名称解析非常简单：通过点语法调用的方法必须始终来自当前包或类型的包！"

#: ../../language/methods.md:225
msgid "Here's an example of calling trait `impl` with dot syntax:"
msgstr "以下是使用点语法调用特征 `impl` 的示例："

#: ../../language/methods.md:227
msgid ""
"struct MyCustomType {}\n"
"\n"
"impl Show for MyCustomType with output(self, logger) { ... }\n"
"\n"
"fn f() -> Unit {\n"
"  let x = MyCustomType::{  }\n"
"  let _ = x.to_string()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/methods.md:233
msgid "Trait objects"
msgstr "特征对象"

#: ../../language/methods.md:235
msgid ""
"MoonBit supports runtime polymorphism via trait objects. If `t` is of "
"type `T`, which implements trait `I`, one can pack the methods of `T` "
"that implements `I`, together with `t`, into a runtime object via `t as "
"&I`. Trait object erases the concrete type of a value, so objects created"
" from different concrete types can be put in the same data structure and "
"handled uniformly:"
msgstr ""
"MoonBit 支持通过特征对象实现运行时多态。如果 `t` 是类型 `T`，它实现了特征 `I`，可以通过 `t as &I` 将实现 `I` "
"的 `T` 的方法与 `t` 一起打包到运行时对象中。特征对象擦除了值的具体类型，因此可以将从不同具体类型创建的对象放入相同的数据结构并统一处理："

#: ../../language/methods.md:242
msgid ""
"trait Animal {\n"
"  speak(Self) -> String\n"
"}\n"
"\n"
"type Duck String\n"
"\n"
"fn Duck::make(name : String) -> Duck {\n"
"  Duck(name)\n"
"}\n"
"\n"
"fn speak(self : Duck) -> String {\n"
"  \"\\{self._}: quack!\"\n"
"}\n"
"\n"
"type Fox String\n"
"\n"
"fn Fox::make(name : String) -> Fox {\n"
"  Fox(name)\n"
"}\n"
"\n"
"fn Fox::speak(_self : Fox) -> String {\n"
"  \"What does the fox say?\"\n"
"}\n"
"\n"
"test {\n"
"  let duck1 = Duck::make(\"duck1\")\n"
"  let duck2 = Duck::make(\"duck2\")\n"
"  let fox1 = Fox::make(\"fox1\")\n"
"  let animals : Array[&Animal] = [\n"
"    duck1 as &Animal,\n"
"    duck2 as &Animal,\n"
"    fox1 as &Animal,\n"
"  ]\n"
"  inspect!(\n"
"    animals.map(fn(animal) { animal.speak() }),\n"
"    content=\n"
"      #|[\"duck1: quack!\", \"duck2: quack!\", \"What does the fox "
"say?\"]\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/methods.md:248
msgid ""
"Not all traits can be used to create objects. \"object-safe\" traits' "
"methods must satisfy the following conditions:"
msgstr "并非所有特征都可以用于创建对象。“对象安全” 特征的方法必须满足以下条件："

#: ../../language/methods.md:251
msgid "`Self` must be the first parameter of a method"
msgstr "`Self` 必须是方法的第一个参数"

#: ../../language/methods.md:252
msgid ""
"There must be only one occurrence of `Self` in the type of the method "
"(i.e. the first parameter)"
msgstr "方法的类型中只能出现一个 `Self` （即第一个参数）"

#: ../../language/methods.md:254
msgid ""
"Users can define new methods for trait objects, just like defining new "
"methods for structs and enums:"
msgstr "用户可以为特征对象定义新方法，就像为结构体和枚举定义新方法一样："

#: ../../language/methods.md:256
msgid ""
"trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// use the new method to simplify code\n"
"impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"
msgstr ""
"trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"trait CanLog {\n"
"  log(Self, &Logger) -> Unit\n"
"}\n"
"\n"
"fn &Logger::write_object[Obj : CanLog](self : &Logger, obj : Obj) -> Unit"
" {\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// 使用新的方法来简化代码\n"
"impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"

#: ../../language/methods.md:262
msgid "Builtin traits"
msgstr "内建特征"

#: ../../language/methods.md:264
msgid "MoonBit provides the following useful builtin traits:"
msgstr "MoonBit 提供了以下有用的内建特征："

#: ../../language/methods.md:268
msgid ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` for equal, `-1` for smaller, `1` for greater\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // to be implemented\n"
"  hash(Self) -> Int // has default implementation\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // to be implemented\n"
"  to_string(Self) -> String // has default implementation\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"
msgstr ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` 代表相等，`-1` 代表小于，`1` 代表大于\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash_combine(Self, Hasher) -> Unit // 待实现\n"
"  hash(Self) -> Int // 有默认实现\n"
"}\n"
"\n"
"trait Show {\n"
"  output(Self, Logger) -> Unit // 待实现\n"
"  to_string(Self) -> String // 有默认实现\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"

#: ../../language/methods.md:293
msgid "Deriving builtin traits"
msgstr "派生内建特征"

#: ../../language/methods.md:295
msgid "MoonBit can automatically derive implementations for some builtin traits:"
msgstr "MoonBit 可以自动为一些内建特征派生实现："

#: ../../language/methods.md:297
msgid ""
"struct T {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare, Show, Default)\n"
"\n"
"test {\n"
"  let t1 = T::default()\n"
"  let t2 = T::{ x: 1, y: 1 }\n"
"  inspect!(t1, content=\"{x: 0, y: 0}\")\n"
"  inspect!(t2, content=\"{x: 1, y: 1}\")\n"
"  assert_not_eq!(t1, t2)\n"
"  assert_true!(t1 < t2)\n"
"}\n"
msgstr ""

#: ../../language/methods.md:303
msgid "See [Deriving](./derive.md) for more information about deriving traits."
msgstr "参见 [派生](./derive.md) 了解有关派生特征的更多信息。"

#: ../../language/packages.md:1
msgid "Managing Projects with Packages"
msgstr "使用包管理项目"

#: ../../language/packages.md:3
msgid ""
"When developing projects at large scale, the project usually needs to be "
"divided into smaller modular unit that depends on each other.  More "
"often, it involves using other people's work: most noticeably is the "
"[core](https://github.com/moonbitlang/core), the standard library of "
"MoonBit."
msgstr ""
"在大规模开发项目时，项目通常需要分解为相互依赖的较小模块单元。更常见的是使用其他人的工作：最典型的是 "
"[core](https://github.com/moonbitlang/core)，MoonBit 的标准库。"

#: ../../language/packages.md:6
msgid "Packages and modules"
msgstr "包和模块"

#: ../../language/packages.md:8
msgid ""
"In MoonBit, the most important unit for code organization is a package, "
"which consists of a number of source code files and a single "
"`moon.pkg.json` configuration file. A package can either be a `main` "
"package, consisting a `main` function, or a package that serves as a "
"library."
msgstr ""
"在 MoonBit 中，代码组织的最重要单元是包，它由多个源代码文件和一个单独的 `moon.pkg.json` 配置文件组成。包可以是一个 "
"`main` 包，包含一个 `main` 函数，或者是一个用作库的包。"

#: ../../language/packages.md:11
msgid ""
"A project, corresponding to a module, consists of multiple packages and a"
" single `moon.mod.json` configuration file."
msgstr "一个项目对应一个模块，由多个包和一个单独的 `moon.mod.json` 配置文件组成。"

#: ../../language/packages.md:13
msgid ""
"When using things from another package, the dependency between modules "
"should first be declared inside the `moon.mod.json`. The dependency "
"between packages should then be declared inside the `moon.pkg.json`. Then"
" it is possible to use `@pkg` to access the imported entities, where "
"`pkg` is the last part of the imported package's path or the declared "
"alias in `moon.pkg.json`:"
msgstr ""
"在从另一个包中使用内容时，模块之间的依赖关系应首先在 `moon.mod.json` 中声明。然后在 `moon.pkg.json` "
"中声明包之间的依赖关系。然后可以使用 `@pkg` 访问导入的实体，其中 `pkg` 是导入包路径的最后一部分或 `moon.pkg.json` "
"中声明的别名："

#: ../../language/packages.md:17
msgid "pkgB/moon.pkg.json"
msgstr ""

#: ../../language/packages.md:17
msgid ""
"{\n"
"    \"import\": [\n"
"        \"moonbit-community/language/packages/pkgA\",\n"
"        {\n"
"            \"path\": \"moonbit-community/language/packages/pkgC\",\n"
"            \"alias\": \"c\"\n"
"        }\n"
"    ]\n"
"}"
msgstr ""

#: ../../language/packages.md:22
msgid "pkgB/top.mbt"
msgstr ""

#: ../../language/packages.md:22
msgid ""
"pub fn add1(x : Int) -> Int {\n"
"  @c.incr(@pkgA.incr(x))\n"
"}"
msgstr ""

#: ../../language/packages.md:27
msgid "Access Control"
msgstr "访问控制"

#: ../../language/packages.md:29
msgid ""
"By default, all function definitions and variable bindings are "
"_invisible_ to other packages. You can use the `pub` modifier before "
"toplevel `let`/`fn` to make them public."
msgstr "默认情况下，所有函数定义和变量绑定对其他包是 _不可见_ 的。可以在顶层 `let`/`fn` 前使用 `pub` 修饰符使其公开。"

#: ../../language/packages.md:32
msgid "There are four different kinds of visibility for types in MoonBit:"
msgstr "MoonBit 中有四种不同的类型可见性："

#: ../../language/packages.md:34
msgid ""
"private type, declared with `priv`, completely invisible to the outside "
"world"
msgstr "私有类型，使用 `priv` 声明，对外部世界完全不可见"

#: ../../language/packages.md:35
msgid ""
"abstract type, which is the default visibility for types. Only the name "
"of an abstract type is visible outside, the internal representation of "
"the type is hidden"
msgstr "抽象类型，这是类型的默认可见性。只有抽象类型的名称对外部可见，类型的内部表示被隐藏"

#: ../../language/packages.md:36
msgid ""
"readonly types, declared with `pub`. The internal representation of "
"readonly types are visible outside, but users can only read the values of"
" these types from outside, construction and mutation are not allowed"
msgstr "只读类型，使用 `pub` 声明。只读类型的内部表示对外部可见，但用户只能从外部读取这些类型的值，不允许构造和修改"

#: ../../language/packages.md:38
msgid ""
"fully public types, declared with `pub(all)`. The outside world can "
"freely construct, modify and read values of these types"
msgstr "完全公开类型，使用 `pub(all)` 声明。外部世界可以自由构造、修改和读取这些类型的值"

#: ../../language/packages.md:40
msgid ""
"In addition to the visibility of the type itself, the fields of a public "
"`struct` can be annotated with `priv`, which will hide the field from the"
" outside world completely. Note that `struct`s with private fields cannot"
" be constructed directly outside, but you can update the public fields "
"using the functional struct update syntax."
msgstr ""
"除了类型本身的可见性外，公开的结构体的字段可以用 `priv` 注释，这将完全隐藏字段对外部世界。请注意，具有私有字段的 `struct` "
"不能直接在外部构造，但可以使用函数式 `struct` 更新语法更新公共字段。"

#: ../../language/packages.md:45
msgid ""
"Readonly types is a very useful feature, inspired by [private "
"types](https://v2.ocaml.org/manual/privatetypes.html) in OCaml. In short,"
" values of `pub` types can be destructed by pattern matching and the dot "
"syntax, but cannot be constructed or mutated in other packages. Note that"
" there is no restriction within the same package where `pub` types are "
"defined."
msgstr ""
"只读类型是一个非常有用的功能，受到 OCaml 中 "
"[私有类型](https://v2.ocaml.org/manual/privatetypes.html) 的启发。简而言之，`pub` "
"类型的值可以通过模式匹配和点语法解构，但不能在其他包中构造或修改。请注意，在定义 `pub` 类型的同一包中没有限制。"

#: ../../language/packages.md:49
msgid ""
"// Package A\n"
"pub struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // OK\n"
"  let r = { ..r, field: 8 }  // OK\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // OK\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public"
" read-only type RO!\n"
"  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only "
"field!\n"
"}\n"
msgstr ""
"// Package A\n"
"pub struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // 可以\n"
"  let r = { ..r, field: 8 }  // 可以\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // 可以\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // 错误：不能创建公共只读类型 RO 的值！\n"
"  let r = { ..r, field: 8 }  // 错误：不能修改公共只读字段！\n"
"}\n"

#: ../../language/packages.md:71
msgid ""
"Access control in MoonBit adheres to the principle that a `pub` type, "
"function, or variable cannot be defined in terms of a private type. This "
"is because the private type may not be accessible everywhere that the "
"`pub` entity is used. MoonBit incorporates sanity checks to prevent the "
"occurrence of use cases that violate this principle."
msgstr ""
"MoonBit "
"中的访问控制遵循一个原则，即公开的类型、函数或变量不能以私有类型定义。这是因为私有类型可能无法在使用公开的实体的所有地方访问。MoonBit "
"包含了健全性检查，以防止违反这一原则的用例发生。"

#: ../../language/packages.md:74
msgid ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // OK\n"
"  y: T2  // OK\n"
"  z: T3  // ERROR: public field has private type `T3`!\n"
"}\n"
"\n"
"// ERROR: public function has private parameter type `T3`!\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// ERROR: public function has private return type `T3`!\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// OK\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // ERROR: public variable has private type `T3`!\n"
msgstr ""
"pub(all) type T1\n"
"pub(all) type T2\n"
"priv type T3\n"
"\n"
"pub(all) struct S {\n"
"  x: T1  // 可以\n"
"  y: T2  // 可以\n"
"  z: T3  // 错误：公开字段使用了私有类型 `T3`！\n"
"}\n"
"\n"
"// 错误：公开函数使用了私有类型 `T3`！\n"
"pub fn f1(_x: T3) -> T1 { ... }\n"
"// 错误：公开函数的返回值使用了私有类型 `T3`！\n"
"pub fn f2(_x: T1) -> T3 { ... }\n"
"// 可以\n"
"pub fn f3(_x: T1) -> T1 { ... }\n"
"\n"
"pub let a: T3 = { ... } // 错误：公开变量的类型是私有类型 `T3`！\n"

#: ../../language/packages.md:95
msgid "Access control of methods and trait implementations"
msgstr "方法和特征实现的访问控制"

#: ../../language/packages.md:97
msgid ""
"To make the trait system coherent (i.e. there is a globally unique "
"implementation for every `Type: Trait` pair), and prevent third-party "
"packages from modifying behavior of existing programs by accident, "
"MoonBit employs the following restrictions on who can define "
"methods/implement traits for types:"
msgstr ""
"为了使特征系统一致（即每个 `Type: Trait` 对都有全局唯一的实现），并防止第三方包意外地修改现有程序的行为，MoonBit "
"对谁可以定义方法/实现类型的特征采用了以下限制："

#: ../../language/packages.md:101
msgid ""
"_only the package that defines a type can define methods for it_. So one "
"cannot define new methods or override old methods for builtin and foreign"
" types."
msgstr "**只有定义类型的包才能为其定义方法**。因此，不能为内建和外部类型定义新方法或覆盖旧方法。"

#: ../../language/packages.md:102
msgid ""
"_only the package of the type or the package of the trait can define an "
"implementation_. For example, only `@pkg1` and `@pkg2` are allowed to "
"write `impl @pkg1.Trait for @pkg2.Type`."
msgstr ""
"**只有类型的包或特征的包才能定义实现**。例如，只有 `@pkg1` 和 `@pkg2` 允许编写 `impl @pkg1.Trait for "
"@pkg2.Type`。"

#: ../../language/packages.md:105
msgid ""
"The second rule above allows one to add new functionality to a foreign "
"type by defining a new trait and implementing it. This makes MoonBit's "
"trait & method system flexible while enjoying good coherence property."
msgstr "上述第二条规则允许通过定义新特征并实现它来为外部类型添加新功能。这使 MoonBit 的特征和方法系统灵活，同时享有良好的一致性属性。"

#: ../../language/packages.md:108
msgid "Visibility of traits and sealed traits"
msgstr "特征的可见性和封闭特征"

#: ../../language/packages.md:109
msgid ""
"There are four visibility for traits, just like `struct` and `enum`: "
"private, abstract, readonly and fully public. Private traits are declared"
" with `priv trait`, and they are completely invisible from outside. "
"Abstract trait is the default visibility. Only the name of the trait is "
"visible from outside, and the methods in the trait are not exposed. "
"Readonly traits are declared with `pub trait`, their methods can be "
"involked from outside, but only the current package can add new "
"implementation for readonly traits. Finally, fully public traits are "
"declared with `pub(open) trait`, they are open to new implementations "
"outside current package, and their methods can be freely used."
msgstr ""
"特征有四种可见性，就像 `struct` 和 `enum`：私有、抽象、只读和完全公开。私有特征使用 `priv trait` "
"声明，对外部完全不可见。抽象特征是默认可见性：只有特征的名称对外部可见，特征中的方法不会暴露。只读特征使用 `pub trait` "
"声明，它们的方法可以从外部调用，但只有当前包可以为只读特征添加新实现。最后，完全公开特征使用 `pub(open) trait` "
"声明，它们对外部新实现是开放的，它们的方法可以自由使用。"

#: ../../language/packages.md:115
msgid ""
"Abstract and readonly traits are sealed, because only the package "
"defining the trait can implement them. Implementing a sealed (abstract or"
" readonly) trait outside its package result in compiler error. If you are"
" the owner of a sealed trait, and you want to make some implementation "
"available to users of your package, make sure there is at least one "
"declaration of the form `impl Trait for Type with ...` in your package. "
"Implementations with only regular method and default implementations will"
" not be available outside."
msgstr "抽象和只读特征是封闭的，因为只有定义特征的包才能实现它们。在其包外实现封闭（抽象或只读）特征会导致编译器错误。"

#: ../../language/packages.md:121
msgid "Here's an example of abstract trait:"
msgstr "以下是抽象特征的示例："

#: ../../language/packages.md:124
msgid ""
"trait Number {\n"
" op_add(Self, Self) -> Self\n"
" op_sub(Self, Self) -> Self\n"
"}\n"
"\n"
"fn add[N : Number](x : N, y: N) -> N {\n"
"  Number::op_add(x, y)\n"
"}\n"
"\n"
"fn sub[N : Number](x : N, y: N) -> N {\n"
"  Number::op_sub(x, y)\n"
"}\n"
"\n"
"impl Number for Int with op_add(x, y) { x + y }\n"
"impl Number for Int with op_sub(x, y) { x - y }\n"
"\n"
"impl Number for Double with op_add(x, y) { x + y }\n"
"impl Number for Double with op_sub(x, y) { x - y }\n"
msgstr ""

#: ../../language/packages.md:145
msgid "From outside this package, users can only see the following:"
msgstr "从包外，用户只能看到以下内容："

#: ../../language/packages.md:147
msgid ""
"trait Number\n"
"\n"
"fn op_add[N : Number](x : N, y : N) -> N\n"
"fn op_sub[N : Number](x : N, y : N) -> N\n"
"\n"
"impl Number for Int\n"
"impl Number for Double\n"
msgstr ""

#: ../../language/packages.md:157
msgid ""
"The author of `Number` can make use of the fact that only `Int` and "
"`Double` can ever implement `Number`, because new implementations are not"
" allowed outside."
msgstr "`Number` 的作者可以利用只有 `Int` 和 `Double` 可以实现 `Number` 这一事实，因为在外部不允许新的实现。"

#: ../../language/tests.md:1
msgid "Writing Tests"
msgstr "编写测试"

#: ../../language/tests.md:3
msgid ""
"Tests are important for improving quality and maintainability of a "
"program. They verify the behavior of a program and also serves as a "
"specification to avoid regressions over time."
msgstr "测试对于提高程序的质量和可维护性很重要。它们验证程序的行为，也作为规范，以避免随时间的推移出现退步。"

#: ../../language/tests.md:5
msgid "MoonBit comes with test support to make the writing easier and simpler."
msgstr "MoonBit 提供测试支持，使编写测试更加简单和容易。"

#: ../../language/tests.md:7
msgid "Test Blocks"
msgstr "测试块"

#: ../../language/tests.md:9
msgid ""
"MoonBit provides the test code block for writing inline test cases. For "
"example:"
msgstr "MoonBit 提供测试代码块，用于编写内联测试用例。例如："

#: ../../language/tests.md:17
msgid ""
"A test code block is essentially a function that returns a `Unit` but may"
" throws a `String` on error, or `Unit!String` as one would see in its "
"signature at the position of return type. It is called during the "
"execution of `moon test` and outputs a test report through the build "
"system. The `assert_eq` function is from the standard library; if the "
"assertion fails, it prints an error message and terminates the test. The "
"string `\"test_name\"` is used to identify the test case and is optional."
msgstr ""
"测试代码块本质上是一个返回 `Unit` 抛出 `String` 的函数。它在执行 `moon test` "
"期间被调用，并通过构建系统输出测试报告。`assert_eq` 函数来自标准库；如果断言失败，它会打印错误消息并终止测试。字符串 "
"`\"test_name\"` 用于标识测试用例，是可选的。"

#: ../../language/tests.md:19
msgid ""
"If a test name starts with `\"panic\"`, it indicates that the expected "
"behavior of the test is to trigger a panic, and the test will only pass "
"if the panic is triggered. For example:"
msgstr "如果测试名称以 `\"panic\"` 开头，表示测试的预期行为是触发 panic，只有在触发 panic 时测试才会通过。例如："

#: ../../language/tests.md:21
msgid ""
"test \"panic_test\" {\n"
"  let _ : Int = Option::None.unwrap()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/tests.md:27
msgid "Snapshot Tests"
msgstr "快照测试"

#: ../../language/tests.md:29
msgid ""
"Writing tests can be tedious when specifying the expected values. Thus, "
"MoonBit provides three kinds of snapshot tests. All of which can be "
"inserted or updated automatically using `moon test --update`."
msgstr ""
"在指定预期值时，编写测试可能会很繁琐。因此，MoonBit 提供了三种快照测试。所有这些都可以使用 `moon test --update` "
"自动插入或更新。"

#: ../../language/tests.md:32
msgid "Snapshotting `Show`"
msgstr "快照 `Show`"

#: ../../language/tests.md:34
msgid ""
"We can use `inspect!(x, content=\"x\")` to inspect anything that "
"implements `Show` trait.  As we mentioned before, `Show` is a builtin "
"trait that can be derived, providing `to_string` that will print the "
"content of the data structures.  The labelled argument `content` can be "
"omitted as `moon test --update` will insert it for you:"
msgstr ""
"我们可以使用 `inspect!(x, content=\"x\")` 来检查实现了 `Show` "
"特征的任何内容。正如我们之前提到的，`Show` 是一个可以派生的内建特征，提供了 `to_string`来打印数据结构的内容。标记参数 "
"`content` 可以省略，因为 `moon test --update` 会自动插入："

#: ../../language/tests.md:38
msgid ""
"struct X { x : Int } derive(Show)\n"
"\n"
"test \"show snapshot test\" {\n"
"  inspect!({x: 10}, content=\"{x: 10}\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:44
msgid "Snapshotting `JSON`"
msgstr "快照 `JSON`"

#: ../../language/tests.md:46
msgid ""
"The problem with the derived `Show` trait is that it does not perform "
"pretty printing, resulting in extremely long output."
msgstr "派生的 `Show` 特征的问题是它不能对输出进行格式化，导致输出非常长。"

#: ../../language/tests.md:48
msgid ""
"The solution is to use `@json.inspect!(x, content=x)`. The benefit is "
"that the resulting content is a JSON structure, which can be more "
"readable after being formatted."
msgstr "解决方案是使用 `@json.inspect!(x, content=x)`。其好处是生成的内容是一个 JSON 结构，在格式化后更易读。"

#: ../../language/tests.md:50
msgid ""
"enum Rec {\n"
"  End\n"
"  Really_long_name_that_is_difficult_to_read(Rec)\n"
"} derive(Show, ToJson)\n"
"\n"
"test \"json snapshot test\" {\n"
"  let r = Really_long_name_that_is_difficult_to_read(\n"
"    Really_long_name_that_is_difficult_to_read(\n"
"      Really_long_name_that_is_difficult_to_read(End),\n"
"    ),\n"
"  )\n"
"  inspect!(\n"
"    r,\n"
"    "
"content=\"Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(Really_long_name_that_is_difficult_to_read(End)))\","
"\n"
"  )\n"
"  @json.inspect!(\n"
"    r,\n"
"    content={\n"
"      \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"      \"0\": {\n"
"        \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"        \"0\": {\n"
"          \"$tag\": \"Really_long_name_that_is_difficult_to_read\",\n"
"          \"0\": { \"$tag\": \"End\" },\n"
"        },\n"
"      },\n"
"    },\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/tests.md:56
msgid ""
"One can also implement a custom `ToJson` to keep only the essential "
"information."
msgstr "也可以实现自定义 `ToJson` 来保留必要的信息。"

#: ../../language/tests.md:58
msgid "Snapshotting Anything"
msgstr "快照任何内容"

#: ../../language/tests.md:60
msgid ""
"Still, sometimes we want to not only record one data structure but the "
"output of a whole process."
msgstr "有时我们不仅要记录一个数据结构，还要记录整个过程的输出。"

#: ../../language/tests.md:62
msgid ""
"A full snapshot test can be used to record anything using "
"`@test.T::write` and `@test.T::writeln`:"
msgstr "可以使用完整的快照测试使用 `@test.T::write` 和 `@test.T::writeln` 记录任何内容："

#: ../../language/tests.md:64
msgid ""
"test \"record anything\" (t : @test.T) {\n"
"  t.write(\"Hello, world!\")\n"
"  t.writeln(\" And hello, MoonBit!\")\n"
"  t.snapshot!(filename=\"record_anything.txt\")\n"
"}\n"
msgstr ""

#: ../../language/tests.md:70
msgid ""
"This will create a file under `__snapshot__` of that package with the "
"given filename:"
msgstr "这将在该包的 `__snapshot__` 下创建一个具有给定文件名的文件："

#: ../../language/tests.md:72
msgid "Hello, world! And hello, MoonBit!\n"
msgstr ""

#: ../../language/tests.md:75
msgid ""
"This can also be used for applications to test the generated output, "
"whether it were creating an image, a video or some custom data."
msgstr "这也可以用于测试应用程序的输出，无论是创建图像、视频还是一些自定义数据。"

#: ../../language/tests.md:77
msgid "BlackBox Tests and WhiteBox Tests"
msgstr "黑盒测试和白盒测试"

#: ../../language/tests.md:79
msgid ""
"When developing libraries, it is important to verify if the user can use "
"it correctly. For example, one may forget to make a type or a function "
"public. That's why MoonBit provides BlackBox tests, allowing developers "
"to have a grasp of how others are feeling."
msgstr ""
"在开发库时，验证用户是否可以正确使用它是很重要的。例如，可能会忘记使类型或函数公开。这就是为什么 MoonBit "
"提供了黑盒测试，允许开发人员了解其他人的感受。"

#: ../../language/tests.md:81
msgid ""
"A test that has access to all the members in a package is called a "
"WhiteBox tests as we can see everything. Such tests can be defined inline"
" or defined in a file whose name ends with `_wbtest.mbt`."
msgstr ""
"只能访问包中所有成员的测试称为白盒测试，因为我们可以看到一切。这样的测试可以内联定义，也可以在文件中定义，文件名以 `_wbtest.mbt` "
"结尾。"

#: ../../language/tests.md:83
msgid ""
"A test that has access only to the public members in a package is called "
"a BlackBox tests. Such tests need to be defined in a file whose name ends"
" with `_test.mbt`."
msgstr "只能访问包中公共成员的测试称为黑盒测试。这样的测试需要在文件中定义，文件名以 `_test.mbt` 结尾。"

#: ../../language/tests.md:85
msgid ""
"The WhiteBox test files (`_wbtest.mbt`) imports the packages defined in "
"the `import` and `wbtest-import` sections of the package configuration "
"(`moon.pkg.json`)."
msgstr ""
"白盒测试文件（`_wbtest.mbt`）导入包配置（`moon.pkg.json`）中的 `import` 和 `wbtest-import` "
"部分定义的包。"

#: ../../language/tests.md:87
msgid ""
"The BlackBox test files (`_test.mbt`) imports the current package and the"
" packages defined in the `import` and `test-import` sections of the "
"package configuration (`moon.pkg.json`)."
msgstr ""
"黑盒测试文件（`_test.mbt`）导入当前包和包配置（`moon.pkg.json`）中的 `import` 和 `test-import` "
"部分定义的包。"
