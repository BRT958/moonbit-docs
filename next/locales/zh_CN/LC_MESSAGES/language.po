# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit Document
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: MoonBit Document \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-12-03 16:21+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../language/error-handling.md:1
msgid "Error handling in MoonBit"
msgstr "MoonBit 中的错误处理"

#: ../../language/error-handling.md:3
msgid ""
"Error handling has always been at core of our language design. In the "
"following we'll be explaining how error handling is done in MoonBit. We "
"assume you have some prior knowledge of MoonBit, if not, please checkout "
"[A tour of MoonBit](../tutorial/tour.md)."
msgstr ""
"错误处理一直是我们语言设计的核心。接下来我们将解释 MoonBit 中的错误处理。我们假设您对 MoonBit 有一些了解，如果没有，请查看 "
"[MoonBit 之旅](../tutorial/tour.md)。"

#: ../../language/error-handling.md:7
msgid "Example: Division by Zero"
msgstr "示例：除零"

#: ../../language/error-handling.md:9
msgid ""
"We'll write a small example to demonstrate the basics of MoonBit's error "
"handling system. Consider the following `div` function which'll raise an "
"error on division by zero:"
msgstr "我们将编写一个小例子来演示 MoonBit 错误处理系统的基础知识。考虑以下 `div` 函数，它将在除零时引发错误："

#: ../../language/error-handling.md:13
msgid ""
"type! DivisionByZeroError String\n"
"fn div(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  if y == 0 {\n"
"    raise DivisionByZeroError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:23
msgid ""
"In before, we would typically use `type` to define a wrapper type which "
"wraps around some existing foreign type. Here however, we append `type` "
"with `!` to define a error type `DivisionByZeroError` which wraps around "
"`String`."
msgstr ""
"在以前，我们通常使用 `type` 来定义一个包装器类型，该类型包装了某些现有的外部类型。然而，在这里，我们使用 `!` 将 `type` 附加到"
" `DivisionByZeroError`，以定义一个错误类型，该类型包装了 `String`。"

#: ../../language/error-handling.md:27
msgid "`type! E S` construct a error type `E` from `S`"
msgstr "`type! E S` 从 `S` 构造一个错误类型 `E`"

#: ../../language/error-handling.md:29
msgid ""
"Just like `type`, `type!` may have a payload like the above "
"`DivisionByZeroError`, or may not, or may even have multiple constructors"
" like a normal `enum`:"
msgstr ""
"就像 `type` 一样，`type!` 可能有一个像上面的 `DivisionByZeroError` 那样的数据，也可能没有，甚至可能像普通的"
" `enum` 一样有多个构造器："

#: ../../language/error-handling.md:31
msgid ""
"type! ConnectionError {\n"
"  BrokenPipe(Int,String)\n"
"  ConnectionReset\n"
"  ConnectionAbort\n"
"  ConnectionRefused\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:40
msgid ""
"To utilize `DivisionByZeroError` type, we would usually define a function"
" which may raise error by denoting its return type like `T ! E` in the "
"signature, with `T` being the actual return type and `E` being the error "
"type. In this case, it's `Int!DivisionByZeroError`. The error can be "
"thrown using `raise e` where `e` is an instance of `E` which can be "
"constructed using the default constructor of `S`."
msgstr ""
"要使用 `DivisionByZeroError` 类型，我们通常会定义一个函数，该函数通过在签名中定义返回类型为 `T ! E` "
"来表示它会引发错误，其中 `T` 是实际的返回类型，`E` 是错误类型。在这个例子中，它是 "
"`Int!DivisionByZeroError`。错误可以使用 `raise e` 抛出，其中 `e` 是 `E` 的实例，可以使用 `S` "
"的默认构造函数构造。"

#: ../../language/error-handling.md:47
msgid ""
"Any instance of an error is a second class object. Meaning it may only "
"appear in the return value. And if it does appear, the function signature"
" has to be adjusted to match with the return type."
msgstr "任何错误的实例都是一个二等公民对象。这意味着它只能出现在返回值中。如果返回值包含错误，函数签名必须调整以匹配返回类型。"

#: ../../language/error-handling.md:51
msgid ""
"The `test` block in MoonBit may also be seen as a function, with a return"
" type of Unit!Error."
msgstr "MoonBit 中的 `test` 块也可以看作是一个函数，返回类型为 Unit!Error。"

#: ../../language/error-handling.md:54
msgid "Calling an error-able function"
msgstr "调用一个可出错的函数"

#: ../../language/error-handling.md:56
msgid ""
"an error-able function is usually called in 2 manners: `f!(...)` and "
"`f?(...)`."
msgstr "一个可出错的函数通常有两种调用方式：`f!(...)` 和 `f?(...)`。"

#: ../../language/error-handling.md:58
msgid "As-is calling"
msgstr "直接调用"

#: ../../language/error-handling.md:60
msgid ""
"`f!(...)` calls the function directly. The possible error must be dealt "
"in the function that calls `f`. We can either re-raising it without "
"actually dealing with the error:"
msgstr "`f!(...)` 直接调用函数。可能的错误必须在调用 `f` 的函数中处理。我们可以重新抛出它，而不实际处理错误："

#: ../../language/error-handling.md:64
msgid ""
"// We have to match the error type of `div2` with `div`\n"
"fn div2(x : Int, y : Int) -> Int!DivisionByZeroError {\n"
"  div!(x,y)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:71
msgid "or use `try...catch` block like in many other languages:"
msgstr "或者像其他许多语言一样使用 `try...catch` 块："

#: ../../language/error-handling.md:73
msgid ""
"fn div3(x : Int, y : Int) -> Unit {\n"
"  try {\n"
"    div!(x, y)\n"
"  } catch { // `catch` and `except` works the same.\n"
"    DivisionByZeroError(e) => println(\"inf: \\{e}\")\n"
"  } else {\n"
"    v => println(v)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:85
msgid ""
"The `catch...` clause has similar semantics like pattern matching. We can"
" unwrap the error to retrieve the underlying `String` and print it. "
"Additionally, there's an `else` clause to handle the value of `try...` "
"block."
msgstr ""
"`catch...` 子句的语义类似于模式匹配。我们可以解包错误以检索底层的 `String` 并打印它。此外，还有一个 `else` 子句来处理"
" `try...` 块的值。"

#: ../../language/error-handling.md:89
msgid ""
"fn test_try() -> Result[Int, Error] {\n"
"  // compiler can figure out the type of a local error-able function.\n"
"  fn f() -> _!_ {\n"
"    raise Failure(\"err\")\n"
"  }\n"
"\n"
"  try Ok(f!()) { err => Err(err) }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:100
msgid ""
"Curly braces may be omitted if the body of try is a one-liner "
"(expression). The `catch` keyword can also be omitted as well. In the "
"case where a `try` body would raise different errors, the special "
"`catch!` can be used to catch some of the errors, while re-raising other "
"uncaught errors:"
msgstr ""
"如果 `try` 的主体是一行代码（表达式），则大括号可以省略。`catch` 关键字也可以省略。在 `try` "
"主体可能引发不同错误的情况下，可以使用特殊的 `catch!` 来捕获一些错误，同时重新抛出其他未捕获的错误："

#: ../../language/error-handling.md:104
msgid ""
"type! E1\n"
"type! E2\n"
"fn f1() -> Unit!E1 { raise E1 }\n"
"fn f2() -> Unit!E2 { raise E2 }\n"
"fn f() -> Unit! {\n"
"  try {\n"
"    f1!()\n"
"    f2!()\n"
"  } catch! {\n"
"    E1 => println(\"E1\")\n"
"    // E2 gets re-raised.\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:120
msgid "Convert to Result"
msgstr "转换为 Result"

#: ../../language/error-handling.md:122
msgid "Extracting values"
msgstr "提取值"

#: ../../language/error-handling.md:124
msgid ""
"A object of type `Result` is a first class value in MoonBit. `Result` has"
" 2 constructors: `Ok(...)` and `Err(...)` where the former accept a first"
" class object and the latter accept a error object."
msgstr ""
"`Result` 类型的对象是 MoonBit 中的一等公民。`Result` 有 2 个构造器：`Ok(...)` 和 "
"`Err(...)`，前者接受一个一等公民对象，后者接受一个错误对象。"

#: ../../language/error-handling.md:126
msgid ""
"With `f?(...)`, the return type `T!E` is turned into `Result[T,E]`. We "
"may use pattern matching to extract value from it:"
msgstr "使用 `f?(...)`，返回类型 `T!E` 被转换为 `Result[T,E]`。我们可以使用模式匹配从中提取值："

#: ../../language/error-handling.md:128
msgid ""
"let res = div?(10, 0)\n"
"match res {\n"
"  Ok(x) => println(x)\n"
"  Err(DivisionByZeroError(e)) => println(e)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:136
msgid "the `f?()` is basically a syntactic sugar for"
msgstr "`f?()` 基本上是一个语法糖，等价于"

#: ../../language/error-handling.md:138
msgid ""
"let res = try {\n"
"  Ok(div!(10, 0))\n"
"} catch {\n"
"  s => Err(s)\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:146
msgid ""
"Note the difference between `T?` and `f?(...)`: `T` is a type and `T?` is"
" equivalent to `Option[T]` whereas `f?(...)` is a call to an error-able "
"function `f`."
msgstr ""
"注意 `T?` 和 `f?(...)` 之间的区别：`T` 是一个类型，`T?` 等价于 `Option[T]`，而 `f?(...)` "
"是对可出错函数 `f` 的调用。"

#: ../../language/error-handling.md:150
msgid ""
"Besides pattern matching, `Result` provides some useful methods to deal "
"with possible error:"
msgstr "除了模式匹配，`Result` 还提供了一些有用的方法来处理可能的错误："

#: ../../language/error-handling.md:152
msgid ""
"let res1: Result[Int, String] = Err(\"error\")\n"
"let value = res1.or(0) // 0\n"
"\n"
"let res2: Result[Int, String] = Ok(42)\n"
"let value = res2.unwrap() // 42\n"
msgstr ""

#: ../../language/error-handling.md:160
msgid ""
"`or` returns the value if the result is `Ok` or a default value if it is "
"`Err`"
msgstr "`or` 如果结果是 `Ok`，则返回值，如果是 `Err`，则返回默认值"

#: ../../language/error-handling.md:161
msgid "`unwrap` panics if the result is `Err` and return the value if it is `Ok`"
msgstr "`unwrap` 如果结果是 `Err`，则会崩溃，如果是 `Ok`，则返回值"

#: ../../language/error-handling.md:163
msgid "Mapping values"
msgstr "映射值"

#: ../../language/error-handling.md:165
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let new_result = res1.map(fn(x) { x + 1 }) // Ok(43)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let new_result = res2.map_err(fn(x) { x + \"!\" }) // Err(\"error!\")\n"
msgstr ""

#: ../../language/error-handling.md:173
msgid ""
"`map` applies a function to the value within, except it doesn't nothing "
"if result is `Err`."
msgstr "`map` 将函数应用于内部的值；如果结果是 `Err`，则不执行任何操作。"

#: ../../language/error-handling.md:174
msgid "`map_error` does the opposite."
msgstr "`map_error` 则相反。"

#: ../../language/error-handling.md:176
msgid ""
"Unlike some languages, MoonBit treats error-able and nullable value "
"differently. Although one might treat them analogously, as an `Err` "
"result contains no value, only the error, which is like `null`. MoonBit "
"knows that."
msgstr ""
"与一些语言不同，MoonBit 对可出错值和可空值进行了区分。尽管有些人可能将它们类比对待，因为一个不包含值的 `Err` 对象就像 "
"`null`。MoonBit 知道这一点。"

#: ../../language/error-handling.md:178
msgid "`to_option` converts a `Result` to `Option`."
msgstr "`to_option` 将 `Result` 转换为 `Option`。"

#: ../../language/error-handling.md:180
msgid ""
"let res1: Result[Int, String] = Ok(42)\n"
"let option = res1.to_option() // Some(42)\n"
"\n"
"let res2: Result[Int, String] = Err(\"error\")\n"
"let option1 = res2.to_option() // None\n"
msgstr ""

#: ../../language/error-handling.md:188
msgid "Built-in error type and functions"
msgstr "内置错误类型和相关函数"

#: ../../language/error-handling.md:190
msgid "In MoonBit, `Error` is a generalized error type:"
msgstr "在 MoonBit 中，`Error` 是一个通用的错误类型："

#: ../../language/error-handling.md:192
msgid ""
"// These signatures are equivalent. They all raise Error.\n"
"fn f() -> Unit! { .. }\n"
"fn f!() -> Unit { .. }\n"
"fn f() -> Unit!Error { .. }\n"
"\n"
"fn test_error() -> Result[Int, Error] {\n"
"  fn f() -> _!_ {\n"
"    raise DivisionByZeroError(\"err\")\n"
"  }\n"
"\n"
"  try {\n"
"    Ok(f!())\n"
"  } catch {\n"
"    err => Err(err)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:211
msgid ""
"Although the constructor `Err` expects a type of `Error`, we may still "
"pass an error of type `DivisionByZeroError` to it."
msgstr "尽管构造函数 `Err` 期望一个 `Error` 类型，我们仍然可以将 `DivisionByZeroError` 类型的错误传递给它。"

#: ../../language/error-handling.md:214
msgid ""
"But `Error` can't be constructed directly. It's meant to be passed "
"around, not used directly:"
msgstr "但是 `Error` 不能直接构造。它是用来传递的，而不是直接使用："

#: ../../language/error-handling.md:216
msgid ""
"type! ArithmeticError\n"
"\n"
"fn what_error_is_this(e : Error) -> Unit {\n"
"  match e {\n"
"    DivisionByZeroError(_) => println(\"DivisionByZeroError\")\n"
"    ArithmeticError => println(\"ArithmeticError\")\n"
"    ... => println(\"...\")\n"
"    _ => println(\"Error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:229
msgid ""
"`Error` is typically used where concrete error type is not needed, or "
"simply act as a catch-all for all kinds of sub-errors."
msgstr "`Error` 通常用于不需要具体错误类型的情况，或者简单地用来捕获所有的子错误。"

#: ../../language/error-handling.md:232
msgid ""
"As `Error` includes multiple error types, partial matching is not allowed"
" here. We have to do exhaustive matching by providing a catch-"
"all/wildcard case `_`."
msgstr "由于 `Error` 包含多种错误类型，这里不允许部分匹配。我们必须通过提供一个通配符 `_` 来进行兜底匹配。"

#: ../../language/error-handling.md:234
msgid ""
"We usually use the builtin `Failure` error type for a generalized error, "
"and by generalized we mean using it for trivial errors that doesn't need "
"a new error type."
msgstr "我们通常使用内置的 `Failure` 错误类型来表示通用错误：通用意味着它用于不值得单独定义类型的错误。"

#: ../../language/error-handling.md:237
msgid ""
"fn div_trivial(x : Int, y : Int) -> Int!Failure {\n"
"  if y == 0 {\n"
"    raise Failure(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:246
msgid ""
"Besides using the constructor directly, the function `fail!` provides a "
"shorthand to construct a `Failure`. And if we take a look at the source "
"code:"
msgstr "除了直接使用构造函数，函数 `fail!` 提供了一个快捷方式来构造 `Failure`。如果我们查看源代码："

#: ../../language/error-handling.md:249
msgid ""
"pub fn fail[T](msg : String, ~loc : SourceLoc = _) -> T!Failure {\n"
"  raise Failure(\"FAILED: \\{loc} \\{msg}\")\n"
"}\n"
msgstr ""

#: ../../language/error-handling.md:255
msgid ""
"We can see that `fail` is merely a constructor with a pre-defined output "
"template for showing both the error and the source location. In practice,"
" `fail!` is always preferred over `Failure`."
msgstr "我们可以看到 `fail` 只是一个带有预定义输出模板的构造函数，用于显示错误和源位置。在实践中，`fail!` 总是比 `Failure`更常用。"

#: ../../language/error-handling.md:259
msgid ""
"Other functions used to break control flow are `abort` and `panic`. They "
"are equivalent. An `panic` at any place will manually crash the program "
"at that place, and prints out stack trace."
msgstr ""
"其他用于打破控制流的函数有 `abort` 和 `panic`。它们是等效的。在任何地方的 `panic` "
"都会手动在那个地方崩溃程序，并打印出堆栈跟踪。"

#: ../../language/ffi-and-wasm-host.md:1
msgid "Foreign Function Interface(FFI)"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:3
msgid ""
"You can use foreign function in MoonBit through FFI to interact with the "
"hosting runtime when embedded inside the browser or command line "
"applications through [Wasmtime](https://wasmtime.dev/) or similar "
"projects."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:5
msgid ""
"⚠ Warning: MoonBit is still in early stage, so the content may be "
"outdated."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:7
msgid "FFI"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:9
msgid "Declare Foreign Reference"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:11
msgid "You can declare a foreign reference type like this:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:13
msgid "type Canvas_ctx\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:17
msgid ""
"This will be a type that represents a reference to a foreign object, a "
"`CanvasRenderingContext2D` object held by the hosting JavaScript runtime "
"in this example."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:19
msgid "Declare Foreign Function"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:21
msgid "You can declare a foreign function like this:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:23
msgid "fn cos(d : Double) -> Double = \"Math\" \"cos\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:27
msgid ""
"It's similar to a normal function definition except that the function "
"body is replaced with two strings."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:29
msgid ""
"For WasmGC backend, these two strings are used to identify the specific "
"function from a Wasm import object, the first string is the module name, "
"and the second string is the function name. For JS backend, these two "
"strings are used to call a static function in the global namespace. The "
"example above becomes similar to `const cos = (d) => Math.cos(d)`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:31
msgid ""
"You can also declare inline functions where the function body is replaced"
" with one string."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:33
msgid ""
"For WasmGC backend, you may declare it as a Wasm function without name "
"(which will be generated afterwards):"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:35
msgid ""
"extern \"wasm\" fn abs(d : Double) -> Double =\n"
"  #|(func (param f64) (result f64))\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:40
msgid "and for JS backend, you may declare it as a lambda expression:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:42
msgid ""
"extern \"js\" fn abs(d : Double) -> Double =\n"
"  #|(d) => Math.abs(d)\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:47
msgid "After declaration, you can use foreign functions like regular functions."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:49
msgid ""
"For multi-backend project, you may implement backend specific code in the"
" files that ends with `.wasm.mbt` `.wasm-gc.mbt` and `.js.mbt`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:51
msgid ""
"You may also declare a foreign function that will be invoked upon a "
"foreign object by using the foreign reference type like this:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:53
msgid "fn begin_path(self: Canvas_ctx) = \"canvas\" \"begin_path\"\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:57
msgid ""
"and apply it to a previously owned reference normally such as "
"`context.begin_path()`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:59
msgid "Exported functions"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:61
msgid ""
"Functions that are not methods nor polymorphic functions can be exported "
"if they are public and if the link configuration appears in the "
"`moon.pkg.json` of the package:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:63
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [\n"
"        \"add\",\n"
"        \"fib:test\"\n"
"      ]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [\n"
"        \"add\",\n"
"        \"fib:test\"\n"
"      ]\n"
"    },\n"
"    \"js\": {\n"
"      \"exports\": [\n"
"        \"add\",\n"
"        \"fib:test\"\n"
"      ],\n"
"      \"format\": \"esm\"\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:89
msgid ""
"Each backend has a separate definition. For JS backend, a `format` option"
" is used to specify whether the generated JavaScript file should be "
"released as an ES Module (`esm`), a CommonJS module (`cjs`), or an "
"immediately invoked function expression (`iife`)."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:91
msgid ""
"The example above will export function `add` and `fib`, and the function "
"`fib` will be exported with the name of `test`."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:93
msgid ""
"For WasmGC backend, the `_start` function should always be called to "
"initialize all the global instances defined in MoonBit program."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:95
msgid "Use compiled Wasm"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:97
msgid ""
"To use the compiled Wasm, you need to initialize the Wasm module with the"
" host functions so as to meet the needs of the foreign functions, and "
"then use the exported functions provided by the Wasm module."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:99
msgid "Provide host functions"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:101
msgid ""
"To use the compiled Wasm, you must provide **All** declared foreign "
"functions in Wasm import object."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:103
msgid "For example, to use wasm compiled from above code snippet in JavaScript:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:105
msgid ""
"WebAssembly.instantiateStreaming(fetch(\"xxx.wasm\"), {\n"
"  Math: {\n"
"    cos: (d) => Math.cos(d),\n"
"  },\n"
"});\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:113
msgid ""
"Check out the documentation such as [MDN](https://developer.mozilla.org"
"/en-US/docs/WebAssembly) or the manual of runtime that you're using to "
"embed the Wasm."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:115
msgid "Example: Smiling face"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:117
msgid ""
"Let's walk through a full example to draw a smiling face using Canvas API"
" in MoonBit. Suppose you created a new project with `moon new draw`"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:119
msgid ""
"// We first declare a type representing the context of canvas\n"
"type Canvas_ctx\n"
"\n"
"// We then declare the foreign function interfaces\n"
"fn begin_path(self : Canvas_ctx) = \"canvas\" \"beginPath\"\n"
"fn arc(self : Canvas_ctx, x : Int, y : Int, radius : Int, start_angle : "
"Double,\n"
"    end_angle : Double, counterclockwise : Bool) = \"canvas\" \"arc\"\n"
"fn move_to(self : Canvas_ctx, x : Int, y : Int) = \"canvas\" \"moveTo\"\n"
"fn stroke(self : Canvas_ctx) = \"canvas\" \"stroke\"\n"
"\n"
"fn get_pi() -> Double = \"math\" \"PI\"\n"
"let pi : Double = get_pi()\n"
"\n"
"// We then apply these functions to define the drawing function upon the "
"context\n"
"pub fn draw(self : Canvas_ctx) -> Unit {\n"
"  self.begin_path()\n"
"  self.arc(75, 75, 50, 0.0, pi * 2.0, true) // Outer circle\n"
"  self.move_to(110, 75)\n"
"  self.arc(75, 75, 35, 0.0, pi, false) // Mouth (clockwise)\n"
"  self.move_to(65, 65)\n"
"  self.arc(60, 65, 5, 0.0, pi * 2.0, true) // Left eye\n"
"  self.move_to(95, 65)\n"
"  self.arc(90, 65, 5, 0.0, pi * 2.0, true) // Right eye\n"
"  self.stroke()\n"
"}\n"
"\n"
"// We also demonstrate the `println` functionality here\n"
"pub fn display_pi() -> Unit {\n"
"  println(\"PI: \\{pi}\")\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:152
msgid ""
"{\n"
"  \"link\": {\n"
"    \"wasm\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    },\n"
"    \"wasm-gc\": {\n"
"      \"exports\": [\"draw\", \"display_pi\"]\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:165
msgid ""
"Build the project using `moon build`. We recommend using Wasm with GC "
"integration whenever possible (which is the default). If the environment "
"does not support the GC feature, use the `--target wasm` option instead."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:167
msgid "We now can use it from JavaScript."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:169
msgid ""
"<html lang=\"en\">\n"
"  <body>\n"
"    <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  </body>\n"
"  <script>\n"
"    // import object for defining the FFI\n"
"    const importObject = {\n"
"      // TODO\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          // Always call _start to initialize the environment\n"
"          obj.instance.exports._start();\n"
"          // Pass the JS object as parameter to draw the smiling face\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          // Display the value of PI\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:198
msgid ""
"For import object, we need to provide all the FFI used in the previously "
"defined program: the canvas rendering API, the math API and finally, an "
"API for printing to the console used by the `println` or `print` "
"function."
msgstr ""

#: ../../language/ffi-and-wasm-host.md:200
msgid ""
"As of the canvas rendering API and the math API, we can use the following"
" code to convert the methods of objects into function calls that accept "
"the object as the first parameter, and convert the constant properties of"
" objects into functions that returns the value:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:202
msgid ""
"function prototype_to_ffi(prototype) {\n"
"  return Object.fromEntries(\n"
"    Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"      .filter(([_key, value]) => value.value)\n"
"      .map(([key, value]) => {\n"
"        if (typeof value.value == 'function')\n"
"          return [key, Function.prototype.call.bind(value.value)]\n"
"        // TODO: it is also possible to convert properties into getters "
"and setters\n"
"        else\n"
"          return [key, () => value.value]\n"
"      })\n"
"  );\n"
"}\n"
"\n"
"const importObject = {\n"
"  canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"  math: prototype_to_ffi(Math),\n"
"  // ...\n"
"}\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:224
msgid ""
"As of the printing service, we can provide the following closure so that "
"it buffers the bytes of string until it needs to be logged to the "
"console:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:226
msgid ""
"const [log, flush] = (() => {\n"
"  var buffer = [];\n"
"  function flush() {\n"
"    if (buffer.length > 0) {\n"
"      console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"      buffer = [];\n"
"    }\n"
"  }\n"
"  function log(ch) {\n"
"    if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"    else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"    else { buffer.push(ch); }\n"
"  }\n"
"  return [log, flush]\n"
"})();\n"
"\n"
"const importObject = {\n"
"  // ...\n"
"  spectest: {\n"
"    print_char: log\n"
"  },\n"
"}\n"
"\n"
"// ...\n"
"WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"  (obj) => {\n"
"    obj.instance.exports._start();\n"
"    // ...\n"
"    flush()\n"
"  }\n"
");\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:260
msgid "Now, we put them together, so this is our final complete `index.html`:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:262
msgid ""
"<!DOCTYPE html>\n"
"<html>\n"
"\n"
"<head></head>\n"
"\n"
"<body>\n"
"  <canvas id=\"canvas\" width=\"150\" height=\"150\"></canvas>\n"
"  <script>\n"
"    function prototype_to_ffi(prototype) {\n"
"      return Object.fromEntries(\n"
"        Object.entries(Object.getOwnPropertyDescriptors(prototype))\n"
"          .filter(([_key, value]) => value.value)\n"
"          .map(([key, value]) => {\n"
"            if (typeof value.value == 'function')\n"
"              return [key, Function.prototype.call.bind(value.value)]\n"
"            else\n"
"              return [key, () => value.value]\n"
"          })\n"
"      );\n"
"    }\n"
"\n"
"    const [log, flush] = (() => {\n"
"      var buffer = [];\n"
"      function flush() {\n"
"        if (buffer.length > 0) {\n"
"          console.log(new TextDecoder(\"utf-16\").decode(new "
"Uint16Array(buffer).valueOf()));\n"
"          buffer = [];\n"
"        }\n"
"      }\n"
"      function log(ch) {\n"
"        if (ch == '\\n'.charCodeAt(0)) { flush(); }\n"
"        else if (ch == '\\r'.charCodeAt(0)) { /* noop */ }\n"
"        else { buffer.push(ch); }\n"
"      }\n"
"      return [log, flush]\n"
"    })();\n"
"\n"
"\n"
"\n"
"    const importObject = {\n"
"      canvas: prototype_to_ffi(CanvasRenderingContext2D.prototype),\n"
"      math: prototype_to_ffi(Math),\n"
"      spectest: {\n"
"        print_char: log\n"
"      },\n"
"    }\n"
"\n"
"    const canvas = document.getElementById(\"canvas\");\n"
"    if (canvas.getContext) {\n"
"      const ctx = canvas.getContext(\"2d\");\n"
"      WebAssembly.instantiateStreaming(fetch(\"target/wasm-"
"gc/release/build/lib/lib.wasm\"), importObject).then(\n"
"        (obj) => {\n"
"          obj.instance.exports._start();\n"
"          obj.instance.exports[\"draw\"](ctx);\n"
"          obj.instance.exports[\"display_pi\"]();\n"
"          flush()\n"
"        }\n"
"      );\n"
"    }\n"
"  </script>\n"
"</body>\n"
"\n"
"</html>\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:328
msgid ""
"Make sure that `draw.wasm` and `index.html` are in the same folder, then "
"start a http server at this folder. For example, using Python:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:330
msgid "python3 -m http.server 8080\n"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:334
msgid ""
"Goto [http://localhost:8080](http://localhost:8080) in your browser, "
"there should be a smile face on the screen and an output on the console:"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:336
msgid ""
"![A smile face webpage with browser devtools "
"open](../imgs/smile_face_with_log.png)"
msgstr ""

#: ../../language/ffi-and-wasm-host.md:336
msgid "A smile face webpage with browser devtools open"
msgstr ""

#: ../../language/index.md:9
msgid "Contents:"
msgstr ""

#: ../../language/index.md:1
msgid "Language"
msgstr ""

#: ../../language/index.md:3
msgid "Here are the topics about the programming syntax."
msgstr ""

#: ../../language/index.md:5
msgid ""
"[MoonBit](./language.md): almost everything you need to know about the "
"MoonBit grammar."
msgstr ""

#: ../../language/index.md:6
msgid ""
"[Error handling](./error-handling.md): the error handling mechanism in "
"MoonBit."
msgstr ""

#: ../../language/index.md:7
msgid ""
"[Foreign Function Interface](./ffi-and-wasm-host.md): how MoonBit "
"interacts with the real world using different backends."
msgstr ""

#: ../../language/language.md:1
msgid "MoonBit"
msgstr ""

#: ../../language/language.md:3
msgid ""
"MoonBit is an end-to-end programming language toolchain for cloud and "
"edge computing using WebAssembly. The IDE environment is available at "
"[https://try.moonbitlang.com](https://try.moonbitlang.com) without any "
"installation; it does not rely on any server either."
msgstr ""

#: ../../language/language.md:5
msgid "Status and aimed timeline"
msgstr ""

#: ../../language/language.md:7
msgid ""
"MoonBit is currently in beta-preview. We expect to reach beta in "
"2024/11/22, and 1.0 in 2025."
msgstr ""

#: ../../language/language.md:9
msgid ""
"When MoonBit reaches beta, it means any backwards-incompatible changes "
"will be seriously evaluated and MoonBit _can_ be used in production(very "
"rare compiler bugs). MoonBit is developed by a talented full time team "
"who had extensive experience in building language toolchains, so we will "
"grow much faster than the typical language ecosystem, you won't wait long"
" to use MoonBit in your production."
msgstr ""

#: ../../language/language.md:11
msgid "Main advantages"
msgstr ""

#: ../../language/language.md:13
msgid "Generate significantly smaller WASM output than any existing solutions."
msgstr ""

#: ../../language/language.md:14
msgid "Much faster runtime performance."
msgstr ""

#: ../../language/language.md:15
msgid "State of the art compile-time performance."
msgstr ""

#: ../../language/language.md:16
msgid "Simple but practical, data-oriented language design."
msgstr ""

#: ../../language/language.md:18
msgid "Overview"
msgstr ""

#: ../../language/language.md:20
msgid ""
"A MoonBit program consists of type definitions, function definitions, and"
" variable bindings."
msgstr ""

#: ../../language/language.md:22
msgid "Program entrance"
msgstr ""

#: ../../language/language.md:24
msgid ""
"There is a specialized function called `init` function. The `init` "
"function is special in two aspects:"
msgstr ""

#: ../../language/language.md:26
msgid "There can be multiple `init` functions in the same package."
msgstr ""

#: ../../language/language.md:27
msgid ""
"An `init` function can't be explicitly called or referred to by other "
"functions. Instead, all `init` functions will be implicitly called when "
"initializing a package. Therefore, `init` functions should only consist "
"of statements."
msgstr ""

#: ../../language/language.md:29
msgid ""
"fn init {\n"
"  let x = 1\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/language.md:35
msgid ""
"For WebAssembly backend, it means that it will be executed **before** the"
" instance is available, meaning that the FFIs that relies on the "
"instance's exportations can not be used at this stage; for JavaScript "
"backend, it means that it will be executed during the importation stage."
msgstr ""

#: ../../language/language.md:38
msgid ""
"There is another specialized function called `main` function. The `main` "
"function is the main entrance of the program, and it will be executed "
"after the initialization stage."
msgstr ""

#: ../../language/language.md:40
msgid ""
"fn main {\n"
"  let x = 2\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/language.md:46
msgid "The previous two code snippets will print the following at runtime:"
msgstr ""

#: ../../language/language.md:48
msgid ""
"1\n"
"2\n"
msgstr ""

#: ../../language/language.md:54
msgid ""
"Only packages that are `main` packages can define such `main` function. "
"Check out [build system tutorial](/toolchain/moon/tutorial) for detail."
msgstr ""

#: ../../language/language.md:56
msgid "moon.pkg.json"
msgstr ""

#: ../../language/language.md:56
msgid ""
"{\n"
"  \"is-main\": true\n"
"}"
msgstr ""

#: ../../language/language.md:61
msgid ""
"The two functions above need to drop the parameter list and the return "
"type."
msgstr ""

#: ../../language/language.md:63
msgid "Expressions and Statements"
msgstr ""

#: ../../language/language.md:65
msgid ""
"MoonBit distinguishes between statements and expressions. In a function "
"body, only the last clause should be an expression, which serves as a "
"return value. For example:"
msgstr ""

#: ../../language/language.md:67
msgid ""
"fn foo() -> Int {\n"
"  let x = 1\n"
"  x + 1\n"
"}\n"
"\n"
"fn bar() -> Int {\n"
"  let x = 1\n"
"  // x + 1 // fail\n"
"  x + 2\n"
"}\n"
msgstr ""

#: ../../language/language.md:73
msgid "Expressions include:"
msgstr ""

#: ../../language/language.md:75
msgid ""
"Value literals (e.g. Boolean values, numbers, characters, strings, "
"arrays, tuples, structs)"
msgstr ""

#: ../../language/language.md:76
msgid "Arithmetical, logical, or comparison operations"
msgstr ""

#: ../../language/language.md:77
msgid ""
"Accesses to array elements (e.g. `a[0]`) or struct fields (e.g `r.x`) or "
"tuple components (e.g. `t.0`)"
msgstr ""

#: ../../language/language.md:78
msgid "Variables and (capitalized) enum constructors"
msgstr ""

#: ../../language/language.md:79
msgid "Anonymous local function definitions"
msgstr ""

#: ../../language/language.md:80
msgid "`match` and `if` expressions"
msgstr ""

#: ../../language/language.md:82
msgid "Statements include:"
msgstr ""

#: ../../language/language.md:84
msgid "Named local function definitions"
msgstr ""

#: ../../language/language.md:85
msgid "Local variable bindings"
msgstr ""

#: ../../language/language.md:86
msgid "Assignments"
msgstr ""

#: ../../language/language.md:87
msgid "`return` statements"
msgstr ""

#: ../../language/language.md:88
msgid "Any expression whose return type is `Unit`"
msgstr ""

#: ../../language/language.md:90
msgid "Functions"
msgstr ""

#: ../../language/language.md:92
msgid ""
"Functions take arguments and produce a result. In MoonBit, functions are "
"first-class, which means that functions can be arguments or return values"
" of other functions. MoonBit's naming convention requires that function "
"names should not begin with uppercase letters (A-Z). Compare for "
"constructors in the `enum` section below."
msgstr ""

#: ../../language/language.md:94
msgid "Top-Level Functions"
msgstr ""

#: ../../language/language.md:96
msgid ""
"Functions can be defined as top-level or local. We can use the `fn` "
"keyword to define a top-level function that sums three integers and "
"returns the result, as follows:"
msgstr ""

#: ../../language/language.md:98
msgid ""
"fn add3(x : Int, y : Int, z : Int) -> Int {\n"
"  x + y + z\n"
"}\n"
msgstr ""

#: ../../language/language.md:104
msgid ""
"Note that the arguments and return value of top-level functions require "
"explicit type annotations."
msgstr ""

#: ../../language/language.md:106
msgid "Local Functions"
msgstr ""

#: ../../language/language.md:108
msgid ""
"Local functions can be named or anonymous. Type annotations can be "
"omitted for local function definitions: they can be automatically "
"inferred in most cases. For example:"
msgstr ""

#: ../../language/language.md:110
msgid ""
"fn local_1() -> Int {\n"
"  fn inc(x) { // named as `inc`\n"
"    x + 1\n"
"  }\n"
"  // anonymous, instantly appplied to integer literal 6\n"
"  (fn(x) { x + inc(2) })(6)\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_1(), 9)\n"
"}\n"
msgstr ""

#: ../../language/language.md:116
msgid ""
"Functions, whether named or anonymous, are _lexical closures_: any "
"identifiers without a local binding must refer to bindings from a "
"surrounding lexical scope. For example:"
msgstr ""

#: ../../language/language.md:118
msgid ""
"let global_y = 3\n"
"\n"
"fn local_2(x : Int) -> (Int, Int) {\n"
"  fn inc() {\n"
"    x + 1\n"
"  }\n"
"\n"
"  fn four() {\n"
"    global_y + 1\n"
"  }\n"
"\n"
"  (inc(), four())\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(local_2(3), (4, 4))\n"
"}\n"
msgstr ""

#: ../../language/language.md:124
msgid "Function Applications"
msgstr ""

#: ../../language/language.md:126
msgid "A function can be applied to a list of arguments in parentheses:"
msgstr ""

#: ../../language/language.md:128
msgid "add3(1, 2, 7)\n"
msgstr ""

#: ../../language/language.md:132
msgid ""
"This works whether `add3` is a function defined with a name (as in the "
"previous example), or a variable bound to a function value, as shown "
"below:"
msgstr ""

#: ../../language/language.md:134
msgid ""
"test {\n"
"  let add3 = fn(x, y, z) { x + y + z }\n"
"  assert_eq!(add3(1, 2, 7), 10)\n"
"}\n"
msgstr ""

#: ../../language/language.md:140
msgid ""
"The expression `add3(1, 2, 7)` returns `10`. Any expression that "
"evaluates to a function value is applicable:"
msgstr ""

#: ../../language/language.md:142
msgid ""
"test {\n"
"  let f = fn(x) { x + 1 }\n"
"  let g = fn(x) { x + 2 }\n"
"  let w = (if true { f } else { g })(3)\n"
"  assert_eq!(w, 4)\n"
"}\n"
msgstr ""

#: ../../language/language.md:149
msgid "Labelled arguments"
msgstr ""

#: ../../language/language.md:151
msgid ""
"Functions can declare labelled argument with the syntax `label~ : Type`. "
"`label` will also serve as parameter name inside function body:"
msgstr ""

#: ../../language/language.md:153
msgid ""
"fn labelled_1(arg1~ : Int, arg2~ : Int) -> Int {\n"
"  arg1 + arg2\n"
"}\n"
msgstr ""

#: ../../language/language.md:159
msgid ""
"Labelled arguments can be supplied via the syntax `label=arg`. "
"`label=label` can be abbreviated as `label~`:"
msgstr ""

#: ../../language/language.md:161
msgid ""
"test {\n"
"  let arg1 = 1\n"
"  assert_eq!(labelled_1(arg2=2, arg1~), 3)\n"
"}\n"
msgstr ""

#: ../../language/language.md:167
msgid ""
"Labelled function can be supplied in any order. The evaluation order of "
"arguments is the same as the order of parameters in function declaration."
msgstr ""

#: ../../language/language.md:169
msgid "Optional arguments"
msgstr ""

#: ../../language/language.md:171
msgid ""
"A labelled argument can be made optional by supplying a default "
"expression with the syntax `label~ : Type = default_expr`. If this "
"argument is not supplied at call site, the default expression will be "
"used:"
msgstr ""

#: ../../language/language.md:173
msgid ""
"fn optional(opt~ : Int = 42) -> Int {\n"
"  opt\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(optional(), 42)\n"
"  assert_eq!(optional(opt=0), 0)\n"
"}\n"
msgstr ""

#: ../../language/language.md:179
msgid ""
"The default expression will be evaluated every time it is used. And the "
"side effect in the default expression, if any, will also be triggered. "
"For example:"
msgstr ""

#: ../../language/language.md:181
msgid ""
"fn incr(counter~ : Ref[Int] = { val: 0 }) -> Ref[Int] {\n"
"  counter.val = counter.val + 1\n"
"  counter\n"
"}\n"
"\n"
"test {\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  inspect!(incr(), content=\"{val: 1}\")\n"
"  let counter : Ref[Int] = { val: 0 }\n"
"  inspect!(incr(counter~), content=\"{val: 1}\")\n"
"  inspect!(incr(counter~), content=\"{val: 2}\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:187
msgid ""
"If you want to share the result of default expression between different "
"function calls, you can lift the default expression to a toplevel `let` "
"declaration:"
msgstr ""

#: ../../language/language.md:189
msgid ""
"let default_counter : Ref[Int] = { val: 0 }\n"
"\n"
"fn incr_2(counter~ : Ref[Int] = default_counter) -> Int {\n"
"  counter.val = counter.val + 1\n"
"  counter.val\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(incr_2(), 1)\n"
"  assert_eq!(incr_2(), 2)\n"
"}\n"
msgstr ""

#: ../../language/language.md:195
msgid ""
"Default expression can depend on the value of previous arguments. For "
"example:"
msgstr ""

#: ../../language/language.md:197
msgid ""
"fn sub_array[X](\n"
"  xs : Array[X],\n"
"  offset~ : Int,\n"
"  len~ : Int = xs.length() - offset\n"
") -> Array[X] {\n"
"  xs[offset:offset + len].iter().to_array()\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1), [2, 3])\n"
"  assert_eq!(sub_array([1, 2, 3], offset=1, len=1), [2])\n"
"}\n"
msgstr ""

#: ../../language/language.md:204
msgid "Automatically insert `Some` when supplying optional arguments"
msgstr ""

#: ../../language/language.md:206
msgid ""
"It is quite often optional arguments have type `T?` with `None` as "
"default value. In this case, passing the argument explicitly requires "
"wrapping a `Some`, which is ugly:"
msgstr ""

#: ../../language/language.md:210
msgid ""
"fn ugly_constructor(width~ : Int? = None, height~ : Int? = None) -> Image"
" {\n"
"  ...\n"
"}\n"
"\n"
"let img : Image = ugly_constructor(width=Some(1920), height=Some(1080))\n"
msgstr ""

#: ../../language/language.md:216
msgid ""
"Fortunately, MoonBit provides a special kind of optional arguments to "
"solve this problem. Optional arguments declared with `label? : T` has "
"type `T?` and `None` as default value. When supplying this kind of "
"optional argument directly, MoonBit will automatically insert a `Some`:"
msgstr ""

#: ../../language/language.md:220
msgid ""
"fn nice_constructor(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"let img2 : Image = nice_constructor(width=1920, height=1080)\n"
msgstr ""

#: ../../language/language.md:226
msgid ""
"Sometimes, it is also useful to pass a value of type `T?` directly, for "
"example when forwarding optional argument. MoonBit provides a syntax "
"`label?=value` for this, with `label?` being an abbreviation of "
"`label?=label`:"
msgstr ""

#: ../../language/language.md:230
msgid ""
"fn image(width? : Int, height? : Int) -> Image {\n"
"  ...\n"
"}\n"
"\n"
"fn fixed_width_image(height? : Int) -> Image {\n"
"  image(width=1920, height?)\n"
"}\n"
msgstr ""

#: ../../language/language.md:236
msgid "Autofill arguments"
msgstr ""

#: ../../language/language.md:238
msgid ""
"MoonBit supports filling specific types of arguments automatically at "
"different call site, such as the source location of a function call. To "
"declare an autofill argument, simply declare an optional argument with "
"`_` as default value. Now if the argument is not explicitly supplied, "
"MoonBit will automatically fill it at the call site."
msgstr ""

#: ../../language/language.md:242
msgid ""
"Currently MoonBit supports two types of autofill arguments, `SourceLoc`, "
"which is the source location of the whole function call, and `ArgsLoc`, "
"which is a array containing the source location of each argument, if any:"
msgstr ""

#: ../../language/language.md:245
msgid ""
"fn f(_x : Int, loc~ : SourceLoc = _, args_loc~ : ArgsLoc = _) -> String {"
"\n"
"  $|loc of whole function call: \\{loc}\n"
"  $|loc of arguments: \\{args_loc}\n"
"  // loc of whole function call: <filename>:7:3-7:10\n"
"  // loc of arguments: [Some(<filename>:7:5-7:6), "
"Some(<filename>:7:8-7:9), None, None]\n"
"}\n"
msgstr ""

#: ../../language/language.md:251
msgid ""
"Autofill arguments are very useful for writing debugging and testing "
"utilities."
msgstr ""

#: ../../language/language.md:253
msgid "Control Structures"
msgstr ""

#: ../../language/language.md:255
msgid "Conditional Expressions"
msgstr ""

#: ../../language/language.md:257
msgid ""
"A conditional expression consists of a condition, a consequent, and an "
"optional else clause."
msgstr ""

#: ../../language/language.md:259
msgid ""
"if x == y {\n"
"  expr1\n"
"} else {\n"
"  expr2\n"
"}\n"
msgstr ""

#: ../../language/language.md:266
msgid "The else clause can also contain another if-else expression:"
msgstr ""

#: ../../language/language.md:268
msgid ""
"if x == y {\n"
"  expr1\n"
"}\n"
msgstr ""

#: ../../language/language.md:275
msgid ""
"Curly brackets are used to group multiple expressions in the consequent "
"or the else clause."
msgstr ""

#: ../../language/language.md:277
msgid ""
"Note that a conditional expression always returns a value in MoonBit, and"
" the return values of the consequent and the else clause must be of the "
"same type. Here is an example:"
msgstr ""

#: ../../language/language.md:279
msgid "let initial = if size < 1 { 1 } else { size }\n"
msgstr ""

#: ../../language/language.md:286
msgid "While loop"
msgstr ""

#: ../../language/language.md:288
msgid ""
"In MoonBit, `while` loop can be used to execute a block of code "
"repeatedly as long as a condition is true. The condition is evaluated "
"before executing the block of code. The `while` loop is defined using the"
" `while` keyword, followed by a condition and the loop body. The loop "
"body is a sequence of statements. The loop body is executed as long as "
"the condition is true."
msgstr ""

#: ../../language/language.md:290
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:298 ../../language/language.md:312
#: ../../language/language.md:326 ../../language/language.md:340
#: ../../language/language.md:352 ../../language/language.md:369
#: ../../language/language.md:407 ../../language/language.md:445
#: ../../language/language.md:459 ../../language/language.md:683
#: ../../language/language.md:715 ../../language/language.md:742
#: ../../language/language.md:766 ../../language/language.md:854
#: ../../language/language.md:881 ../../language/language.md:912
#: ../../language/language.md:939 ../../language/language.md:968
#: ../../language/language.md:988 ../../language/language.md:1022
#: ../../language/language.md:1036 ../../language/language.md:1159
#: ../../language/language.md:1347
msgid "Output"
msgstr ""

#: ../../language/language.md:298
msgid ""
"5\n"
"4\n"
"3\n"
"2\n"
"1\n"
msgstr ""

#: ../../language/language.md:302
msgid ""
"The loop body supports `break` and `continue`. Using `break` allows you "
"to exit the current loop, while using `continue` skips the remaining part"
" of the current iteration and proceeds to the next iteration."
msgstr ""

#: ../../language/language.md:304
msgid ""
"fn main {\n"
"  let mut i = 5\n"
"  while i > 0 {\n"
"    i = i - 1\n"
"    if i == 4 {\n"
"      continue\n"
"    }\n"
"    if i == 1 {\n"
"      break\n"
"    }\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:312
msgid ""
"3\n"
"2\n"
msgstr ""

#: ../../language/language.md:316
msgid ""
"The `while` loop also supports an optional `else` clause. When the loop "
"condition becomes false, the `else` clause will be executed, and then the"
" loop will end."
msgstr ""

#: ../../language/language.md:318
msgid ""
"fn main {\n"
"  let mut i = 2\n"
"  while i > 0 {\n"
"    println(i)\n"
"    i = i - 1\n"
"  } else {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:326
msgid ""
"2\n"
"1\n"
"0\n"
msgstr ""

#: ../../language/language.md:330
msgid ""
"When there is an `else` clause, the `while` loop can also return a value."
" The return value is the evaluation result of the `else` clause. In this "
"case, if you use `break` to exit the loop, you need to provide a return "
"value after `break`, which should be of the same type as the return value"
" of the `else` clause."
msgstr ""

#: ../../language/language.md:332
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"    if i % 2 == 0 {\n"
"      break 5\n"
"    }\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/language.md:340
msgid "5\n"
msgstr ""

#: ../../language/language.md:344
msgid ""
"fn main {\n"
"  let mut i = 10\n"
"  let r = while i > 0 {\n"
"    i = i - 1\n"
"  } else {\n"
"    7\n"
"  }\n"
"  println(r)\n"
"}\n"
msgstr ""

#: ../../language/language.md:352
msgid "7\n"
msgstr ""

#: ../../language/language.md:356
msgid "For Loop"
msgstr ""

#: ../../language/language.md:358
msgid ""
"MoonBit also supports C-style For loops. The keyword `for` is followed by"
" variable initialization clauses, loop conditions, and update clauses "
"separated by semicolons. They do not need to be enclosed in parentheses. "
"For example, the code below creates a new variable binding `i`, which has"
" a scope throughout the entire loop and is immutable. This makes it "
"easier to write clear code and reason about it:"
msgstr ""

#: ../../language/language.md:361
msgid ""
"fn main {\n"
"  for i = 0; i < 5; i = i + 1 {\n"
"    println(i)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:369
msgid ""
"0\n"
"1\n"
"2\n"
"3\n"
"4\n"
msgstr ""

#: ../../language/language.md:373
msgid "The variable initialization clause can create multiple bindings:"
msgstr ""

#: ../../language/language.md:375
msgid ""
"for i = 0, j = 0; i + j < 100; i = i + 1, j = j + 1 {\n"
"  println(i)\n"
"}\n"
msgstr ""

#: ../../language/language.md:382
msgid ""
"It should be noted that in the update clause, when there are multiple "
"binding variables, the semantics are to update them simultaneously. In "
"other words, in the example above, the update clause does not execute `i "
"= i + 1`, `j = j + 1` sequentially, but rather increments `i` and `j` at "
"the same time. Therefore, when reading the values of the binding "
"variables in the update clause, you will always get the values updated in"
" the previous iteration."
msgstr ""

#: ../../language/language.md:384
msgid ""
"Variable initialization clauses, loop conditions, and update clauses are "
"all optional. For example, the following two are infinite loops:"
msgstr ""

#: ../../language/language.md:386
msgid ""
"for i = 1; ; i = i + 1 {\n"
"  println(i)\n"
"}\n"
"for {\n"
"  println(\"loop forever\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:393
msgid ""
"The `for` loop also supports `continue`, `break`, and `else` clauses. "
"Like the `while` loop, the `for` loop can also return a value using the "
"`break` and `else` clauses."
msgstr ""

#: ../../language/language.md:395
msgid ""
"The `continue` statement skips the remaining part of the current "
"iteration of the `for` loop (including the update clause) and proceeds to"
" the next iteration. The `continue` statement can also update the binding"
" variables of the `for` loop, as long as it is followed by expressions "
"that match the number of binding variables, separated by commas."
msgstr ""

#: ../../language/language.md:397
msgid ""
"For example, the following program calculates the sum of even numbers "
"from 1 to 6:"
msgstr ""

#: ../../language/language.md:399
msgid ""
"fn main {\n"
"  let sum = for i = 1, acc = 0; i <= 6; i = i + 1 {\n"
"    if i % 2 == 0 {\n"
"      println(\"even: \\{i}\")\n"
"      continue i + 1, acc + i\n"
"    }\n"
"  } else {\n"
"    acc\n"
"  }\n"
"  println(sum)\n"
"}\n"
msgstr ""

#: ../../language/language.md:407
msgid ""
"even: 2\n"
"even: 4\n"
"even: 6\n"
"12\n"
msgstr ""

#: ../../language/language.md:411
msgid "`for .. in` loop"
msgstr ""

#: ../../language/language.md:413
msgid ""
"MoonBit supports traversing elements of different data structures and "
"sequences via the `for .. in` loop syntax:"
msgstr ""

#: ../../language/language.md:415
msgid ""
"for x in [1, 2, 3] {\n"
"  println(x)\n"
"}\n"
msgstr ""

#: ../../language/language.md:422
msgid ""
"`for .. in` loop is translated to the use of `Iter` in MoonBit's standard"
" library. Any type with a method `.iter() : Iter[T]` can be traversed "
"using `for .. in`. For more information of the `Iter` type, see "
"[Iterator](#iterator) below."
msgstr ""

#: ../../language/language.md:425
msgid ""
"In addition to sequences of a single value, MoonBit also supports "
"traversing sequences of two values, such as `Map`, via the `Iter2` type "
"in MoonBit's standard library. Any type with method `.iter2() : Iter2[A, "
"B]` can be traversed using `for .. in` with two loop variables:"
msgstr ""

#: ../../language/language.md:428
msgid ""
"for k, v in { \"x\": 1, \"y\": 2, \"z\": 3 } {\n"
"  println(k)\n"
"  println(v)\n"
"}\n"
msgstr ""

#: ../../language/language.md:435
msgid ""
"Another example of `for .. in` with two loop variables is traversing an "
"array while keeping track of array index:"
msgstr ""

#: ../../language/language.md:437
msgid ""
"fn main {\n"
"  for index, elem in [4, 5, 6] {\n"
"    let i = index + 1\n"
"    println(\"The \\{i}-th element of the array is \\{elem}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:445
msgid ""
"The 1-th element of the array is 4\n"
"The 2-th element of the array is 5\n"
"The 3-th element of the array is 6\n"
msgstr ""

#: ../../language/language.md:449
msgid ""
"Control flow operations such as `return`, `break` and error handling are "
"supported in the body of `for .. in` loop:"
msgstr ""

#: ../../language/language.md:451
msgid ""
"fn main {\n"
"  let map = { \"x\": 1, \"y\": 2, \"z\": 3, \"w\": 4 }\n"
"  for k, v in map {\n"
"    if k == \"y\" {\n"
"      continue\n"
"    }\n"
"    println(\"\\{k}, \\{v}\")\n"
"    if k == \"z\" {\n"
"      break\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:459
msgid ""
"x, 1\n"
"z, 3\n"
msgstr ""

#: ../../language/language.md:463
msgid "If a loop variable is unused, it can be ignored with `_`."
msgstr ""

#: ../../language/language.md:465
msgid "Functional loop"
msgstr ""

#: ../../language/language.md:467
msgid ""
"Functional loop is a powerful feature in MoonBit that enables you to "
"write loops in a functional style."
msgstr ""

#: ../../language/language.md:469
msgid ""
"A functional loop consumes arguments and returns a value. It is defined "
"using the `loop` keyword, followed by its arguments and the loop body. "
"The loop body is a sequence of clauses, each of which consists of a "
"pattern and an expression. The clause whose pattern matches the input "
"will be executed, and the loop will return the value of the expression. "
"If no pattern matches, the loop will panic. Use the `continue` keyword "
"with arguments to start the next iteration of the loop. Use the `break` "
"keyword with arguments to return a value from the loop. The `break` "
"keyword can be omitted if the value is the last expression in the loop "
"body."
msgstr ""

#: ../../language/language.md:471
msgid ""
"test {\n"
"  fn sum(xs : @immut/list.T[Int]) -> Int {\n"
"    loop xs, 0 {\n"
"      Nil, acc => break acc // <=> Nil, acc => acc\n"
"      Cons(x, rest), acc => continue rest, x + acc\n"
"    }\n"
"  }\n"
"\n"
"  assert_eq!(sum(Cons(1, Cons(2, Cons(3, Nil)))), 6)\n"
"}\n"
msgstr ""

#: ../../language/language.md:477
msgid "Guard Statement"
msgstr ""

#: ../../language/language.md:479
msgid ""
"The `guard` statement is used to check a specified invariant. If the "
"condition of the invariant is satisfied, the program continues executing "
"the subsequent statements and returns. If the condition is not satisfied "
"(i.e., false), the code in the `else` block is executed and its "
"evaluation result is returned (the subsequent statements are skipped)."
msgstr ""

#: ../../language/language.md:484
msgid "guard index >= 0 && index < len else { abort(\"Index out of range\") }\n"
msgstr ""

#: ../../language/language.md:491
msgid ""
"The `guard` statement also supports pattern matching: in the following "
"example, `getProcessedText` assumes that the input `path` points to "
"resources that are all plain text, and it uses the `guard` statement to "
"ensure this invariant. Compared to using a `match` statement, the "
"subsequent processing of `text` can have one less level of indentation."
msgstr ""

#: ../../language/language.md:496
msgid ""
"enum Resource {\n"
"  Folder(Array[String])\n"
"  PlainText(String)\n"
"  JsonConfig(Json)\n"
"}\n"
"\n"
"fn getProcessedText(\n"
"  resources : Map[String, Resource],\n"
"  path : String\n"
") -> String!Error {\n"
"  guard let Some(PlainText(text)) = resources[path] else {\n"
"    None => fail!(\"\\{path} not found\")\n"
"    Some(Folder(_)) => fail!(\"\\{path} is a folder\")\n"
"    Some(JsonConfig(_)) => fail!(\"\\{path} is a json config\")\n"
"  }\n"
"  process(text)\n"
"}\n"
msgstr ""

#: ../../language/language.md:502
msgid ""
"When the `else` part is omitted, the program terminates if the condition "
"specified in the `guard` statement is not true or cannot be matched."
msgstr ""

#: ../../language/language.md:505
msgid ""
"guard condition  // <=> guard condition else { panic() }\n"
"guard let Some(x) = expr\n"
"// <=> guard let Some(x) = expr else { _ => panic() }\n"
msgstr ""

#: ../../language/language.md:512
msgid "Iterator"
msgstr ""

#: ../../language/language.md:514
msgid ""
"An iterator is an object that traverse through a sequence while providing"
" access to its elements. Traditional OO languages like Java's "
"`Iterator<T>` use `next()` `hasNext()` to step through the iteration "
"process, whereas functional languages (JavaScript's `forEach`, Lisp's "
"`mapcar`) provides a high-order function which takes an operation and a "
"sequence then consumes the sequence with that operation being applied to "
"the sequence. The former is called _external iterator_ (visible to user) "
"and the latter is called _internal iterator_ (invisible to user)."
msgstr ""

#: ../../language/language.md:522
msgid ""
"The built-in type `Iter[T]` is MoonBit's internal iterator "
"implementation. Almost all built-in sequential data structures have "
"implemented `Iter`:"
msgstr ""

#: ../../language/language.md:525
msgid ""
"fn filter_even(l : Array[Int]) -> Array[Int] {\n"
"  let l_iter : Iter[Int] = l.iter()\n"
"  l_iter.filter(fn { x => (x & 1) == 0 }).collect()\n"
"}\n"
"\n"
"fn fact(n : Int) -> Int {\n"
"  let start = 1\n"
"  let range : Iter[Int] = start.until(n)\n"
"  range.fold(Int::op_mul, init=start)\n"
"}\n"
msgstr ""

#: ../../language/language.md:531
msgid "Commonly used methods include:"
msgstr ""

#: ../../language/language.md:533
msgid ""
"`each`: Iterates over each element in the iterator, applying some "
"function to each element."
msgstr ""

#: ../../language/language.md:534
msgid ""
"`fold`: Folds the elements of the iterator using the given function, "
"starting with the given initial value."
msgstr ""

#: ../../language/language.md:535
msgid "`collect`: Collects the elements of the iterator into an array."
msgstr ""

#: ../../language/language.md:537
msgid ""
"`filter`: _lazy_ Filters the elements of the iterator based on a "
"predicate function."
msgstr ""

#: ../../language/language.md:538
msgid ""
"`map`: _lazy_ Transforms the elements of the iterator using a mapping "
"function."
msgstr ""

#: ../../language/language.md:539
msgid ""
"`concat`: _lazy_ Combines two iterators into one by appending the "
"elements of the second iterator to the first."
msgstr ""

#: ../../language/language.md:541
msgid ""
"Methods like `filter` `map` are very common on a sequence object e.g. "
"Array. But what makes `Iter` special is that any method that constructs a"
" new `Iter` is _lazy_ (i.e. iteration doesn't start on call because it's "
"wrapped inside a function), as a result of no allocation for intermediate"
" value. That's what makes `Iter` superior for traversing through "
"sequence: no extra cost. MoonBit encourages user to pass an `Iter` across"
" functions instead of the sequence object itself."
msgstr ""

#: ../../language/language.md:549
msgid ""
"Pre-defined sequence structures like `Array` and its iterators should be "
"enough to use. But to take advantages of these methods when used with a "
"custom sequence with elements of type `S`, we will need to implement "
"`Iter`, namely, a function that returns an `Iter[S]`. Take `Bytes` as an "
"example:"
msgstr ""

#: ../../language/language.md:554
msgid ""
"fn iter(data : Bytes) -> Iter[Byte] {\n"
"  Iter::new(\n"
"    fn(visit : (Byte) -> IterResult) -> IterResult {\n"
"      for byte in data {\n"
"        if visit(byte) == IterEnd {\n"
"          break IterEnd\n"
"        }\n"
"      } else {\n"
"        IterContinue\n"
"      }\n"
"    },\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/language.md:560
msgid ""
"Almost all `Iter` implementations are identical to that of `Bytes`, the "
"only main difference being the code block that actually does the "
"iteration."
msgstr ""

#: ../../language/language.md:563
msgid "Implementation details"
msgstr ""

#: ../../language/language.md:565
msgid ""
"The type `Iter[T]` is basically a type alias for `((T) -> IterResult) -> "
"IterResult`, a higher-order function that takes an operation and "
"`IterResult` is an enum object that tracks the state of current iteration"
" which consists any of the 2 states:"
msgstr ""

#: ../../language/language.md:570
msgid "`IterEnd`: marking the end of an iteration"
msgstr ""

#: ../../language/language.md:571
msgid ""
"`IterContinue`: marking the end of an iteration is yet to be reached, "
"implying the iteration will still continue at this state."
msgstr ""

#: ../../language/language.md:573
msgid ""
"To put it simply, `Iter[T]` takes a function `(T) -> IterResult` and use "
"it to transform `Iter[T]` itself to a new state of type `IterResult`. "
"Whether that state being `IterEnd` `IterContinue` depends on the "
"function."
msgstr ""

#: ../../language/language.md:577
msgid ""
"Iterator provides a unified way to iterate through data structures, and "
"they can be constructed at basically no cost: as long as `fn(yield)` "
"doesn't execute, the iteration process doesn't start."
msgstr ""

#: ../../language/language.md:581
msgid ""
"Internally a `Iter::run()` is used to trigger the iteration. Chaining all"
" sorts of `Iter` methods might be visually pleasing, but do notice the "
"heavy work underneath the abstraction."
msgstr ""

#: ../../language/language.md:585
msgid ""
"Thus, unlike an external iterator, once the iteration starts there's no "
"way to stop unless the end is reached. Methods such as `count()` which "
"counts the number of elements in a iterator looks like an `O(1)` "
"operation but actually has linear time complexity. Carefully use "
"iterators or performance issue might occur."
msgstr ""

#: ../../language/language.md:591
msgid "Built-in Data Structures"
msgstr ""

#: ../../language/language.md:593
msgid "Boolean"
msgstr ""

#: ../../language/language.md:595
msgid ""
"MoonBit has a built-in boolean type, which has two values: `true` and "
"`false`. The boolean type is used in conditional expressions and control "
"structures."
msgstr ""

#: ../../language/language.md:597
msgid ""
"let a = true\n"
"let b = false\n"
"let c = a && b\n"
"let d = a || b\n"
"let e = not(a)\n"
msgstr ""

#: ../../language/language.md:604
msgid "Number"
msgstr ""

#: ../../language/language.md:606
msgid "MoonBit have integer type and floating point type:"
msgstr ""

#: ../../language/language.md:597
msgid "type"
msgstr ""

#: ../../language/language.md:597 ../../language/language.md:683
msgid "description"
msgstr ""

#: ../../language/language.md:597
msgid "example"
msgstr ""

#: ../../language/language.md:597
msgid "`Int`"
msgstr ""

#: ../../language/language.md:597
msgid "32-bit signed integer"
msgstr ""

#: ../../language/language.md:597
msgid "`42`"
msgstr ""

#: ../../language/language.md:597
msgid "`Int64`"
msgstr ""

#: ../../language/language.md:597
msgid "64-bit signed integer"
msgstr ""

#: ../../language/language.md:597
msgid "`1000L`"
msgstr ""

#: ../../language/language.md:597
msgid "`UInt`"
msgstr ""

#: ../../language/language.md:597
msgid "32-bit unsigned integer"
msgstr ""

#: ../../language/language.md:597
msgid "`14U`"
msgstr ""

#: ../../language/language.md:597
msgid "`UInt64`"
msgstr ""

#: ../../language/language.md:597
msgid "64-bit unsigned integer"
msgstr ""

#: ../../language/language.md:597
msgid "`14UL`"
msgstr ""

#: ../../language/language.md:597
msgid "`Double`"
msgstr ""

#: ../../language/language.md:597
msgid "64-bit floating point, defined by IEEE754"
msgstr ""

#: ../../language/language.md:597
msgid "`3.14`"
msgstr ""

#: ../../language/language.md:597
msgid "`Float`"
msgstr ""

#: ../../language/language.md:597
msgid "32-bit floating point"
msgstr ""

#: ../../language/language.md:597
msgid "`(3.14 : Float)`"
msgstr ""

#: ../../language/language.md:597
msgid "`BigInt`"
msgstr ""

#: ../../language/language.md:597
msgid "represents numeric values larger than other types"
msgstr ""

#: ../../language/language.md:597
msgid "`10000000000000000000000N`"
msgstr ""

#: ../../language/language.md:618
msgid ""
"MoonBit also supports numeric literals, including decimal, binary, octal,"
" and hexadecimal numbers."
msgstr ""

#: ../../language/language.md:620
msgid ""
"To improve readability, you may place underscores in the middle of "
"numeric literals such as `1_000_000`. Note that underscores can be placed"
" anywhere within a number, not just every three digits."
msgstr ""

#: ../../language/language.md:622
msgid "There is nothing surprising about decimal numbers."
msgstr ""

#: ../../language/language.md:624
msgid ""
"let a = 1234\n"
"let b = 1_000_000 + a\n"
"// UInt : 0_U\n"
"let unsigned_num = 4_294_967_295U\n"
"// Int64 : 0_L\n"
"let large_num = 9_223_372_036_854_775_807L\n"
"// UInt64 : 0_UL\n"
"let unsigned_large_num = 18_446_744_073_709_551_615UL\n"
msgstr ""

#: ../../language/language.md:631
msgid ""
"A binary number has a leading zero followed by a letter \"B\", i.e. "
"`0b`/`0B`. Note that the digits after `0b`/`0B` must be `0` or `1`."
msgstr ""

#: ../../language/language.md:634
msgid ""
"let bin = 0b110010\n"
"let another_bin = 0B110010\n"
msgstr ""

#: ../../language/language.md:641
msgid ""
"An octal number has a leading zero followed by a letter \"O\", i.e. "
"`0o`/`0O`. Note that the digits after `0o`/`0O` must be in the range from"
" `0` through `7`:"
msgstr ""

#: ../../language/language.md:644
msgid ""
"let octal = 0o1234\n"
"let another_octal = 0O1234\n"
msgstr ""

#: ../../language/language.md:651
msgid ""
"A hexadecimal number has a leading zero followed by a letter \"X\", i.e. "
"`0x`/`0X`. Note that the digits after the `0x`/`0X` must be in the range "
"`0123456789ABCDEF`."
msgstr ""

#: ../../language/language.md:654
msgid ""
"let hex = 0XA\n"
"let another_hex = 0xA\n"
msgstr ""

#: ../../language/language.md:661
msgid "Overloaded int literal"
msgstr ""

#: ../../language/language.md:663
msgid ""
"When the expected type is known, MoonBit can automatically overload "
"integer literal, and there is no need to specify the type of number via "
"letter postfix:"
msgstr ""

#: ../../language/language.md:665
msgid ""
"let int : Int = 42\n"
"let uint : UInt = 42\n"
"let int64 : Int64 = 42\n"
"let double : Double = 42\n"
"let float : Float = 42\n"
"let bigint : BigInt = 42\n"
msgstr ""

#: ../../language/language.md:672
msgid "String"
msgstr ""

#: ../../language/language.md:674
msgid ""
"`String` holds a sequence of UTF-16 code units. You can use double quotes"
" to create a string, or use `#|` to write a multi-line string."
msgstr ""

#: ../../language/language.md:676
msgid ""
"let a = \"兔rabbit\"\n"
"println(a[0])\n"
"println(a[1])\n"
"let b =\n"
"  #| Hello\n"
"  #| MoonBit\\n\n"
"  #|\n"
"println(b)\n"
msgstr ""

#: ../../language/language.md:683
msgid ""
"'兔'\n"
"'r'\n"
" Hello\n"
" MoonBit\\n\n"
"\n"
msgstr ""

#: ../../language/language.md:687
msgid ""
"In double quotes string, a backslash followed by certain special "
"characters forms an escape sequence:"
msgstr ""

#: ../../language/language.md:683
msgid "escape sequences"
msgstr ""

#: ../../language/language.md:683
msgid "`\\n`,`\\r`,`\\t`,`\\b`"
msgstr ""

#: ../../language/language.md:683
msgid "New line, Carriage return, Horizontal tab, Backspace"
msgstr ""

#: ../../language/language.md:683
msgid "`\\\\`"
msgstr ""

#: ../../language/language.md:683
msgid "Backslash"
msgstr ""

#: ../../language/language.md:683
msgid "`\\x41`"
msgstr ""

#: ../../language/language.md:683
msgid "Hexadecimal escape sequence"
msgstr ""

#: ../../language/language.md:683
msgid "`\\o102`"
msgstr ""

#: ../../language/language.md:683
msgid "Octal escape sequence"
msgstr ""

#: ../../language/language.md:683
msgid "`\\u5154`,`\\u{1F600}`"
msgstr ""

#: ../../language/language.md:683
msgid "Unicode escape sequence"
msgstr ""

#: ../../language/language.md:697
msgid ""
"MoonBit supports string interpolation. It enables you to substitute "
"variables within interpolated strings. This feature simplifies the "
"process of constructing dynamic strings by directly embedding variable "
"values into the text. Variables used for string interpolation must "
"support the `to_string` method."
msgstr ""

#: ../../language/language.md:699
msgid ""
"let x = 42\n"
"println(\"The answer is \\{x}\")\n"
msgstr ""

#: ../../language/language.md:706
msgid ""
"Multi-line strings do not support interpolation by default, but you can "
"enable interpolation for a specific line by changing the leading `#|` to "
"`$|`:"
msgstr ""

#: ../../language/language.md:708
msgid ""
"let lang = \"MoonBit\"\n"
"let str =\n"
"  #| Hello\n"
"  #| ---\n"
"  $| \\{lang}\\n\n"
"  #| ---\n"
"println(str)\n"
msgstr ""

#: ../../language/language.md:715
msgid ""
" Hello\n"
" ---\n"
" MoonBit\n"
"\n"
" ---\n"
msgstr ""

#: ../../language/language.md:719
msgid "Char"
msgstr ""

#: ../../language/language.md:721
msgid "`Char` is an integer representing a Unicode code point."
msgstr ""

#: ../../language/language.md:723
msgid ""
"let a : Char = 'A'\n"
"let b = '\\x41'\n"
"let c = '兔'\n"
"let zero = '\\u{30}'\n"
"let zero = '\\u0030'\n"
msgstr ""

#: ../../language/language.md:730
msgid "Byte(s)"
msgstr ""

#: ../../language/language.md:732
msgid ""
"A byte literal in MoonBit is either a single ASCII character or a single "
"escape enclosed in single quotes `'`, and preceded by the character `b`. "
"Byte literals are of type `Byte`. For example:"
msgstr ""

#: ../../language/language.md:734
msgid ""
"fn main {\n"
"  let b1 : Byte = b'a'\n"
"  println(b1.to_int())\n"
"  let b2 = b'\\xff'\n"
"  println(b2.to_int())\n"
"}\n"
msgstr ""

#: ../../language/language.md:742
msgid ""
"97\n"
"255\n"
msgstr ""

#: ../../language/language.md:746
msgid ""
"A `Bytes` is a sequence of bytes. Similar to byte, bytes literals have "
"the form of `b\"...\"`. For example:"
msgstr ""

#: ../../language/language.md:748
msgid ""
"test {\n"
"  let b1 : Bytes = b\"abcd\"\n"
"  let b2 = b\"\\x61\\x62\\x63\\x64\"\n"
"  assert_eq!(b1, b2)\n"
"}\n"
msgstr ""

#: ../../language/language.md:754
msgid "Tuple"
msgstr ""

#: ../../language/language.md:756
msgid ""
"A tuple is a collection of finite values constructed using round brackets"
" `()` with the elements separated by commas `,`. The order of elements "
"matters; for example, `(1,true)` and `(true,1)` have different types. "
"Here's an example:"
msgstr ""

#: ../../language/language.md:758
msgid ""
"fn main {\n"
"  fn pack(\n"
"    a : Bool,\n"
"    b : Int,\n"
"    c : String,\n"
"    d : Double\n"
"  ) -> (Bool, Int, String, Double) {\n"
"    (a, b, c, d)\n"
"  }\n"
"\n"
"  let quad = pack(false, 100, \"text\", 3.14)\n"
"  let (bool_val, int_val, str, float_val) = quad\n"
"  println(\"\\{bool_val} \\{int_val} \\{str} \\{float_val}\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:766
msgid "false 100 text 3.14\n"
msgstr ""

#: ../../language/language.md:770
msgid "Tuples can be accessed via pattern matching or index:"
msgstr ""

#: ../../language/language.md:772
msgid ""
"test {\n"
"  let t = (1, 2)\n"
"  let (x1, y1) = t\n"
"  let x2 = t.0\n"
"  let y2 = t.1\n"
"  assert_eq!(x1, x2)\n"
"  assert_eq!(y1, y2)\n"
"}\n"
msgstr ""

#: ../../language/language.md:778
msgid "Array"
msgstr ""

#: ../../language/language.md:780
msgid ""
"An array is a finite sequence of values constructed using square brackets"
" `[]`, with elements separated by commas `,`. For example:"
msgstr ""

#: ../../language/language.md:782
msgid "let numbers = [1, 2, 3, 4]\n"
msgstr ""

#: ../../language/language.md:789
msgid ""
"You can use `numbers[x]` to refer to the xth element. The index starts "
"from zero."
msgstr ""

#: ../../language/language.md:791
msgid ""
"test {\n"
"  let numbers = [1, 2, 3, 4]\n"
"  let a = numbers[2]\n"
"  numbers[3] = 5\n"
"  let b = a + numbers[3]\n"
"  assert_eq!(b, 8)\n"
"}\n"
msgstr ""

#: ../../language/language.md:798
msgid "Map"
msgstr ""

#: ../../language/language.md:800
msgid ""
"MoonBit provides a hash map data structure that preserves insertion orde "
"called `Map` in its standard library. `Map`s can be created via a "
"convenient literal syntax:"
msgstr ""

#: ../../language/language.md:803
msgid "let map : Map[String, Int] = { \"x\": 1, \"y\": 2, \"z\": 3 }\n"
msgstr ""

#: ../../language/language.md:809
msgid ""
"Currently keys in map literal syntax must be constant. `Map`s can also be"
" destructed elegantly with pattern matching, see [Map Pattern](#map-"
"pattern)."
msgstr ""

#: ../../language/language.md:811
msgid "Json literal"
msgstr ""

#: ../../language/language.md:813
msgid ""
"MoonBit supports convenient json handling by overloading literals. When "
"the expected type of an expression is `Json`, number, string, array and "
"map literals can be directly used to create json data:"
msgstr ""

#: ../../language/language.md:816
msgid ""
"let moon_pkg_json_example : Json = {\n"
"  \"import\": [\"moonbitlang/core/builtin\", "
"\"moonbitlang/core/coverage\"],\n"
"  \"test-import\": [\"moonbitlang/core/random\"],\n"
"}\n"
msgstr ""

#: ../../language/language.md:822
msgid "Json values can be pattern matched too, see [Json Pattern](#json-pattern)."
msgstr ""

#: ../../language/language.md:824
msgid "Variable Binding"
msgstr ""

#: ../../language/language.md:826
msgid ""
"A variable can be declared as mutable or immutable using `let mut` or "
"`let`, respectively. A mutable variable can be reassigned to a new value,"
" while an immutable one cannot."
msgstr ""

#: ../../language/language.md:828
msgid ""
"let zero = 0\n"
"\n"
"fn main {\n"
"  let mut i = 10\n"
"  i = 20\n"
"  println(i + zero)\n"
"}\n"
msgstr ""

#: ../../language/language.md:832
msgid "Data Types"
msgstr ""

#: ../../language/language.md:834
msgid "There are two ways to create new data types: `struct` and `enum`."
msgstr ""

#: ../../language/language.md:836
msgid "Struct"
msgstr ""

#: ../../language/language.md:838
msgid ""
"In MoonBit, structs are similar to tuples, but their fields are indexed "
"by field names. A struct can be constructed using a struct literal, which"
" is composed of a set of labeled values and delimited with curly "
"brackets. The type of a struct literal can be automatically inferred if "
"its fields exactly match the type definition. A field can be accessed "
"using the dot syntax `s.f`. If a field is marked as mutable using the "
"keyword `mut`, it can be assigned a new value."
msgstr ""

#: ../../language/language.md:840
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  mut email : String\n"
"}\n"
msgstr ""

#: ../../language/language.md:846
msgid ""
"fn main {\n"
"  let u = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  u.email = \"john@doe.name\"\n"
"  println(u.id)\n"
"  println(u.name)\n"
"  println(u.email)\n"
"}\n"
msgstr ""

#: ../../language/language.md:854
msgid ""
"0\n"
"John Doe\n"
"john@doe.name\n"
msgstr ""

#: ../../language/language.md:858
msgid "Constructing Struct with Shorthand"
msgstr ""

#: ../../language/language.md:860
msgid ""
"If you already have some variable like `name` and `email`, it's redundant"
" to repeat those names when constructing a struct. You can use shorthand "
"instead, it behaves exactly the same:"
msgstr ""

#: ../../language/language.md:862
msgid ""
"let name = \"john\"\n"
"let email = \"john@doe.com\"\n"
"let u = { id: 0, name, email }\n"
msgstr ""

#: ../../language/language.md:869
msgid "Struct Update Syntax"
msgstr ""

#: ../../language/language.md:871
msgid ""
"It's useful to create a new struct based on an existing one, but with "
"some fields updated."
msgstr ""

#: ../../language/language.md:873
msgid ""
"fn main {\n"
"  let user = { id: 0, name: \"John Doe\", email: \"john@doe.com\" }\n"
"  let updated_user = { ..user, email: \"john@doe.name\" }\n"
"  println(\n"
"    $|{ id: \\{user.id}, name: \\{user.name}, email: \\{user.email} }\n"
"    $|{ id: \\{updated_user.id}, name: \\{updated_user.name}, email: "
"\\{updated_user.email} }\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/language.md:881
msgid ""
"{ id: 0, name: John Doe, email: john@doe.com }\n"
"{ id: 0, name: John Doe, email: john@doe.name }\n"
msgstr ""

#: ../../language/language.md:885
msgid "Enum"
msgstr ""

#: ../../language/language.md:887
msgid ""
"Enum types are similar to algebraic data types in functional languages. "
"Users familiar with C/C++ may prefer calling it tagged union."
msgstr ""

#: ../../language/language.md:889
msgid ""
"An enum can have a set of cases (constructors). Constructor names must "
"start with capitalized letter. You can use these names to construct "
"corresponding cases of an enum, or checking which branch an enum value "
"belongs to in pattern matching:"
msgstr ""

#: ../../language/language.md:891
msgid ""
"/// An enum type that represents the ordering relation between two "
"values,\n"
"/// with three cases \"Smaller\", \"Greater\" and \"Equal\"\n"
"enum Relation {\n"
"  Smaller\n"
"  Greater\n"
"  Equal\n"
"}\n"
msgstr ""

#: ../../language/language.md:897
msgid ""
"/// compare the ordering relation between two integers\n"
"fn compare_int(x : Int, y : Int) -> Relation {\n"
"  if x < y {\n"
"    // when creating an enum, if the target type is known, \n"
"    // you can write the constructor name directly\n"
"    Smaller\n"
"  } else if x > y {\n"
"    // but when the target type is not known,\n"
"    // you can always use `TypeName::Constructor` to create an enum "
"unambiguously\n"
"    Relation::Greater\n"
"  } else {\n"
"    Equal\n"
"  }\n"
"}\n"
"\n"
"/// output a value of type `Relation`\n"
"fn print_relation(r : Relation) -> Unit {\n"
"  // use pattern matching to decide which case `r` belongs to\n"
"  match r {\n"
"    // during pattern matching, if the type is known, \n"
"    // writing the name of constructor is sufficient\n"
"    Smaller => println(\"smaller!\")\n"
"    // but you can use the `TypeName::Constructor` syntax \n"
"    // for pattern matching as well\n"
"    Relation::Greater => println(\"greater!\")\n"
"    Equal => println(\"equal!\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:904
msgid ""
"fn main {\n"
"  print_relation(compare_int(0, 1))\n"
"  print_relation(compare_int(1, 1))\n"
"  print_relation(compare_int(2, 1))\n"
"}\n"
msgstr ""

#: ../../language/language.md:912
msgid ""
"smaller!\n"
"equal!\n"
"greater!\n"
msgstr ""

#: ../../language/language.md:916
msgid ""
"Enum cases can also carry payload data. Here's an example of defining an "
"integer list type using enum:"
msgstr ""

#: ../../language/language.md:918
msgid ""
"enum List {\n"
"  Nil\n"
"  // constructor `Cons` carries additional payload: the first element of "
"the list,\n"
"  // and the remaining parts of the list\n"
"  Cons(Int, List)\n"
"}\n"
msgstr ""

#: ../../language/language.md:924
msgid ""
"// In addition to binding payload to variables,\n"
"// you can also continue matching payload data inside constructors.\n"
"// Here's a function that decides if a list contains only one element\n"
"fn is_singleton(l : List) -> Bool {\n"
"  match l {\n"
"    // This branch only matches values of shape `Cons(_, Nil)`, \n"
"    // i.e. lists of length 1\n"
"    Cons(_, Nil) => true\n"
"    // Use `_` to match everything else\n"
"    _ => false\n"
"  }\n"
"}\n"
"\n"
"fn print_list(l : List) -> Unit {\n"
"  // when pattern-matching an enum with payload,\n"
"  // in additional to deciding which case a value belongs to\n"
"  // you can extract the payload data inside that case\n"
"  match l {\n"
"    Nil => println(\"nil\")\n"
"    // Here `x` and `xs` are defining new variables \n"
"    // instead of referring to existing variables,\n"
"    // if `l` is a `Cons`, then the payload of `Cons` \n"
"    // (the first element and the rest of the list)\n"
"    // will be bind to `x` and `xs\n"
"    Cons(x, xs) => {\n"
"      println(\"\\{x},\")\n"
"      print_list(xs)\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:931
msgid ""
"fn main {\n"
"  // when creating values using `Cons`, the payload of by `Cons` must be "
"provided\n"
"  let l : List = Cons(1, Cons(2, Nil))\n"
"  println(is_singleton(l))\n"
"  print_list(l)\n"
"}\n"
msgstr ""

#: ../../language/language.md:939
msgid ""
"false\n"
"1,\n"
"2,\n"
"nil\n"
msgstr ""

#: ../../language/language.md:943
msgid "Constructor with labelled arguments"
msgstr ""

#: ../../language/language.md:945
msgid "Enum constructors can have labelled argument:"
msgstr ""

#: ../../language/language.md:947
msgid ""
"enum E {\n"
"  // `x` and `y` are labelled argument\n"
"  C(x~ : Int, y~ : Int)\n"
"}\n"
msgstr ""

#: ../../language/language.md:953
msgid ""
"// pattern matching constructor with labelled arguments\n"
"fn f(e : E) -> Unit {\n"
"  match e {\n"
"    // `label=pattern`\n"
"    C(x=0, y=0) => println(\"0!\")\n"
"    // `x~` is an abbreviation for `x=x`\n"
"    // Unmatched labelled arguments can be omitted via `..`\n"
"    C(x~, ..) => println(x)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:960
msgid ""
"fn main {\n"
"  f(C(x=0, y=0))\n"
"  let x = 0\n"
"  f(C(x~, y=1)) // <=> C(x=x, y=1)\n"
"}\n"
msgstr ""

#: ../../language/language.md:968
msgid ""
"0!\n"
"0\n"
msgstr ""

#: ../../language/language.md:972
msgid ""
"It is also possible to access labelled arguments of constructors like "
"accessing struct fields in pattern matching:"
msgstr ""

#: ../../language/language.md:974
msgid ""
"enum Object {\n"
"  Point(x~ : Double, y~ : Double)\n"
"  Circle(x~ : Double, y~ : Double, radius~ : Double)\n"
"}\n"
"\n"
"type! NotImplementedError  derive(Show)\n"
"\n"
"fn distance_with(self : Object, other : Object) -> "
"Double!NotImplementedError {\n"
"  match (self, other) {\n"
"    // For variables defined via `Point(..) as p`,\n"
"    // the compiler knows it must be of constructor `Point`,\n"
"    // so you can access fields of `Point` directly via `p.x`, `p.y` etc."
"\n"
"    (Point(_) as p1, Point(_) as p2) => {\n"
"      let dx = p2.x - p1.x\n"
"      let dy = p2.y - p1.y\n"
"      (dx * dx + dy * dy).sqrt()\n"
"    }\n"
"    (Point(_), Circle(_)) | (Circle(_), Point(_)) | (Circle(_), "
"Circle(_)) =>\n"
"      raise NotImplementedError\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:980
msgid ""
"fn main {\n"
"  let p1 : Object = Point(x=0, y=0)\n"
"  let p2 : Object = Point(x=3, y=4)\n"
"  let c1 : Object = Circle(x=0, y=0, radius=2)\n"
"  try {\n"
"    println(p1.distance_with!(p2))\n"
"    println(p1.distance_with!(c1))\n"
"  } catch {\n"
"    e => println(e)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:988
msgid ""
"5\n"
"NotImplementedError\n"
msgstr ""

#: ../../language/language.md:992
msgid "Constructor with mutable fields"
msgstr ""

#: ../../language/language.md:994
msgid ""
"It is also possible to define mutable fields for constructor. This is "
"especially useful for defining imperative data structures:"
msgstr ""

#: ../../language/language.md:996
msgid ""
"// A set implemented using mutable binary search tree.\n"
"struct Set[X] {\n"
"  mut root : Tree[X]\n"
"}\n"
"\n"
"fn Set::insert[X : Compare](self : Set[X], x : X) -> Unit {\n"
"  self.root = self.root.insert(x, parent=Nil)\n"
"}\n"
"\n"
"// A mutable binary search tree with parent pointer\n"
"enum Tree[X] {\n"
"  Nil\n"
"  // only labelled arguments can be mutable\n"
"  Node(\n"
"    mut value~ : X,\n"
"    mut left~ : Tree[X],\n"
"    mut right~ : Tree[X],\n"
"    mut parent~ : Tree[X]\n"
"  )\n"
"}\n"
"\n"
"// In-place insert a new element to a binary search tree.\n"
"// Return the new tree root\n"
"fn Tree::insert[X : Compare](\n"
"  self : Tree[X],\n"
"  x : X,\n"
"  parent~ : Tree[X]\n"
") -> Tree[X] {\n"
"  match self {\n"
"    Nil => Node(value=x, left=Nil, right=Nil, parent~)\n"
"    Node(_) as node => {\n"
"      let order = x.compare(node.value)\n"
"      if order == 0 {\n"
"        // mutate the field of a constructor\n"
"        node.value = x\n"
"      } else if order < 0 {\n"
"        // cycle between `node` and `node.left` created here\n"
"        node.left = node.left.insert(x, parent=node)\n"
"      } else {\n"
"        node.right = node.right.insert(x, parent=node)\n"
"      }\n"
"      // The tree is non-empty, so the new root is just the original tree"
"\n"
"      node\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1002
msgid "Newtype"
msgstr ""

#: ../../language/language.md:1004
msgid "MoonBit supports a special kind of enum called newtype:"
msgstr ""

#: ../../language/language.md:1006
msgid ""
"// `UserId` is a fresh new type different from `Int`, \n"
"// and you can define new methods for `UserId`, etc.\n"
"// But at the same time, the internal representation of `UserId` \n"
"// is exactly the same as `Int`\n"
"type UserId Int\n"
"\n"
"type UserName String\n"
msgstr ""

#: ../../language/language.md:1012
msgid ""
"Newtypes are similar to enums with only one constructor (with the same "
"name as the newtype itself). So, you can use the constructor to create "
"values of newtype, or use pattern matching to extract the underlying "
"representation of a newtype:"
msgstr ""

#: ../../language/language.md:1014
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let name : UserName = UserName(\"John Doe\")\n"
"  let UserId(uid) = id // uid : Int\n"
"  let UserName(uname) = name // uname: String\n"
"  println(uid)\n"
"  println(uname)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1022
msgid ""
"1\n"
"John Doe\n"
msgstr ""

#: ../../language/language.md:1026
msgid ""
"Besides pattern matching, you can also use `._` to extract the internal "
"representation of newtypes:"
msgstr ""

#: ../../language/language.md:1028
msgid ""
"fn main {\n"
"  let id : UserId = UserId(1)\n"
"  let uid : Int = id._\n"
"  println(uid)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1036
msgid "1\n"
msgstr ""

#: ../../language/language.md:1040
msgid "Type alias"
msgstr ""

#: ../../language/language.md:1041
msgid "MoonBit supports type alias via the syntax `typealias Name = TargetType`:"
msgstr ""

#: ../../language/language.md:1043
msgid ""
"pub typealias Index = Int\n"
"\n"
"// type alias are private by default\n"
"typealias MapString[X] = Map[String, X]\n"
msgstr ""

#: ../../language/language.md:1049
msgid ""
"unlike all other kinds of type declaration above, type alias does not "
"define a new type, it is merely a type macro that behaves exactly the "
"same as its definition. So for example one cannot define new methods or "
"implement traits for a type alias."
msgstr ""

#: ../../language/language.md:1053
msgid ""
"Type alias can be used to perform incremental code refactor. For example,"
" if you want to move a type `T` from `@pkgA` to `@pkgB`, you can leave a "
"type alias `typealias T = @pkgB.T` in `@pkgA`, and **incrementally** port"
" uses of `@pkgA.T` to `@pkgB.T`. The type alias can be removed after all "
"uses of `@pkgA.T` is migrated to `@pkgB.T`."
msgstr ""

#: ../../language/language.md:1058
msgid "Pattern Matching"
msgstr ""

#: ../../language/language.md:1060
msgid ""
"We have shown a use case of pattern matching for enums, but pattern "
"matching is not restricted to enums. For example, we can also match "
"expressions against Boolean values, numbers, characters, strings, tuples,"
" arrays, and struct literals. Since there is only one case for those "
"types other than enums, we can pattern match them using `let` binding "
"instead of `match` expressions. Note that the scope of bound variables in"
" `match` is limited to the case where the variable is introduced, while "
"`let` binding will introduce every variable to the current scope. "
"Furthermore, we can use underscores `_` as wildcards for the values we "
"don't care about, use `..` to ignore remaining fields of struct or "
"elements of array."
msgstr ""

#: ../../language/language.md:1062
msgid ""
"let id = match u {\n"
"  { id, name: _, email: _ } => id\n"
"}\n"
"\n"
"// <=>\n"
"let { id, name: _, email: _ } = u\n"
"\n"
"// <=>\n"
"let { id, .. } = u\n"
msgstr ""

#: ../../language/language.md:1069
msgid ""
"test {\n"
"  let ary = [1, 2, 3, 4]\n"
"  let [a, b, ..] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 1, b = 2\")\n"
"  let [.., a, b] = ary\n"
"  inspect!(\"a = \\{a}, b = \\{b}\", content=\"a = 3, b = 4\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:1075
msgid ""
"There are some other useful constructs in pattern matching. For example, "
"we can use `as` to give a name to some pattern, and we can use `|` to "
"match several cases at once. A variable name can only be bound once in a "
"single pattern, and the same set of variables should be bound on both "
"sides of `|` patterns."
msgstr ""

#: ../../language/language.md:1077
msgid ""
"match expr {\n"
"  Lit(n) as a => ...\n"
"  Add(e1, e2) | Mul(e1, e2) => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1084
msgid "Range Pattern"
msgstr ""

#: ../../language/language.md:1085
msgid ""
"For builtin integer types and `Char`, MoonBit allows matching whether the"
" value falls in a specific range. Range patterns have the form `a..<b` or"
" `a..=b`, where `..<` means the upper bound is exclusive, and `..=` means"
" inclusive upper bound. `a` and `b` can be one of:"
msgstr ""

#: ../../language/language.md:1089
msgid "literal"
msgstr ""

#: ../../language/language.md:1090
msgid "named constant declared with `const`"
msgstr ""

#: ../../language/language.md:1091
msgid "`_`, meaning the pattern has no restriction on this side"
msgstr ""

#: ../../language/language.md:1093
msgid "Here are some examples:"
msgstr ""

#: ../../language/language.md:1095
msgid ""
"const Zero = 0\n"
"\n"
"fn sign(x : Int) -> Int {\n"
"  match x {\n"
"    _..<Zero => -1\n"
"    Zero => 0\n"
"    1..<_ => 1\n"
"  }\n"
"}\n"
"\n"
"fn classify_char(c : Char) -> String {\n"
"  match c {\n"
"    'a'..='z' => \"lowercase\"\n"
"    'A'..='Z' => \"uppercase\"\n"
"    '0'..='9' => \"digit\"\n"
"    _ => \"other\"\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1102
msgid "Map Pattern"
msgstr ""

#: ../../language/language.md:1104
msgid ""
"MoonBit allows convenient matching on map-like data structures. Inside a "
"map pattern, the `key : value` syntax will match if `key` exists in the "
"map, and match the value of `key` with pattern `value`. The `key? : "
"value` syntax will match no matter `key` exists or not, and `value` will "
"be matched against `map[key]` (an optional)."
msgstr ""

#: ../../language/language.md:1108
msgid ""
"match map {\n"
"  // matches if any only if \"b\" exists in `map`\n"
"  { \"b\": _ } => ...\n"
"  // matches if and only if \"b\" does not exist in `map` and \"a\" "
"exists in `map`.\n"
"  // When matches, bind the value of \"a\" in `map` to `x`\n"
"  { \"b\"? : None, \"a\": x } => ...\n"
"  // compiler reports missing case: { \"b\"? : None, \"a\"? : None }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1115
msgid ""
"To match a data type `T` using map pattern, `T` must have a method "
"`op_get(Self, K) -> Option[V]` for some type `K` and `V`."
msgstr ""

#: ../../language/language.md:1116
msgid "Currently, the key part of map pattern must be a constant"
msgstr ""

#: ../../language/language.md:1117
msgid "Map patterns are always open: unmatched keys are silently ignored"
msgstr ""

#: ../../language/language.md:1118
msgid ""
"Map pattern will be compiled to efficient code: every key will be fetched"
" at most once"
msgstr ""

#: ../../language/language.md:1120
msgid "Json Pattern"
msgstr ""

#: ../../language/language.md:1122
msgid ""
"When the matched value has type `Json`, literal patterns can be used "
"directly:"
msgstr ""

#: ../../language/language.md:1124
msgid ""
"match json {\n"
"  { \"version\": \"1.0.0\", \"import\": [..] as imports } => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1131
msgid "Operators"
msgstr ""

#: ../../language/language.md:1133
msgid "Operator Overloading"
msgstr ""

#: ../../language/language.md:1135
msgid ""
"MoonBit supports operator overloading of builtin operators via methods. "
"The method name corresponding to a operator `<op>` is `op_<op>`. For "
"example:"
msgstr ""

#: ../../language/language.md:1137
msgid ""
"struct T {\n"
"  x : Int\n"
"}\n"
"\n"
"fn op_add(self : T, other : T) -> T {\n"
"  { x: self.x + other.x }\n"
"}\n"
"\n"
"test {\n"
"  let a = { x: 0 }\n"
"  let b = { x: 2 }\n"
"  assert_eq!((a + b).x, 2)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1143
msgid "Another example about `op_get` and `op_set`:"
msgstr ""

#: ../../language/language.md:1145
msgid ""
"struct Coord {\n"
"  mut x : Int\n"
"  mut y : Int\n"
"} derive(Show)\n"
"\n"
"fn op_get(self : Coord, key : String) -> Int {\n"
"  match key {\n"
"    \"x\" => self.x\n"
"    \"y\" => self.y\n"
"  }\n"
"}\n"
"\n"
"fn op_set(self : Coord, key : String, val : Int) -> Unit {\n"
"  match key {\n"
"    \"x\" => self.x = val\n"
"    \"y\" => self.y = val\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1151
msgid ""
"fn main {\n"
"  let c = { x: 1, y: 2 }\n"
"  println(c)\n"
"  println(c[\"y\"])\n"
"  c[\"x\"] = 23\n"
"  println(c)\n"
"  println(c[\"x\"])\n"
"}\n"
msgstr ""

#: ../../language/language.md:1159
msgid ""
"{x: 1, y: 2}\n"
"2\n"
"{x: 23, y: 2}\n"
"23\n"
msgstr ""

#: ../../language/language.md:1163
msgid "Currently, the following operators can be overloaded:"
msgstr ""

#: ../../language/language.md:1159
msgid "Operator Name"
msgstr ""

#: ../../language/language.md:1159
msgid "Method Name"
msgstr ""

#: ../../language/language.md:1159
msgid "`+`"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_add`"
msgstr ""

#: ../../language/language.md:1159
msgid "`-`"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_sub`"
msgstr ""

#: ../../language/language.md:1159
msgid "`*`"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_mul`"
msgstr ""

#: ../../language/language.md:1159
msgid "`/`"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_div`"
msgstr ""

#: ../../language/language.md:1159
msgid "`%`"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_mod`"
msgstr ""

#: ../../language/language.md:1159
msgid "`=`"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_equal`"
msgstr ""

#: ../../language/language.md:1159 ../../language/language.md:1222
msgid "`<<`"
msgstr ""

#: ../../language/language.md:1159 ../../language/language.md:1222
msgid "`op_shl`"
msgstr ""

#: ../../language/language.md:1159 ../../language/language.md:1222
msgid "`>>`"
msgstr ""

#: ../../language/language.md:1159 ../../language/language.md:1222
msgid "`op_shr`"
msgstr ""

#: ../../language/language.md:1159
msgid "`-` (unary)"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_neg`"
msgstr ""

#: ../../language/language.md:1159
msgid "`_[_]` (get item)"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_get`"
msgstr ""

#: ../../language/language.md:1159
msgid "`_[_] = _` (set item)"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_set`"
msgstr ""

#: ../../language/language.md:1159
msgid "`_[_:_]` (view)"
msgstr ""

#: ../../language/language.md:1159
msgid "`op_as_view`"
msgstr ""

#: ../../language/language.md:1180
msgid "Pipe operator"
msgstr ""

#: ../../language/language.md:1182
msgid ""
"MoonBit provides a convenient pipe operator `|>`, which can be used to "
"chain regular function calls:"
msgstr ""

#: ../../language/language.md:1184
msgid ""
"5 |> ignore // <=> ignore(5)\n"
"[] |> push(5) // <=> push([], 5)\n"
"1\n"
"|> add(5) // <=> add(1, 5)\n"
"|> ignore // <=> ignore(add(1, 5))\n"
msgstr ""

#: ../../language/language.md:1191
msgid "Cascade Operator"
msgstr ""

#: ../../language/language.md:1193
msgid ""
"The cascade operator `..` is used to perform a series of mutable "
"operations on the same value consecutively. The syntax is as follows:"
msgstr ""

#: ../../language/language.md:1196
msgid "x..f()\n"
msgstr ""

#: ../../language/language.md:1203
msgid "`x..f()..g()` is equivalent to `{x.f(); x.g(); x}`."
msgstr ""

#: ../../language/language.md:1205
msgid ""
"Consider the following scenario: for a `StringBuilder` type that has "
"methods like `write_string`, `write_char`, `write_object`, etc., we often"
" need to perform a series of operations on the same `StringBuilder` "
"value:"
msgstr ""

#: ../../language/language.md:1209
msgid ""
"let builder = StringBuilder::new()\n"
"builder.write_char('a')\n"
"builder.write_char('a')\n"
"builder.write_object(1001)\n"
"builder.write_string(\"abcdef\")\n"
"let result = builder.to_string()\n"
msgstr ""

#: ../../language/language.md:1216
msgid ""
"To avoid repetitive typing of `builder`, its methods are often designed "
"to return `self` itself, allowing operations to be chained using the `.` "
"operator. To distinguish between immutable and mutable operations, in "
"MoonBit, for all methods that return `Unit`, cascade operator can be used"
" for consecutive operations without the need to modify the return type of"
" the methods."
msgstr ""

#: ../../language/language.md:1222
msgid ""
"let result = StringBuilder::new()\n"
"  ..write_char('a')\n"
"  ..write_char('a')\n"
"  ..write_object(1001)\n"
"  ..write_string(\"abcdef\")\n"
"  .to_string()\n"
msgstr ""

#: ../../language/language.md:1229
msgid "Bitwise Operator"
msgstr ""

#: ../../language/language.md:1231
msgid "MoonBit supports C-Style bitwise operators."
msgstr ""

#: ../../language/language.md:1222
msgid "Operator"
msgstr ""

#: ../../language/language.md:1222
msgid "Perform"
msgstr ""

#: ../../language/language.md:1222
msgid "`&`"
msgstr ""

#: ../../language/language.md:1222
msgid "`land`"
msgstr ""

#: ../../language/language.md:1222
msgid "`|`"
msgstr ""

#: ../../language/language.md:1222
msgid "`lor`"
msgstr ""

#: ../../language/language.md:1222
msgid "`^`"
msgstr ""

#: ../../language/language.md:1222
msgid "`lxor`"
msgstr ""

#: ../../language/language.md:1241
msgid "Error Handling"
msgstr ""

#: ../../language/language.md:1243
msgid "Error types"
msgstr ""

#: ../../language/language.md:1245
msgid ""
"The error values used in MoonBit must have an error type. An error type "
"can be defined in the following forms:"
msgstr ""

#: ../../language/language.md:1248
msgid ""
"type! E1 Int // error type E1 has one constructor E1 with an Int payload\n"
"\n"
"type! E2  // error type E2 has one constructor E2 with no payload\n"
"\n"
"type! E3 { // error type E3 has three constructors like a normal enum "
"type\n"
"  A\n"
"  B(Int, x~ : String)\n"
"  C(mut x~ : String, Char, y~ : Bool)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1255
msgid ""
"The return type of a function can include an error type to indicate that "
"the function might return an error. For example, the following function "
"`div` might return an error of type `DivError`:"
msgstr ""

#: ../../language/language.md:1259
msgid ""
"type! DivError String\n"
"\n"
"fn div(x : Int, y : Int) -> Int!DivError {\n"
"  if y == 0 {\n"
"    raise DivError(\"division by zero\")\n"
"  }\n"
"  x / y\n"
"}\n"
msgstr ""

#: ../../language/language.md:1266
msgid ""
"Here, the keyword `raise` is used to interrupt the function execution and"
" return an error."
msgstr ""

#: ../../language/language.md:1269
msgid "The Default Error Type"
msgstr ""

#: ../../language/language.md:1271
msgid ""
"MoonBit provides a default error type `Error` that can be used when the "
"concrete error type is not important. For convenience, you can annotate "
"the function name or the return type with the suffix `!` to indicate that"
" the `Error` type is used. For example, the following function signatures"
" are equivalent:"
msgstr ""

#: ../../language/language.md:1276
msgid ""
"fn f() -> Unit! {\n"
"  ...\n"
"}\n"
"\n"
"fn g!() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn h() -> Unit!Error {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1283
msgid ""
"For anonymous function and matrix function, you can annotate the keyword "
"`fn` with the `!` suffix to achieve that. For example,"
msgstr ""

#: ../../language/language.md:1286
msgid ""
"type! IntError Int\n"
"\n"
"fn h(f : (Int) -> Int!, x : Int) -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"fn g() -> Unit {\n"
"  let _ = h(fn! { x => raise IntError(x) }, 0)\n"
"  let _ = h(fn!(x) { raise IntError(x) }, 0)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/language.md:1292
msgid ""
"As shown in the above example, the error types defined by `type!` can be "
"used as value of the type `Error` when the error is raised."
msgstr ""

#: ../../language/language.md:1295
msgid ""
"Note that only error types or the type `Error` can be used as errors. For"
" functions that are generic in the error type, you can use the `Error` "
"bound to do that. For example,"
msgstr ""

#: ../../language/language.md:1299
msgid ""
"// Result::unwrap_or_error\n"
"fn unwrap_or_error[T, E : Error](result : Result[T, E]) -> T!E {\n"
"  match result {\n"
"    Ok(x) => x\n"
"    Err(e) => raise e\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1305
msgid ""
"Since the type `Error` can include multiple error types, pattern matching"
" on the `Error` type must use the wildcard `_` to match all error types. "
"For example,"
msgstr ""

#: ../../language/language.md:1308
msgid ""
"type! E4\n"
"\n"
"type! E5\n"
"\n"
"fn f(e : Error) -> Unit {\n"
"  match e {\n"
"    E4 => println(\"E1\")\n"
"    E5 => println(\"E2\")\n"
"    _ => println(\"unknown error\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1314
msgid "Handling Errors"
msgstr ""

#: ../../language/language.md:1316
msgid "There are three ways to handle errors:"
msgstr ""

#: ../../language/language.md:1318
msgid ""
"Append `!` after the function name in a function application to rethrow "
"the error directly in case of an error, for example:"
msgstr ""

#: ../../language/language.md:1321
msgid ""
"fn div_reraise(x : Int, y : Int) -> Int!DivError {\n"
"  div!(x, y) // Rethrow the error if `div` raised an error\n"
"}\n"
msgstr ""

#: ../../language/language.md:1327
msgid ""
"Append `?` after the function name to convert the result into a first-"
"class value of the `Result` type, for example:"
msgstr ""

#: ../../language/language.md:1330
msgid ""
"test {\n"
"  let res = div?(6, 3)\n"
"  inspect!(res, content=\"Ok(2)\")\n"
"  let res = div?(6, 0)\n"
"  inspect!(\n"
"    res,\n"
"    content=\n"
"      #|Err(\"division by zero\")\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/language.md:1336
msgid "Use `try` and `catch` to catch and handle errors, for example:"
msgstr ""

#: ../../language/language.md:1338
msgid ""
"fn main {\n"
"try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  DivError(s) => println(s)\n"
"} else {\n"
"  v => println(v)\n"
"}\n"
"}\n"
msgstr ""

#: ../../language/language.md:1347
#, fuzzy
msgid "division by zero\n"
msgstr "示例：除零"

#: ../../language/language.md:1351
msgid ""
"Here, `try` is used to call a function that might throw an error, and "
"`catch` is used to match and handle the caught error. If no error is "
"caught, the catch block will not be executed and the `else` block will be"
" executed instead."
msgstr ""

#: ../../language/language.md:1355
msgid ""
"The `else` block can be omitted if no action is needed when no error is "
"caught. For example:"
msgstr ""

#: ../../language/language.md:1358
msgid ""
"try {\n"
"  println(div!(42, 0))\n"
"} catch {\n"
"  _ => println(\"Error\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:1365
msgid ""
"The `catch` keyword is optional, and when the body of `try` is a simple "
"expression, the curly braces can be omitted. For example:"
msgstr ""

#: ../../language/language.md:1368
msgid ""
"let a = try {\n"
"  div!(42, 0)\n"
"} catch {\n"
"  _ => 0\n"
"}\n"
"println(a)\n"
msgstr ""

#: ../../language/language.md:1375
msgid ""
"The `!` and `?` attributes can also be used on method invocation and pipe"
" operator. For example:"
msgstr ""

#: ../../language/language.md:1378
msgid ""
"type T Int\n"
"\n"
"type! E Int derive(Show)\n"
"\n"
"fn k(self : T) -> Unit!E {\n"
"  ...\n"
"}\n"
"\n"
"fn l() -> Unit!E {\n"
"  let x = T(42)\n"
"  k!(x)\n"
"  x.k!()\n"
"  x |> k!()\n"
"}\n"
msgstr ""

#: ../../language/language.md:1384
msgid ""
"However for infix operators such as `+` `*` that may raise an error, the "
"original form has to be used, e.g. `x.op_add!(y)`, `x.op_mul!(y)`."
msgstr ""

#: ../../language/language.md:1387
msgid ""
"Additionally, if the return type of a function includes an error type, "
"the function call must use `!` or `?` for error handling, otherwise the "
"compiler will report an error."
msgstr ""

#: ../../language/language.md:1391
msgid "Error Inference"
msgstr ""

#: ../../language/language.md:1393
msgid ""
"Within a `try` block, several different kinds of errors can be raised. "
"When that happens, the compiler will use the type `Error` as the common "
"error type. Accordingly, the handler must use the wildcard `_` to make "
"sure all errors are caught. For example,"
msgstr ""

#: ../../language/language.md:1398
msgid ""
"fn f1() -> Unit!E1 {\n"
"  ...\n"
"}\n"
"\n"
"fn f2() -> Unit!E2 {\n"
"  ...\n"
"}\n"
"\n"
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch {\n"
"  E1(_) => ...\n"
"  E2 => ...\n"
"  _ => ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1405
msgid ""
"You can also use `catch!` to rethrow the uncaught errors for convenience."
" This is useful when you only want to handle a specific error and rethrow"
" others. For example,"
msgstr ""

#: ../../language/language.md:1409
msgid ""
"try {\n"
"  f1!()\n"
"  f2!()\n"
"} catch! {\n"
"  E1(_) => ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1416
msgid "Generics"
msgstr ""

#: ../../language/language.md:1418
msgid ""
"Generics are supported in top-level function and data type definitions. "
"Type parameters can be introduced within square brackets. We can rewrite "
"the aforementioned data type `List` to add a type parameter `T` to obtain"
" a generic version of lists. We can then define generic functions over "
"lists like `map` and `reduce`."
msgstr ""

#: ../../language/language.md:1420
msgid ""
"enum List[T] {\n"
"  Nil\n"
"  Cons(T, List[T])\n"
"}\n"
"\n"
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
msgstr ""

#: ../../language/language.md:1424
msgid "Access Control"
msgstr ""

#: ../../language/language.md:1426
msgid ""
"By default, all function definitions and variable bindings are "
"_invisible_ to other packages. You can use the `pub` modifier before "
"toplevel `let`/`fn` to make them public."
msgstr ""

#: ../../language/language.md:1429
msgid "There are four different kinds of visibility for types in MoonBit:"
msgstr ""

#: ../../language/language.md:1431
msgid ""
"private type, declared with `priv`, completely invisible to the outside "
"world"
msgstr ""

#: ../../language/language.md:1432
msgid ""
"abstract type, which is the default visibility for types. Only the name "
"of an abstract type is visible outside, the internal representation of "
"the type is hidden"
msgstr ""

#: ../../language/language.md:1433
msgid ""
"readonly types, declared with `pub(readonly)`. The internal "
"representation of readonly types are visible outside, but users can only "
"read the values of these types from outside, construction and mutation "
"are not allowed"
msgstr ""

#: ../../language/language.md:1435
msgid ""
"fully public types, declared with `pub(all)`. The outside world can "
"freely construct, modify and read values of these types"
msgstr ""

#: ../../language/language.md:1437
msgid ""
"Currently, the semantic of `pub` is `pub(all)`. But in the future, the "
"meaning of `pub` will be ported to `pub(readonly)`. In addition to the "
"visibility of the type itself, the fields of a public `struct` can be "
"annotated with `priv`, which will hide the field from the outside world "
"completely. Note that `struct`s with private fields cannot be constructed"
" directly outside, but you can update the public fields using the "
"functional struct update syntax."
msgstr ""

#: ../../language/language.md:1443
msgid ""
"Readonly types is a very useful feature, inspired by [private "
"types](https://v2.ocaml.org/manual/privatetypes.html) in OCaml. In short,"
" values of `pub(readonly)` types can be destructed by pattern matching "
"and the dot syntax, but cannot be constructed or mutated in other "
"packages. Note that there is no restriction within the same package where"
" `pub(readonly)` types are defined."
msgstr ""

#: ../../language/language.md:1447
msgid ""
"// Package A\n"
"pub(readonly) struct RO {\n"
"  field: Int\n"
"}\n"
"test {\n"
"  let r = { field: 4 }       // OK\n"
"  let r = { ..r, field: 8 }  // OK\n"
"}\n"
"\n"
"// Package B\n"
"fn println(r : RO) -> Unit {\n"
"  println(\"{ field: \")\n"
"  println(r.field)  // OK\n"
"  println(\" }\")\n"
"}\n"
"test {\n"
"  let r : RO = { field: 4 }  // ERROR: Cannot create values of the public"
" read-only type RO!\n"
"  let r = { ..r, field: 8 }  // ERROR: Cannot mutate a public read-only "
"field!\n"
"}\n"
msgstr ""

#: ../../language/language.md:1469
msgid ""
"Access control in MoonBit adheres to the principle that a `pub` type, "
"function, or variable cannot be defined in terms of a private type. This "
"is because the private type may not be accessible everywhere that the "
"`pub` entity is used. MoonBit incorporates sanity checks to prevent the "
"occurrence of use cases that violate this principle."
msgstr ""

#: ../../language/language.md:1472
msgid ""
"pub struct S {\n"
"  x: T1  // OK\n"
"  y: T2  // OK\n"
"  z: T3  // ERROR: public field has private type `T3`!\n"
"}\n"
"\n"
"// ERROR: public function has private parameter type `T3`!\n"
"pub fn f1(_x: T3) -> T1 { T1::A(0) }\n"
"// ERROR: public function has private return type `T3`!\n"
"pub fn f2(_x: T1) -> T3 { T3::A(0) }\n"
"// OK\n"
"pub fn f3(_x: T1) -> T1 { T1::A(0) }\n"
"\n"
"pub let a: T3  // ERROR: public variable has private type `T3`!\n"
msgstr ""

#: ../../language/language.md:1489
msgid "Method system"
msgstr ""

#: ../../language/language.md:1491
msgid ""
"MoonBit supports methods in a different way from traditional object-"
"oriented languages. A method in MoonBit is just a toplevel function "
"associated with a type constructor. Methods can be defined using the "
"syntax `fn TypeName::method_name(...) -> ...`:"
msgstr ""

#: ../../language/language.md:1493 ../../language/language.md:1535
msgid ""
"pub(all) enum List[X] {\n"
"  Nil\n"
"  Cons(X, List[X])\n"
"}\n"
"\n"
"pub fn List::concat[X](xs : List[List[X]]) -> List[X] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1499
msgid ""
"As a convenient shorthand, when the first parameter of a function is "
"named `self`, MoonBit automatically defines the function as a method of "
"the type of `self`:"
msgstr ""

#: ../../language/language.md:1501
msgid ""
"fn List::map[X, Y](xs : List[X], f : (X) -> Y) -> List[Y] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1507
msgid "is equivalent to:"
msgstr ""

#: ../../language/language.md:1509
msgid ""
"fn map[X, Y](self : List[X], f : (X) -> Y) -> List[Y] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1515
msgid ""
"Methods are just regular functions owned by a type constructor. So when "
"there is no ambiguity, methods can be called using regular function call "
"syntax directly:"
msgstr ""

#: ../../language/language.md:1517
msgid ""
"let xs : List[List[_]] = { ... }\n"
"let ys = concat(xs)\n"
msgstr ""

#: ../../language/language.md:1524
msgid ""
"Unlike regular functions, methods support overloading: different types "
"can define methods of the same name. If there are multiple methods of the"
" same name (but for different types) in scope, one can still call them by"
" explicitly adding a `TypeName::` prefix:"
msgstr ""

#: ../../language/language.md:1526
msgid ""
"struct T1 {\n"
"  x1 : Int\n"
"}\n"
"\n"
"fn T1::default() -> T1 {\n"
"  { x1: 0 }\n"
"}\n"
"\n"
"struct T2 {\n"
"  x2 : Int\n"
"}\n"
"\n"
"fn T2::default() -> T2 {\n"
"  { x2: 0 }\n"
"}\n"
"\n"
"test {\n"
"  // default() : T1::default() ? T2::default()?\n"
"  let t1 = T1::default()\n"
"  let t2 = T2::default()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/language.md:1533
msgid ""
"When the first parameter of a method is also the type it belongs to, "
"methods can be called using dot syntax `x.method(...)`. MoonBit "
"automatically finds the correct method based on the type of `x`, there is"
" no need to write the type name and even the package name of the method:"
msgstr ""

#: ../../language/language.md:1541
msgid "using package with alias list"
msgstr ""

#: ../../language/language.md:1541
msgid ""
"fn f() -> Unit {\n"
"  let xs : @list.List[@list.List[Unit]] = Nil\n"
"  let _ = xs.concat()\n"
"  let _ = @list.List::concat(xs)\n"
"  let _ = @list.concat(xs)\n"
"\n"
"}\n"
msgstr ""

#: ../../language/language.md:1549
msgid ""
"The highlighted line is only possible when there is no ambiguity in "
"`@list`."
msgstr ""

#: ../../language/language.md:1551
msgid "View"
msgstr ""

#: ../../language/language.md:1553
msgid ""
"Analogous to `slice` in other languages, the view is a reference to a "
"specific segment of collections. You can use `data[start:end]` to create "
"a view of array `data`, referencing elements from `start` to `end` "
"(exclusive). Both `start` and `end` indices can be omitted."
msgstr ""

#: ../../language/language.md:1558
msgid ""
"test {\n"
"  let xs = [0, 1, 2, 3, 4, 5]\n"
"  let s1 : ArrayView[Int] = xs[2:]\n"
"  inspect!(s1, content=\"[2, 3, 4, 5]\")\n"
"  inspect!(xs[:4], content=\"[0, 1, 2, 3]\")\n"
"  inspect!(xs[2:5], content=\"[2, 3, 4]\")\n"
"  inspect!(xs[:], content=\"[0, 1, 2, 3, 4, 5]\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:1564
msgid ""
"By implementing `op_as_view` method, you can also create a view for a "
"user-defined type. Here is an example:"
msgstr ""

#: ../../language/language.md:1566
msgid ""
"type DataView String\n"
"\n"
"struct Data {}\n"
"\n"
"fn Data::op_as_view(_self : Data, start~ : Int = 0, end? : Int) -> "
"DataView {\n"
"  \"[\\{start}, \\{end.or(100)})\"\n"
"}\n"
"\n"
"test {\n"
"  let data = Data::{  }\n"
"  inspect!(data[:]._, content=\"[0, 100)\")\n"
"  inspect!(data[2:]._, content=\"[2, 100)\")\n"
"  inspect!(data[:5]._, content=\"[0, 5)\")\n"
"  inspect!(data[2:5]._, content=\"[2, 5)\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:1572
msgid "Trait system"
msgstr ""

#: ../../language/language.md:1574
msgid ""
"MoonBit features a structural trait system for overloading/ad-hoc "
"polymorphism. Traits declare a list of operations, which must be supplied"
" when a type wants to implement the trait. Traits can be declared as "
"follows:"
msgstr ""

#: ../../language/language.md:1576
msgid ""
"trait I {\n"
"  method_(Int) -> Int\n"
"}\n"
msgstr ""

#: ../../language/language.md:1582
msgid ""
"In the body of a trait definition, a special type `Self` is used to refer"
" to the type that implements the trait."
msgstr ""

#: ../../language/language.md:1584
msgid ""
"To implement a trait, a type must provide all the methods required by the"
" trait. Implementation for trait methods can be provided via the syntax "
"`impl Trait for Type with method_name(...) { ... }`, for example:"
msgstr ""

#: ../../language/language.md:1587
msgid ""
"trait MyShow {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"struct MyType {}\n"
"\n"
"impl MyShow for MyType with to_string(self) { ... }\n"
"\n"
"struct MyContainer[T] {}\n"
"\n"
"// trait implementation with type parameters.\n"
"// `[X : Show]` means the type parameter `X` must implement `Show`,\n"
"// this will be covered later.\n"
"impl[X : MyShow] MyShow for MyContainer[X] with to_string(self) { ... }\n"
msgstr ""

#: ../../language/language.md:1593
msgid ""
"Type annotation can be omitted for trait `impl`: MoonBit will "
"automatically infer the type based on the signature of `Trait::method` "
"and the self type."
msgstr ""

#: ../../language/language.md:1595
msgid ""
"The author of the trait can also define default implementations for some "
"methods in the trait, for example:"
msgstr ""

#: ../../language/language.md:1597
msgid ""
"trait J {\n"
"  f(Self) -> Unit\n"
"  f_twice(Self) -> Unit\n"
"}\n"
"\n"
"impl J with f_twice(self) {\n"
"  self.f()\n"
"  self.f()\n"
"}\n"
msgstr ""

#: ../../language/language.md:1603
msgid ""
"Implementers of trait `I` don't have to provide an implementation for "
"`f_twice`: to implement `I`, only `f` is necessary. They can always "
"override the default implementation with an explicit `impl I for Type "
"with f_twice`, if desired, though."
msgstr ""

#: ../../language/language.md:1606
msgid ""
"If an explicit `impl` or default implementation is not found, trait "
"method resolution falls back to regular methods. This allows types to "
"implement a trait implicitly, hence allowing different packages to work "
"together without seeing or depending on each other. For example, the "
"following trait is automatically implemented for builtin number types "
"such as `Int` and `Double`:"
msgstr ""

#: ../../language/language.md:1610
msgid ""
"trait Number {\n"
"  op_add(Self, Self) -> Self\n"
"  op_mul(Self, Self) -> Self\n"
"}\n"
msgstr ""

#: ../../language/language.md:1616
msgid ""
"When declaring a generic function, the type parameters can be annotated "
"with the traits they should implement, allowing the definition of "
"constrained generic functions. For example:"
msgstr ""

#: ../../language/language.md:1618
msgid ""
"fn square[N : Number](x : N) -> N {\n"
"  x * x // <=> x.op_mul(x)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1624
msgid ""
"Without the `Number` requirement, the expression `x * x` in `square` will"
" result in a method/operator not found error. Now, the function `square` "
"can be called with any type that implements `Number`, for example:"
msgstr ""

#: ../../language/language.md:1626
msgid ""
"struct Point {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Show)\n"
"\n"
"impl Number for Point with op_add(self, other) {\n"
"  { x: self.x + other.x, y: self.y + other.y }\n"
"}\n"
"\n"
"impl Number for Point with op_mul(self, other) {\n"
"  { x: self.x * other.x, y: self.y * other.y }\n"
"}\n"
"\n"
"test {\n"
"  assert_eq!(square(2), 4)\n"
"  assert_eq!(square(1.5), 2.25)\n"
"  assert_eq!(square(Point::{ x: 2, y: 3 }), { x: 4, y: 9 })\n"
"}\n"
msgstr ""

#: ../../language/language.md:1632
msgid "MoonBit provides the following useful builtin traits:"
msgstr ""

#: ../../language/language.md:1636
msgid ""
"trait Eq {\n"
"  op_equal(Self, Self) -> Bool\n"
"}\n"
"\n"
"trait Compare : Eq {\n"
"  // `0` for equal, `-1` for smaller, `1` for greater\n"
"  compare(Self, Self) -> Int\n"
"}\n"
"\n"
"trait Hash {\n"
"  hash(Self) -> Int\n"
"}\n"
"\n"
"trait Show {\n"
"  // writes a string representation of `Self` into a `Logger`\n"
"  output(Self, Logger) -> Unit\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"trait Default {\n"
"  default() -> Self\n"
"}\n"
msgstr ""

#: ../../language/language.md:1661
msgid "Invoke trait methods directly"
msgstr ""

#: ../../language/language.md:1662
msgid ""
"Methods of a trait can be called directly via `Trait::method`. MoonBit "
"will infer the type of `Self` and check if `Self` indeed implements "
"`Trait`, for example:"
msgstr ""

#: ../../language/language.md:1664
msgid ""
"test {\n"
"  assert_eq!(Show::to_string(42), \"42\")\n"
"  assert_eq!(Compare::compare(1.0, 2.5), -1)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1670
msgid ""
"Trait implementations can also be invoked via dot syntax, with the "
"following restrictions:"
msgstr ""

#: ../../language/language.md:1672
msgid ""
"if a regular method is present, the regular method is always favored when"
" using dot syntax"
msgstr ""

#: ../../language/language.md:1673
msgid ""
"only trait implementations that are located in the package of the self "
"type can be invoked via dot syntax"
msgstr ""

#: ../../language/language.md:1674
msgid ""
"if there are multiple trait methods (from different traits) with the same"
" name available, an ambiguity error is reported"
msgstr ""

#: ../../language/language.md:1675
msgid ""
"if neither of the above two rules apply, trait `impl`s in current package"
" will also be searched for dot syntax. This allows extending a foreign "
"type locally."
msgstr ""

#: ../../language/language.md:1677
msgid ""
"these `impl`s can only be called via dot syntax locally, even if they are"
" public."
msgstr ""

#: ../../language/language.md:1679
msgid ""
"The above rules ensures that MoonBit's dot syntax enjoys good property "
"while being flexible. For example, adding a new dependency never break "
"existing code with dot syntax due to ambiguity. These rules also make "
"name resolution of MoonBit extremely simple: the method called via dot "
"syntax must always come from current package or the package of the type!"
msgstr ""

#: ../../language/language.md:1684
msgid "Here's an example of calling trait `impl` with dot syntax:"
msgstr ""

#: ../../language/language.md:1686
msgid ""
"struct MyCustomType {}\n"
"\n"
"impl Show for MyCustomType with output(self, logger) { ... }\n"
"\n"
"fn f() -> Unit {\n"
"  let x = MyCustomType::{  }\n"
"  let _ = x.to_string()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/language.md:1692
msgid "Access control of methods and trait implementations"
msgstr ""

#: ../../language/language.md:1694
msgid ""
"To make the trait system coherent (i.e. there is a globally unique "
"implementation for every `Type: Trait` pair), and prevent third-party "
"packages from modifying behavior of existing programs by accident, "
"MoonBit employs the following restrictions on who can define "
"methods/implement traits for types:"
msgstr ""

#: ../../language/language.md:1698
msgid ""
"_only the package that defines a type can define methods for it_. So one "
"cannot define new methods or override old methods for builtin and foreign"
" types."
msgstr ""

#: ../../language/language.md:1699
msgid ""
"_only the package of the type or the package of the trait can define an "
"implementation_. For example, only `@pkg1` and `@pkg2` are allowed to "
"write `impl @pkg1.Trait for @pkg2.Type`."
msgstr ""

#: ../../language/language.md:1702
msgid ""
"The second rule above allows one to add new functionality to a foreign "
"type by defining a new trait and implementing it. This makes MoonBit's "
"trait & method system flexible while enjoying good coherence property."
msgstr ""

#: ../../language/language.md:1705
msgid "Visibility of traits and sealed traits"
msgstr ""

#: ../../language/language.md:1706
msgid ""
"There are four visibility for traits, just like `struct` and `enum`: "
"private, abstract, readonly and fully public. Private traits are declared"
" with `priv trait`, and they are completely invisible from outside. "
"Abstract trait is the default visibility. Only the name of the trait is "
"visible from outside, and the methods in the trait are not exposed. "
"Readonly traits are declared with `pub(readonly) trait`, their methods "
"can be involked from outside, but only the current package can add new "
"implementation for readonly traits. Finally, fully public traits are "
"declared with `pub(open) trait`, they are open to new implementations "
"outside current package, and their methods can be freely used. Currently,"
" `pub trait` defaults to `pub(open) trait`. But in the future, the "
"semantic of `pub trait` will be ported to `pub(readonly)`."
msgstr ""

#: ../../language/language.md:1713
msgid ""
"Abstract and readonly traits are sealed, because only the package "
"defining the trait can implement them. Implementing a sealed (abstract or"
" readonly) trait outside its package result in compiler error. If you are"
" the owner of a sealed trait, and you want to make some implementation "
"available to users of your package, make sure there is at least one "
"declaration of the form `impl Trait for Type with ...` in your package. "
"Implementations with only regular method and default implementations will"
" not be available outside."
msgstr ""

#: ../../language/language.md:1719
msgid "Here's an example of abstract trait:"
msgstr ""

#: ../../language/language.md:1722
msgid ""
"trait Number {\n"
" op_add(Self, Self) -> Self\n"
" op_sub(Self, Self) -> Self\n"
"}\n"
"\n"
"fn add[N : Number](x : X, y: X) -> X {\n"
"  Number::op_add(x, y)\n"
"}\n"
"\n"
"fn sub[N : Number](x : X, y: X) -> X {\n"
"  Number::op_sub(x, y)\n"
"}\n"
"\n"
"impl Number for Int with op_add(x, y) { x + y }\n"
"impl Number for Int with op_sub(x, y) { x - y }\n"
"\n"
"impl Number for Double with op_add(x, y) { x + y }\n"
"impl Number for Double with op_sub(x, y) { x - y }\n"
msgstr ""

#: ../../language/language.md:1743
msgid "From outside this package, users can only see the following:"
msgstr ""

#: ../../language/language.md:1745
msgid ""
"trait Number\n"
"\n"
"fn op_add[N : Number](x : N, y : N) -> N\n"
"fn op_sub[N : Number](x : N, y : N) -> N\n"
"\n"
"impl Number for Int\n"
"impl Number for Double\n"
msgstr ""

#: ../../language/language.md:1755
msgid ""
"The author of `Number` can make use of the fact that only `Int` and "
"`Double` can ever implement `Number`, because new implementations are not"
" allowed outside."
msgstr ""

#: ../../language/language.md:1758
msgid "Automatically derive builtin traits"
msgstr ""

#: ../../language/language.md:1760
msgid "MoonBit can automatically derive implementations for some builtin traits:"
msgstr ""

#: ../../language/language.md:1762
msgid ""
"struct T {\n"
"  x : Int\n"
"  y : Int\n"
"} derive(Eq, Compare, Show, Default)\n"
"\n"
"test {\n"
"  let t1 = T::default()\n"
"  let t2 = T::{ x: 1, y: 1 }\n"
"  inspect!(t1, content=\"{x: 0, y: 0}\")\n"
"  inspect!(t2, content=\"{x: 1, y: 1}\")\n"
"  assert_not_eq!(t1, t2)\n"
"  assert_true!(t1 < t2)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1768
msgid "Trait objects"
msgstr ""

#: ../../language/language.md:1770
msgid ""
"MoonBit supports runtime polymorphism via trait objects. If `t` is of "
"type `T`, which implements trait `I`, one can pack the methods of `T` "
"that implements `I`, together with `t`, into a runtime object via `t as "
"I`. Trait object erases the concrete type of a value, so objects created "
"from different concrete types can be put in the same data structure and "
"handled uniformly:"
msgstr ""

#: ../../language/language.md:1777
msgid ""
"trait Animal {\n"
"  speak(Self) -> String\n"
"}\n"
"\n"
"type Duck String\n"
"\n"
"fn Duck::make(name : String) -> Duck {\n"
"  Duck(name)\n"
"}\n"
"\n"
"fn speak(self : Duck) -> String {\n"
"  \"\\{self._}: quack!\"\n"
"}\n"
"\n"
"type Fox String\n"
"\n"
"fn Fox::make(name : String) -> Fox {\n"
"  Fox(name)\n"
"}\n"
"\n"
"fn Fox::speak(_self : Fox) -> String {\n"
"  \"What does the fox say?\"\n"
"}\n"
"\n"
"test {\n"
"  let duck1 = Duck::make(\"duck1\")\n"
"  let duck2 = Duck::make(\"duck2\")\n"
"  let fox1 = Fox::make(\"fox1\")\n"
"  let animals : Array[Animal] = [\n"
"    duck1 as Animal,\n"
"    duck2 as Animal,\n"
"    fox1 as Animal,\n"
"  ]\n"
"  inspect!(\n"
"    animals.map(fn(animal) { animal.speak() }),\n"
"    content=\n"
"      #|[\"duck1: quack!\", \"duck2: quack!\", \"What does the fox "
"say?\"]\n"
"    ,\n"
"  )\n"
"}\n"
msgstr ""

#: ../../language/language.md:1783
msgid ""
"Not all traits can be used to create objects. \"object-safe\" traits' "
"methods must satisfy the following conditions:"
msgstr ""

#: ../../language/language.md:1786
msgid "`Self` must be the first parameter of a method"
msgstr ""

#: ../../language/language.md:1787
msgid ""
"There must be only one occurrence of `Self` in the type of the method "
"(i.e. the first parameter)"
msgstr ""

#: ../../language/language.md:1789
msgid ""
"Users can define new methods for trait objects, just like defining new "
"methods for structs and enums:"
msgstr ""

#: ../../language/language.md:1791
msgid ""
"trait Logger {\n"
"  write_string(Self, String) -> Unit\n"
"}\n"
"\n"
"trait CanLog {\n"
"  log(Self, Logger) -> Unit\n"
"}\n"
"\n"
"fn Logger::write_object[Obj : CanLog](self : Logger, obj : Obj) -> Unit {"
"\n"
"  obj.log(self)\n"
"}\n"
"\n"
"// use the new method to simplify code\n"
"impl[A : CanLog, B : CanLog] CanLog for (A, B) with log(self, logger) {\n"
"  let (a, b) = self\n"
"  logger\n"
"  ..write_string(\"(\")\n"
"  ..write_object(a)\n"
"  ..write_string(\", \")\n"
"  ..write_object(b)\n"
"  .write_string(\")\")\n"
"}\n"
msgstr ""

#: ../../language/language.md:1797
msgid "Test Blocks"
msgstr ""

#: ../../language/language.md:1799
msgid "MoonBit provides the test code block for writing test cases. For example:"
msgstr ""

#: ../../language/language.md:1801
msgid ""
"test \"test_name\" {\n"
"  assert_eq!(1 + 1, 2)\n"
"  assert_eq!(2 + 2, 4)\n"
"}\n"
msgstr ""

#: ../../language/language.md:1807
msgid ""
"A test code block is essentially a function that returns a `Unit` but may"
" throws a `String` on error, or `Unit!String` as one would see in its "
"signature at the position of return type. It is called during the "
"execution of `moon test` and outputs a test report through the build "
"system. The `assert_eq` function is from the standard library; if the "
"assertion fails, it prints an error message and terminates the test. The "
"string `\"test_name\"` is used to identify the test case and is optional."
" If it starts with `\"panic\"`, it indicates that the expected behavior "
"of the test is to trigger a panic, and the test will only pass if the "
"panic is triggered. For example:"
msgstr ""

#: ../../language/language.md:1809
msgid ""
"test \"panic_test\" {\n"
"  let _ : Int = Option::None.unwrap()\n"
"\n"
"}\n"
msgstr ""

#: ../../language/language.md:1815
msgid "Doc Comments"
msgstr ""

#: ../../language/language.md:1817
msgid ""
"Doc comments are comments prefix with `///` in each line in the leading "
"of toplevel structure like `fn`,`let`,`enum`,`struct`,`type`. The doc "
"comments contains a markdown text and several pragmas."
msgstr ""

#: ../../language/language.md:1819
msgid ""
"/// Return a new array with reversed elements.\n"
"///\n"
"/// # Example\n"
"///\n"
"/// ```\n"
"/// reverse([1,2,3,4]) |> println()\n"
"/// ```\n"
"fn reverse[T](xs : Array[T]) -> Array[T] {\n"
"  ...\n"
"}\n"
msgstr ""

#: ../../language/language.md:1825
msgid "Pragmas"
msgstr ""

#: ../../language/language.md:1827
msgid ""
"Pragmas are annotations inside doc comments. They all take the form `/// "
"@word ...`. The _word_ indicates the type of pragma and is followed "
"optionally by several _word_ or string literals. Pragmas do not normally "
"affect the meaning of programs. Unrecognized pragmas will be reported as "
"warnings."
msgstr ""

#: ../../language/language.md:1829
msgid "Alert Pragmas"
msgstr ""

#: ../../language/language.md:1831
msgid ""
"Alert pragmas in doc comments of functions will be reported when those "
"functions are referenced. This mechanism is a generalized way to mark "
"functions as `deprecated` or `unsafe`."
msgstr ""

#: ../../language/language.md:1833
msgid "It takes the form `@alert category \"alert message...\"`."
msgstr ""

#: ../../language/language.md:1835
msgid ""
"The category can be an arbitrary identifier. It allows configuration to "
"decide which alerts are enabled or turned into errors."
msgstr ""

#: ../../language/language.md:1838
msgid ""
"/// @alert deprecated \"Use foo2 instead\"\n"
"pub fn foo() -> Unit {\n"
"  ...\n"
"}\n"
"\n"
"/// @alert unsafe \"Div will cause an error when y is zero\"\n"
"pub fn div(x : Int, y : Int) -> Int {\n"
"  ...\n"
"}\n"
"\n"
"test {\n"
"  // Warning (Alert deprecated): Use foo2 instead\n"
"  foo()\n"
"  // Warning (Alert unsafe): Div will cause an error when y is zero\n"
"  div(1, 2) |> ignore\n"
"}\n"
msgstr ""

#: ../../language/language.md:1857
msgid "Special Syntax"
msgstr ""

#: ../../language/language.md:1859
msgid "TODO syntax"
msgstr ""

#: ../../language/language.md:1861
msgid ""
"The `todo` syntax (`...`) is a special construct used to mark sections of"
" code that are not yet implemented or are placeholders for future "
"functionality. For example:"
msgstr ""

#: ../../language/language.md:1863
msgid ""
"fn todo_in_func() -> Int {\n"
"  ...\n"
"}\n"
msgstr ""
