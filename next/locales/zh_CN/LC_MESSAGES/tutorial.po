# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2024, International Digital Economy Academy
# This file is distributed under the same license as the MoonBit Document
# package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2024.
msgid ""
msgstr ""
"Project-Id-Version: MoonBit Document \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2024-12-30 16:06+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: zh_CN\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.16.0\n"

#: ../../tutorial/example/gmachine/gmachine-1.md:1
msgid "G-Machine 1"
msgstr "G-Machine 第一部分"

#: ../../tutorial/example/gmachine/gmachine-1.md:3
msgid ""
"This article is the first in the series on implementing lazy evaluation "
"in MoonBit. In this article, we will exploring the purposes of lazy "
"evaluation and a typical abstract machine for lazy evaluation, the "
"G-Machine."
msgstr ""
"本文是关于在 MoonBit 中实现惰性求值的系列文章的第一篇。在本文中，我们将探讨惰性求值的目的以及用于惰性求值的典型抽象机器 "
"G-Machine。"

#: ../../tutorial/example/gmachine/gmachine-1.md:5
msgid "Higher-Order Functions and Performance Challenges"
msgstr "高阶函数和性能挑战"

#: ../../tutorial/example/gmachine/gmachine-1.md:7
msgid ""
"Higher-order functions such as `map` and `filter` often serve as many "
"people's first impression of functional programming (although it goes far"
" beyond these functions). They simplify many list processing tasks, but "
"another problem emerges: nesting these higher-order functions too deep "
"can lead to poor performance (because it requires multiple traversals of "
"the list)."
msgstr ""
"高阶函数，如 `map` 和 "
"`filter`，通常是许多人对函数式编程的第一印象（尽管函数式编程远不止于这些函数）。它们简化了许多列表处理任务，但另一个问题出现了：这些高阶函数嵌套太深可能会导致性能不佳（因为它需要多次遍历列表）。"

#: ../../tutorial/example/gmachine/gmachine-1.md:9
msgid ""
"To enhance code efficiency, some propose leveraging compiler "
"optimizations based on recurring patterns within higher-order functions. "
"For instance, by rewriting `map(f, map(g, list))` as："
msgstr "为了提高代码效率，一些人提出利用基于高阶函数内部重复模式的编译器优化。例如，将 `map(f, map(g, list))` 重写为："

#: ../../tutorial/example/gmachine/gmachine-1.md:11
msgid "map(fn (x) { f(g(x)) }, list)\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:15
msgid ""
"Nice try, but it's important to recognize that such optimization "
"techniques have inherent limitations, particularly when navigating more "
"complex scenarios. Consolidating all processes into a single function "
"might circumvent the need for repeated list traversals, yet it "
"detrimentally affects code readability and complicates the process of "
"making modifications. Could there be a more equitable solution that "
"balances efficiency with maintainability?"
msgstr "尝试不错，但重要的是要认识到这种优化技术具有固有的局限性，特别是在处理更复杂的场景时。将所有处理合并到一个函数中可以避免重复的列表遍历，但它会对降低代码的可读性，并使修改变得复杂。是否有一种更平衡的解决方案，兼顾效率和可维护性？"

#: ../../tutorial/example/gmachine/gmachine-1.md:17
msgid ""
"Lazy evaluation is a technique that can reduce unnecessary costs to some "
"extent in such scenarios. This strategy can be integrated into specific "
"data structures (for example, the Stream type added in Java 8, and the "
"stream in the earlier Scheme language), or the entire language can be "
"designed to be lazy (successful examples include the Miranda language of "
"the 1980s and later by Haskell and Clean languages)."
msgstr ""
"惰性求值是一种技术，可以在这种情况下在一定程度上减少不必要的成本。这种策略可以集成到特定的数据结构中（例如，Java 8 中添加的 Stream "
"类型，以及早期 Scheme 语言中的 stream），或者整个语言可以被设计为惰性（成功的例子包括 20 世纪 80 年代的 Miranda "
"语言，以及后来的 Haskell 和 Clean 语言）。"

#: ../../tutorial/example/gmachine/gmachine-1.md:19
msgid ""
"Let's first explore how lazy lists (`Stream`) can avoid multiple "
"traversals in such cases."
msgstr "首先，让我们探讨一下惰性列表（`Stream`）如何避免在这种情况下多次遍历。"

#: ../../tutorial/example/gmachine/gmachine-1.md:22
msgid "The `List[T]` here is a `typealias` of `@immut/list.T[T]`"
msgstr "这里的 `List[T]` 是 `@immut/list.T[T]` 的 `typealias`"

#: ../../tutorial/example/gmachine/gmachine-1.md:25
msgid "Lazy List Implementation"
msgstr "惰性列表实现"

#: ../../tutorial/example/gmachine/gmachine-1.md:27
msgid "First, let's define its type:"
msgstr "首先，让我们定义它的类型："

#: ../../tutorial/example/gmachine/gmachine-1.md:29
msgid ""
"enum Stream[T] {\n"
"  Empty\n"
"  Cons(T, () -> Stream[T])\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:36
msgid ""
"The only real difference between `Stream[T]` and `List[T]` is in the "
"`Cons`: the place holding the rest of the list is replaced with a "
"parameterless function (in jargon, called a thunk). This is a simple "
"implementation of lazy evaluation: wrapping things you don't want to "
"compute right away in a thunk."
msgstr ""
"`Stream[T]` 和 `List[T]` 之间唯一的真正区别在于 `Cons`：保存列表其余部分的位置被一个无参数函数（俗称为 "
"thunk）替换。这是惰性求值的一个简单实现：将不想立即计算的东西包装在一个 thunk 中。"

#: ../../tutorial/example/gmachine/gmachine-1.md:38
msgid "We also need a function to convert a regular list into a lazy list:"
msgstr "我们还需要一个函数将常规列表转换为惰性列表："

#: ../../tutorial/example/gmachine/gmachine-1.md:40
msgid ""
"fn Stream::from_list[T](l : List[T]) -> Stream[T] {\n"
"  match l {\n"
"    Nil => Empty\n"
"    Cons(x, xs) => Cons(x, fn () { Stream::from_list(xs) })\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:49
msgid ""
"This function does not need to traverse the entire list to convert it "
"into `Stream`. For operations that are not urgent (here, "
"`Stream::from_list(xs)`), we wrap them directly in a thunk and return. "
"The following `map` function will adopt this approach (though here, `xs` "
"is already a thunk)."
msgstr ""
"这个函数不需要遍历整个列表来将其转换为 `Stream`。对于不急着要结果的运算（这里是 "
"`Stream::from_list(xs)`），我们直接将它们包装在一个 thunk 中并返回。下面的 `map` "
"函数将采用这种方法（不过这里的 `xs` 已经是一个 thunk 了）。"

#: ../../tutorial/example/gmachine/gmachine-1.md:51
msgid ""
"fn map[X, Y](self : Stream[X], f : (X) -> Y) -> Stream[Y] {\n"
"  match self {\n"
"    Empty => Empty\n"
"    Cons(x, xs) => Cons(f(x), fn () { xs().map(f) })\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:60
msgid ""
"The `take` function is responsible for performing computations, and it "
"can extract n elements as needed."
msgstr "`take` 函数负责执行计算，它可以根据需要提取 n 个元素。"

#: ../../tutorial/example/gmachine/gmachine-1.md:62
msgid ""
"fn take[T](self : Stream[T], n : Int) -> List[T] {\n"
"  if n == 0 {\n"
"    Nil\n"
"  } else {\n"
"    match self {\n"
"      Empty => Nil\n"
"      Cons(x, xs) => Cons(x, xs().take(n - 1))\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:75
msgid ""
"The implementation of lazy data structures using thunks is "
"straightforward and effectively addresses the problems mentioned above. "
"This method requires users to explicitly indicate where in the code "
"computation should be delayed, whereas the strategy of lazy languages is "
"much more aggressive: it defaults to using lazy evaluation for all user-"
"defined functions! In the following sections, we will present a minimal "
"implementation of a lazy functional language and briefly introduce its "
"underlying theoretical model."
msgstr ""
"使用 thunk "
"实现惰性数据结构的方法很简单，有效地解决了上述问题。这种方法要求用户明确指示代码中应该延迟计算的位置，而惰性语言的策略则更加激进：它默认使用惰性求值来处理所有用户定义的函数！在接下来的章节中，我们将介绍一个惰性函数式语言的最小实现，并简要介绍其潜在的理论模型。"

#: ../../tutorial/example/gmachine/gmachine-1.md:77
msgid "A Lazy Evaluation Language and Its Abstract Syntax Tree"
msgstr "一种惰性求值语言及其抽象语法树"

#: ../../tutorial/example/gmachine/gmachine-1.md:79
msgid ""
"The example used in this article is a lazy evaluation language, "
"deliberately made to resemble Clojure (a Lisp dialect) and named coreF. "
"This design choice allows for the use of Clojure's syntax highlighting in"
" markdown. Don't worry, though the syntax might seem a bit complex at "
"first, it is straightforward enough."
msgstr ""
"本文中使用的示例是一种惰性求值语言，故意设计成类似 Clojure（一种 Lisp 方言）的语言，命名为 coreF。这是为了在 Markdown"
" 中使用 Clojure 的语法高亮。请别担心，语法可能有点麻烦，但是绝对够简单。"

#: ../../tutorial/example/gmachine/gmachine-1.md:81
msgid "Functions are defined using the `defn` keyword:"
msgstr "使用 `defn` 关键字定义函数："

#: ../../tutorial/example/gmachine/gmachine-1.md:83
msgid ""
"(defn factorial[n] ;; n is the parameter, this function calculates the "
"factorial of n\n"
"  (if (eq n 0) ;; The definition starts here and continues for the next "
"three lines\n"
"    1\n"
"    (mul n (factorial (sub n 1)))))\n"
msgstr ""
"(defn factorial[n] ;; n 是参数，这个函数计算 n 的阶乘\n"
"  (if (eq n 0) ;; 定义从这里开始，持续到下面的三行\n"
"    1\n"
"    (mul n (factorial (sub n 1)))))\n"

#: ../../tutorial/example/gmachine/gmachine-1.md:90
msgid ""
"Referring to it as a function in general conversation is acceptable. "
"However, when discussing lazy functional languages, we must introduce a "
"specialized term: _Super Combinator_. In the definition of a super "
"combinator, all free variables should be included in an initial pair of "
"`[]`."
msgstr ""
"在一般对话中，我们将它成为函数就好。但当我们讨论惰性函数式语言时，我们必须引入一个专门的术语：_超组合子_（ Super Combinator "
"）。在超组合子的定义中，所有自由变量都应该包含在一个初始的 `[]` 中。"

#: ../../tutorial/example/gmachine/gmachine-1.md:92
msgid ""
"Execution of a coreF program begins with `main`, calling a specific super"
" combinator as if replacing it with its definition."
msgstr "coreF 程序的执行从 `main` 开始，调用一个特定的超组合子，等价于用它的定义替换它。"

#: ../../tutorial/example/gmachine/gmachine-1.md:94
msgid "(defn main[] (factorial 42))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:98
msgid ""
"Super combinators without parameters, such as `main`, are referred to by "
"a specific term: _Constant Applicative Forms (CAF)_."
msgstr "没有参数的超组合子，如 `main`，有一个术语：_常量应用形式（ Constant Applicative Forms ，简称 CAF）_。"

#: ../../tutorial/example/gmachine/gmachine-1.md:100
msgid ""
"coreF also possesses several language features, including custom data "
"structures, `case` expressions for dismantling structures, and `let` and "
"`letrec` for the declaration of local variables. However, the scope of "
"this article is limited to the aforementioned features (actually, even "
"less, as built-in functions like `eq`, `mul`, `sub`, etc., are planned "
"for future implementation)."
msgstr ""
"coreF 还具有几个语言特性，包括自定义数据结构、用于解构的 `case` 表达式，以及用于声明局部变量的 `let` 和 "
"`letrec`。但是，本文的范围仅限于上述特性（实际上，甚至更少，因为像 `eq`、`mul`、`sub` 等内置函数之后才会实现）。"

#: ../../tutorial/example/gmachine/gmachine-1.md:102
msgid ""
"coreF excludes anonymous functions because anonymous functions introduce "
"extra free variables. Removing them requires an additional transformation"
" step: lambda lifting. This technique can transform a lambda expression "
"into an external Super Combinator, but this is not a main point of lazy "
"evaluation, hence its omission here."
msgstr ""
"coreF 不包括匿名函数，因为匿名函数会引入额外的自由变量。删除它们需要额外的转换步骤：lambda 提升。这种技术可以将 lambda "
"表达式转换为外部超组合子，但这不是惰性求值的主要内容，因此在这里省略了。"

#: ../../tutorial/example/gmachine/gmachine-1.md:104
msgid ""
"Super combinators will eventually be parsed into `ScDef[String]`, but "
"writing a parser is a tedious task. I will provide it along with the "
"final code."
msgstr "超组合子最终将被解析为 `ScDef[String]`，但编写解析器是一项繁琐的任务。我将在最终代码中提供它。"

#: ../../tutorial/example/gmachine/gmachine-1.md:106
msgid ""
"enum RawExpr[T] {\n"
"  Var(T)\n"
"  Num(Int)\n"
"  Constructor(tag~:Int, arity~:Int) // tag, arity\n"
"  App(RawExpr[T], RawExpr[T])\n"
"  Let(Bool, List[(T, RawExpr[T])], RawExpr[T]) // isRec, Defs, Body\n"
"  Case(RawExpr[T], List[(Int, List[T], RawExpr[T])])\n"
"} derive(Show)\n"
"\n"
"struct ScDef[T] {\n"
"  name : String\n"
"  args : List[T]\n"
"  body : RawExpr[T]\n"
"} derive(Show)\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:112
msgid "Additionally, some predefined coreF programs are required."
msgstr "此外，还有一些预定义的 coreF 程序需要给出。"

#: ../../tutorial/example/gmachine/gmachine-1.md:114
msgid ""
"let prelude_defs : List[ScDef[String]] = {\n"
"  let args : (FixedArray[String]) -> List[String] = List::of\n"
"  let id = ScDef::new(\"I\", args([\"x\"]), Var(\"x\")) // id x = x\n"
"  let k = \n"
"    ScDef::new(\n"
"      \"K\",\n"
"      args([\"x\", \"y\"]),\n"
"      Var(\"x\")\n"
"    ) // K x y = x\n"
"  let k1 = \n"
"    ScDef::new(\n"
"      \"K1\",\n"
"      args([\"x\", \"y\"]),\n"
"      Var(\"y\")\n"
"    ) // K1 x y = y\n"
"  let s = \n"
"    ScDef::new(\n"
"      \"S\",\n"
"      args([\"f\", \"g\", \"x\"]),\n"
"      App(App(Var(\"f\"), Var(\"x\")), App(Var(\"g\"), Var(\"x\")))\n"
"    ) // S f g x = f x (g x)\n"
"  let compose = \n"
"    ScDef::new(\n"
"      \"compose\",\n"
"      args([\"f\", \"g\", \"x\"]),\n"
"      App(Var(\"f\"), App(Var(\"g\"), Var(\"x\")))\n"
"    ) // compose f g x = f (g x)\n"
"  let twice = \n"
"    ScDef::new(\n"
"      \"twice\",\n"
"      args([\"f\"]),\n"
"      App(App(Var(\"compose\"), Var(\"f\")), Var(\"f\"))\n"
"    ) // twice f = compose f f\n"
"  List::of([id, k, k1, s, compose, twice])\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:120
msgid "Why Graph"
msgstr "为什么是图"

#: ../../tutorial/example/gmachine/gmachine-1.md:122
msgid ""
"In the coreF language, expressions (not `RawExpr[T]` mentioned earlier, "
"but runtime expressions) are stored in memory in the form of a graph "
"rather than a tree when being evaluated.)"
msgstr "在 coreF 语言中，表达式（不是前面提到的 `RawExpr[T]`，而是运行时表达式）在被求值时，以图的形式存储在内存中，而不是树。"

#: ../../tutorial/example/gmachine/gmachine-1.md:124
msgid "Why is this approach taken? Let's examine this through a program example:"
msgstr "为什么要这样？看看这个程序："

#: ../../tutorial/example/gmachine/gmachine-1.md:126
msgid ""
"(defn square[x]  (mul x x))\n"
"(defn main[] (square (square 3)))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:131
msgid ""
"If we evaluate according to the conventional expression tree, it would be"
" reduced to:"
msgstr "如果我们按照一般的树形表达式来求值，表达式会被规约成："

#: ../../tutorial/example/gmachine/gmachine-1.md:133
msgid "(mul (square 3) (square 3))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:137
msgid ""
"In this case, `(square 3)` would be evaluated twice, which is certainly "
"not desirable for lazy evaluation."
msgstr "在这种情况下，`(square 3)` 将被计算两次，这对于惰性求值来说显然是不可取的。"

#: ../../tutorial/example/gmachine/gmachine-1.md:139
msgid ""
"To illustrate this more clearly, let's make a somewhat improper analogy "
"using MoonBit code:"
msgstr "为了更清楚地说明这一点，让我们用 MoonBit 代码做一个不太恰当的类比："

#: ../../tutorial/example/gmachine/gmachine-1.md:141
msgid ""
"fn square(thunk : () -> Int) -> Int {\n"
"  thunk() * thunk()\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:147
msgid ""
"To represent the program using a graph is to facilitate sharing of "
"computation results and avoid redundant calculations. To achieve this "
"purpose, it's crucial to implement an in-place update algorithm when "
"reducing the graph. Regarding in-place update, let's simulate it using "
"MoonBit code:"
msgstr ""
"使用图来表示程序是为了方便共享计算结果，避免冗余计算。为了实现这个目的，在减少图时实现一个原地更新算法是至关重要的。关于原地更新，让我们用 "
"MoonBit 代码来模拟它："

#: ../../tutorial/example/gmachine/gmachine-1.md:149
msgid ""
"enum LazyData[T] {\n"
"  Waiting(() -> T)\n"
"  Done(T)\n"
"}\n"
"\n"
"struct LazyRef[T] {\n"
"  mut data : LazyData[T]\n"
"}\n"
"\n"
"fn extract[T](self : LazyRef[T]) -> T {\n"
"  match self.data {\n"
"    Waiting(thunk) => {\n"
"      let value = thunk()\n"
"      self.data = Done(value) // in-place update\n"
"      value\n"
"    }\n"
"    Done(value) => value\n"
"  }\n"
"}\n"
"\n"
"fn square(x : LazyRef[Int]) -> Int {\n"
"  x.extract() * x.extract()\n"
"}\n"
msgstr ""
"enum LazyData[T] {\n"
"  Waiting(() -> T)\n"
"  Done(T)\n"
"}\n"
"\n"
"struct LazyRef[T] {\n"
"  mut data : LazyData[T]\n"
"}\n"
"\n"
"fn extract[T](self : LazyRef[T]) -> T {\n"
"  match self.data {\n"
"    Waiting(thunk) => {\n"
"      let value = thunk()\n"
"      self.data = Done(value) // 原地更新\n"
"      value\n"
"    }\n"
"    Done(value) => value\n"
"  }\n"
"}\n"
"\n"
"fn square(x : LazyRef[Int]) -> Int {\n"
"  x.extract() * x.extract()\n"
"}\n"
"\n"

#: ../../tutorial/example/gmachine/gmachine-1.md:155
msgid ""
"Regardless of which side executes the `extract` method first, it will "
"update the referenced mutable field and replace its content with the "
"computed result. Therefore, there's no need to recompute it during the "
"second execution of the `extract` method."
msgstr "无论哪一方先执行 `extract` 方法，它都会更新引用的可变字段，并用计算结果替换其内容。"

#: ../../tutorial/example/gmachine/gmachine-1.md:157
msgid "Conventions"
msgstr "约定："

#: ../../tutorial/example/gmachine/gmachine-1.md:159
msgid ""
"Before delving into how graph reduction works, let's establish some key "
"terms and basic facts. We'll continue using the same program as an "
"example:"
msgstr "在讨论图规约如何进行之前，让我们先定义一些术语和基本事实。我们将继续使用相同的程序作为示例："

#: ../../tutorial/example/gmachine/gmachine-1.md:161
msgid ""
"(defn square[x]  (mul x x)) ;; multiplication\n"
"(defn main[] (square (square 3)))\n"
msgstr ""
"(defn square[x]  (mul x x)) ;; 乘法\n"
"(defn main[] (square (square 3)))"

#: ../../tutorial/example/gmachine/gmachine-1.md:166
msgid "Built-in primitives like `mul` are predefined operations."
msgstr "内置的原语，如 `mul`，是预定义的操作。"

#: ../../tutorial/example/gmachine/gmachine-1.md:168
msgid ""
"Evaluating an expression (of course, lazy) and updating its corresponding"
" node in the graph in place is called reduction."
msgstr "对表达式进行求值（当然是惰性的），并原地更新图中对应的节点，这个过程称为规约。"

#: ../../tutorial/example/gmachine/gmachine-1.md:169
msgid ""
"`(square 3)` is a reducible expression (often abbreviated as redex), "
"consisting of `square` and its argument. It can be reduced to `(mul 3 "
"3)`. `(mul 3 3)` is also a redex, but it's a different type of redex "
"compared to `(square 3)` because `square` is a user-defined combinator "
"while `mul` is an implemented built-in primitive."
msgstr ""
"`(square 3)` 是一个可规约的表达式（reducible expression，通常缩写为 redex），由 `square` "
"和它的参数组成。它可以规约为 `(mul 3 3)`。`(mul 3 3)` 也是一个 redex，但与 `(square 3)` "
"相比，它是一种不同类型的 redex，因为 `square` 是一个用户定义的组合子，而 `mul` 是一个实现的内置原语。"

#: ../../tutorial/example/gmachine/gmachine-1.md:170
msgid ""
"The reduction result of `(mul 3 3)` is the expression `9`, which cannot "
"be further reduced. Such expressions that cannot be further reduced are "
"called Normal forms."
msgstr "`(mul 3 3)` 的规约结果是表达式 `9`，它不能进一步规约。这种不能进一步规约的表达式称为范式（normal form）。"

#: ../../tutorial/example/gmachine/gmachine-1.md:171
msgid ""
"An expression may contain multiple sub-expressions (e.g., `(mul (add 3 5)"
" (mul 7 9))`). In such cases, the order of reduction of expressions is "
"crucial – some programs only halt under specific reduction orders."
msgstr ""
"一个表达式可能包含多个子表达式（例如 `(mul (add 3 5) (mul 7 "
"9))`）。在这种情况下，表达式的规约顺序至关重要——有些程序只在特定的规约顺序下停机。"

#: ../../tutorial/example/gmachine/gmachine-1.md:173
msgid ""
"There's a special reduction order that always selects the outermost redex"
" for reduction, known as _normal order reduction_. This reduction order "
"will be uniformly adopted in the following discussion."
msgstr ""
"有一种特殊的规约顺序总是选择最外层的 redex 进行规约，称为 _正则序规约_（normal order "
"reduction）。下文也将统一采用这种规约顺序。"

#: ../../tutorial/example/gmachine/gmachine-1.md:175
msgid "So, the graph reduction can be described with the following pseudocode:"
msgstr "因此，图规约可以用以下伪代码描述："

#: ../../tutorial/example/gmachine/gmachine-1.md:177
msgid ""
"While there exist reducible expressions in the graph {\n"
"    Select the outermost reducible expression.\n"
"    Reduce the expression.\n"
"    Update the graph with the result of reduction.\n"
"}\n"
msgstr ""
"当图中存在可规约的表达式时 {\n"
"    选择最外层的可规约表达式。\n"
"    规约表达式。\n"
"    用规约的结果更新图。\n"
"}\n"

#: ../../tutorial/example/gmachine/gmachine-1.md:185
msgid ""
"Dizzy now? Let's find a few examples to demonstrate how to perform "
"reductions on paper."
msgstr "头晕了吗？让我们找一些例子来演示如何在纸上进行规约。"

#: ../../tutorial/example/gmachine/gmachine-1.md:187
msgid "Step 1: Find the next redex"
msgstr "第一步：找到下一个 redex"

#: ../../tutorial/example/gmachine/gmachine-1.md:189
msgid "The execution of the entire program starts from the `main` function."
msgstr "在整个程序中，执行从 `main` 函数开始。"

#: ../../tutorial/example/gmachine/gmachine-1.md:191
msgid ""
"(defn square[x]  (mul x x))\n"
"(defn main[] (add 33 (square 3)))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:196
msgid ""
"`main` itself is a CAF - the simplest kind of redex. If we perform the "
"substitution, the current expression to be handled is:"
msgstr "`main` 本身是一个 CAF - 最简单的 redex。如果我们进行替换，当前要处理的表达式是："

#: ../../tutorial/example/gmachine/gmachine-1.md:198
msgid "(add 33 (square 3))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:202
msgid ""
"According to the principle of finding the outermost redex, it seems like "
"we've immediately found the redex formed by `add` and its two parameters "
"(let's assume it for now)."
msgstr "根据找到最外层 redex 的原则，我们似乎立即找到了由 `add` 和它的两个参数组成的 redex（暂时这么假设）。"

#: ../../tutorial/example/gmachine/gmachine-1.md:204
msgid ""
"But wait! Due to the presence of default currying, the abstract syntax "
"tree corresponding to this expression is actually composed of multiple "
"nested `App` nodes. It roughly looks like this (simplified for "
"readability):"
msgstr "但是稍等！由于存在默认的柯里化，这个表达式对应的抽象语法树实际上由多个 `App` 节点嵌套而成。它大致看起来是这样的（为了可读性而简化）："

#: ../../tutorial/example/gmachine/gmachine-1.md:206
msgid "App(App(add, 33), App(square, 3))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:210
msgid ""
"This chain-like structure from `add` to the outermost `App` node is "
"called the \"Spine\""
msgstr "这个从 `add` 到最外层 `App` 节点的链式结构称为“脊柱”（Spine）"

#: ../../tutorial/example/gmachine/gmachine-1.md:212
msgid ""
"Going back to check, `add` is an internally defined primitive. However, "
"since its second argument `(square 3)` is not in normal form, we cannot "
"reduce it (adding an unevaluated expression to an integer seems a bit "
"absurd). So, we can't definitively say that `(add 33 (square 3))` is a "
"redex; it's just the outermost function application. To reduce it, we "
"must first reduce `(square 3)`."
msgstr ""
"回过头来看一下，`add` 是一个内部定义的原语。但是，由于它的第二个参数 `(square 3)` "
"不是范式，我们不能对它进行规约（将一个未求值的表达式加到一个整数上似乎有点荒谬）。因此，我们不能明确地说 `(add 33 (square "
"3))` 是一个 redex；它只是最外层的函数应用。要对它进行规约，我们必须先规约 `(square 3)`。"

#: ../../tutorial/example/gmachine/gmachine-1.md:214
msgid "Step 2: Reduce"
msgstr "第二步：规约"

#: ../../tutorial/example/gmachine/gmachine-1.md:216
msgid ""
"Since `square` is a user-defined super combinator, reducing `(square 3)` "
"involves only parameter substitution."
msgstr "因为 `square` 是一个用户定义的超组合子，所以对 `(square 3)` 进行规约只涉及参数替换。"

#: ../../tutorial/example/gmachine/gmachine-1.md:218
msgid ""
"If a redex has fewer arguments than required by the super combinator, "
"which is common in higher-order functions, consider the example of "
"tripling all integers in a list."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:220
msgid "(map (mul 3) list-of-int)\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:224
msgid ""
"Here, `(mul 3)` cannot be treated as a redex because it lacks sufficient "
"arguments, making it a `weak head normal form` (often abbreviated as "
"WHNF). In this situation, even if its sub-expressions contain redexes, no"
" action is needed."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:226
msgid "Step 3: Update"
msgstr "第三步：更新"

#: ../../tutorial/example/gmachine/gmachine-1.md:228
msgid ""
"This step only affects execution efficiency and can be skipped during "
"paper deductions."
msgstr "这一步只影响执行效率，在纸上推导时可以跳过。"

#: ../../tutorial/example/gmachine/gmachine-1.md:230
msgid ""
"These operations are easy to perform on paper (when the amount of code "
"doesn't exceed half a sheet), but when we switch to computers, how do we "
"translate these steps into executable code?"
msgstr "这些操作在纸上执行很容易（当代码量不超过半张纸时），但当我们切换到计算机时，我们如何将这些步骤转换为可执行代码呢？"

#: ../../tutorial/example/gmachine/gmachine-1.md:232
msgid ""
"To answer this question, pioneers in the world of lazy evaluation "
"programming languages have proposed various **abstract machines** for "
"modeling lazy evaluation. These include:"
msgstr "为了回答这个问题，惰性求值编程语言的先驱们提出了各种用于建模惰性求值的 **抽象机器**。这些包括："

#: ../../tutorial/example/gmachine/gmachine-1.md:234
#: ../../tutorial/example/gmachine/index.md:1
msgid "G-Machine"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:235
msgid "Three Instruction Machine"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:236
msgid "ABC Machine (used by the Clean language)"
msgstr "ABC Machine（由 Clean 语言使用）"

#: ../../tutorial/example/gmachine/gmachine-1.md:237
msgid "Spineless Tagless G-Machine (abbreviated as STG, used by Haskell language)"
msgstr "Spineless Tagless G-Machine（简称 STG，由 Haskell 语言使用）"

#: ../../tutorial/example/gmachine/gmachine-1.md:239
msgid ""
"They are execution models used to guide compiler implementations. It's "
"important to note that, unlike various popular virtual machines today "
"(such as the JVM), abstract machines are more like intermediate "
"representations (IR) for compilers. Taking Haskell's compiler GHC as an "
"example, after generating STG code, it doesn't directly pass it to an "
"interpreter for execution. Instead, it further transforms it into LLVM, C"
" code, or machine code based on the selected backend."
msgstr ""
"它们是用于指导编译器实现的执行模型。重要的是要注意，与今天各种流行的虚拟机（如 JVM）不同，抽象机器更像是编译器的中间表示（IR）。以 "
"Haskell 的编译器 GHC 为例，生成 STG 代码后，它不会直接将其传递给解释器执行。相反，它会根据所选的后端进一步将其转换为 "
"LLVM、C 代码或机器代码。"

#: ../../tutorial/example/gmachine/gmachine-1.md:241
msgid ""
"To simplify implementation, this article will directly use MoonBit to "
"write an interpreter for G-Machine instructions, starting from a minimal "
"example and gradually adding more features."
msgstr ""
"为了简化实现，本文将直接使用 MoonBit 为 G-Machine 指令编写解释器，从一个最小的示例开始，逐渐添加更多功能。"

#: ../../tutorial/example/gmachine/gmachine-1.md:243
msgid "G-Machine Overview"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:245
msgid ""
"While the G-Machine is an abstract machine for lazy functional languages,"
" its structure and concepts are not significantly different from what one"
" encounters when writing general imperative languages. It also features "
"structures like heap and stack, and its instructions are executed "
"sequentially. Some key differences include:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:247
msgid "The basic unit of memory in the heap is not bytes, but graph nodes."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:248
msgid ""
"The stack only contains pointers to addresses in the heap, not actual "
"data."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:250
msgid "This design may not be practical, but it's relatively simple."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:252
msgid ""
"In coreF, super combinators are compiled into a series of G-Machine "
"instructions. These instructions can be roughly categorized as follows:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:254
msgid ""
"Access Data Instructions, For example, `PushArg` (access function "
"arguments), and `PushGlobal` (access other super combinators)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:255
msgid ""
"Construct/update graph nodes in the heap, like `MkApp`, `PushInt`, "
"`Update`"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:256
msgid "Clean up the `Pop` instruction of the unused addresses from the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:257
msgid "Express control flow with the `Unwind` instruction"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:259
msgid "Dissecting the G-Machine State"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:261
msgid "In this simple version of the G-Machine, the state includes:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:263
msgid ""
"Heap: This is where the expression graph and the sequences of "
"instructions corresponding to super combinators are stored."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:265
#, python-format
msgid ""
"// Use the 'type' keyword to encapsulate an address type.\n"
"type Addr Int derive(Eq, Show)\n"
"\n"
"// Describe graph nodes with an enumeration type.\n"
"enum Node {\n"
"  NNum(Int)\n"
"  // The application node\n"
"  NApp(Addr, Addr)\n"
"  // To store the number of parameters and \n"
"  // the corresponding sequence of instructions for a super combinator\n"
"  NGlobal(String, Int, List[Instruction])\n"
"  // The Indirection node，The key component of implementing lazy "
"evaluation\n"
"  NInd(Addr)\n"
"} derive(Eq, Show)\n"
"\n"
"struct GHeap {\n"
"  // The heap uses an array, \n"
"  // and the space with None content in the array is available as free "
"memory.\n"
"  mut object_count : Int\n"
"  memory : Array[Node?]\n"
"}\n"
"\n"
"// Allocate heap space for nodes.\n"
"fn alloc(self : GHeap, node : Node) -> Addr {\n"
"  let heap = self\n"
"  fn next(n : Int) -> Int {\n"
"    (n + 1) % heap.memory.length()\n"
"  }\n"
"\n"
"  fn free(i : Int) -> Bool {\n"
"    match heap.memory[i] {\n"
"      None => true\n"
"      _ => false\n"
"    }\n"
"  }\n"
"\n"
"  let mut i = heap.object_count\n"
"  while not(free(i)) {\n"
"    i = next(i)\n"
"  }\n"
"  heap.memory[i] = Some(node)\n"
"  heap.object_count = heap.object_count + 1\n"
"  return Addr(i)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:271
msgid ""
"Stack: The stack only holds addresses pointing to the heap. A simple "
"implementation can use `List[Addr]`."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:272
msgid ""
"Global Table: It's a mapping table that records the names of super "
"combinators (including predefined and user-defined) and their "
"corresponding addresses as `NGlobal` nodes. Here I implement it using a "
"Robin Hood hash table."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:273
msgid "Current code sequence to be executed."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:274
msgid ""
"Execution status statistics: A simple implementation involves calculating"
" how many instructions have been executed."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:276
msgid "The entire state is represented using the type `GState`."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:278
msgid ""
"struct GState {\n"
"  mut stack : List[Addr]\n"
"  heap : GHeap\n"
"  globals : @hashmap.T[String, Addr]\n"
"  mut code : List[Instruction]\n"
"  mut stats : GStats\n"
"}\n"
"\n"
"type GStats Int\n"
"\n"
"fn stat_incr(self : GState) -> Unit {\n"
"  self.stats = self.stats._ + 1\n"
"}\n"
"\n"
"fn put_stack(self : GState, addr : Addr) -> Unit {\n"
"  self.stack = Cons(addr, self.stack)\n"
"}\n"
"\n"
"fn put_code(self : GState, instrs : List[Instruction]) -> Unit {\n"
"  self.code = instrs + self.code\n"
"}\n"
"\n"
"fn pop1(self : GState) -> Addr {\n"
"  match self.stack {\n"
"    Cons(addr, reststack) => {\n"
"      self.stack = reststack\n"
"      addr\n"
"    }\n"
"    Nil => abort(\"pop1(): stack size smaller than 1\")\n"
"  }\n"
"}\n"
"\n"
"// e1 e2 ..... -> (e1, e2) ......\n"
"fn pop2(self : GState) -> (Addr, Addr) {\n"
"  match self.stack {\n"
"    Cons(addr1, Cons(addr2, reststack)) => {\n"
"      self.stack = reststack\n"
"      (addr1, addr2)\n"
"    }\n"
"    _ => abort(\"pop2(): stack size smaller than 2\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:284
#: ../../tutorial/example/gmachine/gmachine-1.md:290
msgid ""
"Now, we can map each step of the graph reduction algorithm we deduced on "
"paper to this abstract machine:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:286
#: ../../tutorial/example/gmachine/gmachine-1.md:292
msgid ""
"At the initial state of the machine, all compiled super combinators have "
"been placed in `NGlobal` nodes on the heap. At this point, the current "
"code sequence in the G-Machine contains only two instructions. The first "
"instruction pushes the address of the `main` node onto the stack, and the"
" second instruction loads the corresponding code sequence of `main` into "
"the current code sequence."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:287
#: ../../tutorial/example/gmachine/gmachine-1.md:293
msgid ""
"The corresponding code sequence of `main` is instantiated on the heap, "
"where nodes are allocated and data is loaded accordingly, ultimately "
"constructing a graph in memory. This process is referred to as "
"\"instantiating\" `main`. Once instantiation is complete, the address of "
"the entry point of this graph is pushed onto the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:288
msgid ""
"After instantiation is finished, you need to update graph nodes (since "
"`main` has no parameters, there is no need to clean up residual unused "
"addresses in the stack) and find the next redex to clean up."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:294
msgid ""
"After instantiation is finished, cleanup work is done, which involves "
"updating graph nodes (since `main` has no parameters, there is no need to"
" clean up residual unused addresses in the stack) and finding the next "
"redex."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:296
msgid "All of these tasks have corresponding instruction implementations."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:298
msgid "Corresponding Effect of Each Instruction"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:300
msgid "The highly simplified G-Machine currently consists of 7 instructions."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:302
msgid ""
"enum Instruction {\n"
"  Unwind\n"
"  PushGlobal(String)\n"
"  PushInt(Int)\n"
"  PushArg(Int)\n"
"  MkApp\n"
"  Update(Int)\n"
"  Pop(Int)\n"
"} derive (Eq, Show)\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:308
msgid ""
"The `PushInt` instruction is the simplest. It allocates an `NNum` node on"
" the heap and pushes its address onto the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:310
msgid ""
"fn push_int(self : GState, num : Int) -> Unit {\n"
"  let addr = self.heap.alloc(NNum(num))\n"
"  self.put_stack(addr)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:316
msgid ""
"The `PushGlobal` instruction retrieves the address of the specified super"
" combinator from the global table and then pushes the address onto the "
"stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:318
msgid ""
"fn push_global(self : GState, name : String) -> Unit {\n"
"  let sc = self.globals[name]\n"
"  match sc {\n"
"    None => abort(\"push_global(): cant find supercombinator \\{name}\")\n"
"    Some(addr) => self.put_stack(addr)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:324
msgid ""
"The `PushArg` instruction is a bit more complex. It has specific "
"requirements regarding the layout of addresses on the stack: the first "
"address should point to the super combinator node, followed by n "
"addresses pointing to N `NApp` nodes. `PushArg` retrieves the Nth "
"parameter, starting from the `offset + 1`."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:326
msgid ""
"fn push_arg(self : GState, offset : Int) -> Unit {\n"
"  let appaddr = self.stack.unsafe_nth(offset + 1)\n"
"  let arg = match self.heap[appaddr] {\n"
"    NApp(_, arg) => arg\n"
"    otherwise =>\n"
"      abort(\n"
"        \"pusharg: stack offset \\{offset} address \\{appaddr} node "
"\\{otherwise}\",\n"
"      )\n"
"  }\n"
"  self.put_stack(arg)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:332
msgid ""
"The `MkApp` instruction takes two addresses from the top of the stack, "
"constructs an `NApp` node, and pushes its address onto the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:334
msgid ""
"fn mk_apply(self : GState) -> Unit {\n"
"  let (a1, a2) = self.pop2()\n"
"  let appaddr = self.heap.alloc(NApp(a1, a2))\n"
"  self.put_stack(appaddr)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:340
msgid ""
"The `Update` instruction assumes that the first address on the stack "
"points to the current redex's evaluation result. It skips the addresses "
"of the immediately following super combinator nodes and replaces the Nth "
"`NApp` node with an indirect node pointing to the evaluation result. If "
"the current redex is a CAF, it directly replaces its corresponding "
"`NGlobal` node on the heap. From this, we can see why in lazy functional "
"languages, there is not much distinction between functions without "
"parameters and ordinary variables."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:342
msgid ""
"fn update(self : GState, n : Int) -> Unit {\n"
"  let addr = self.pop1()\n"
"  let dst = self.stack.unsafe_nth(n)\n"
"  self.heap[dst] = NInd(addr)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:348
msgid ""
"The `Unwind` instruction in the G-Machine is akin to an evaluation loop. "
"It has several branching conditions based on the type of node "
"corresponding to the address at the top of the stack:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:350
msgid "For `Nnum` nodes: Do nothing."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:351
msgid ""
"For `NApp` nodes: Push the address of the left node onto the stack and "
"`Unwind` again."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:352
msgid ""
"For `NGlobal` nodes: If there are enough parameters on the stack, load "
"this super combinator into the current code."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:353
msgid ""
"For `NInd` nodes: Push the address contained within this indirect node "
"onto the stack and Unwind again."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:355
msgid ""
"fn unwind(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(_) => self.put_stack(addr)\n"
"    NApp(a1, _) => {\n"
"      self.put_stack(addr)\n"
"      self.put_stack(a1)\n"
"      self.put_code(Cons(Unwind, Nil))\n"
"    }\n"
"    NGlobal(_, n, c) =>\n"
"      if self.stack.length() < n {\n"
"        abort(\"Unwinding with too few arguments\")\n"
"      } else {\n"
"        self.put_stack(addr)\n"
"        self.put_code(c)\n"
"      }\n"
"    NInd(a) => {\n"
"      self.put_stack(a)\n"
"      self.put_code(Cons(Unwind, Nil))\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:361
msgid ""
"The `Pop` instruction pops N addresses, eliminating the need for a "
"separate function implementation."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:363
msgid "Compiling Super Combinators into Instruction Sequences"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:365
msgid ""
"In the G-Machine Overview section, we roughly described the behavior of "
"compiled super combinators. Now we can precisely describe the compilation"
" process of super combinators."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:367
msgid ""
"Firstly, before the instruction sequence of a compiled super combinator "
"is executed, there must be certain addresses already present in the "
"stack:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:369
msgid ""
"The topmost address points to an `NGlobal` node (the super combinator "
"itself)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:370
msgid ""
"Following are N addresses (N being the number of parameters for this "
"super combinator), pointing to a series of App nodes - corresponding "
"exactly to the spine of a redex. The bottommost address in the stack "
"points to the outermost App node of the expression, and the rest follow "
"suit."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:372
msgid ""
"When compiling a super combinator, we need to maintain an environment "
"that allows us to find the relative position of parameters in the stack "
"during the compilation process by their names. Additionally, since "
"clearing the preceding N+1 addresses is necessary after completing the "
"instantiation of a super combinator, the number of parameters N needs to "
"be passed as well."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:374
msgid ""
"Here, \"parameters\" refer to addresses pointing to App nodes on the "
"heap, and the actual parameter addresses can be accessed through the "
"pusharg instruction."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:376
msgid ""
"fn compileSC(self : ScDef[String]) -> (String, Int, List[Instruction]) {\n"
"  let name = self.name\n"
"  let body = self.body\n"
"  let mut arity = 0\n"
"  fn gen_env(i : Int, args : List[String]) -> List[(String, Int)] {\n"
"    match args {\n"
"      Nil => {\n"
"        arity = i\n"
"        return Nil\n"
"      }\n"
"      Cons(s, ss) => Cons((s, i), gen_env(i + 1, ss))\n"
"    }\n"
"  }\n"
"\n"
"  let env = gen_env(0, self.args)\n"
"  (name, arity, compileR(body, env, arity))\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:382
msgid ""
"The `compileR` function generates code for instantiating super "
"combinators by calling the `compileC` function, and then appends three "
"instructions:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:384
msgid ""
"`Update(N)`: Updates the original redex in the heap to an `NInd` node, "
"which then points to the newly instantiated super combinator."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:385
msgid "`Pop(N)`: Clears the stack of redundant addresses."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:386
msgid "`Unwind`: Searches for the next redex to start the next reduction."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:388
msgid ""
"fn compileR(\n"
"  self : RawExpr[String],\n"
"  env : List[(String, Int)],\n"
"  arity : Int\n"
") -> List[Instruction] {\n"
"  if arity == 0 {\n"
"    compileC(self, env) + List::of([Update(arity), Unwind])\n"
"  } else {\n"
"    compileC(self, env) + List::of([Update(arity), Pop(arity), Unwind])\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:394
msgid ""
"When compiling the definition of super combinators, a rather crude "
"approach is used: if a variable is not a parameter, it is treated as "
"another super combinator (writing it incorrectly will result in a runtime"
" error). For function application, the right-hand expression is compiled "
"first, then all offsets corresponding to parameters in the environment "
"are incremented (because an extra address pointing to the instantiated "
"right-hand expression is added to the top of the stack), then the left-"
"hand expression is compiled, and finally the `MkApp` instruction is "
"added."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:396
msgid ""
"fn compileC(\n"
"  self : RawExpr[String],\n"
"  env : List[(String, Int)]\n"
") -> List[Instruction] {\n"
"  match self {\n"
"    Var(s) =>\n"
"      match env.lookup(s) {\n"
"        None => List::of([PushGlobal(s)])\n"
"        Some(n) => List::of([PushArg(n)])\n"
"      }\n"
"    Num(n) => List::of([PushInt(n)])\n"
"    App(e1, e2) =>\n"
"      compileC(e2, env) + compileC(e1, argOffset(1, env)) + "
"List::of([MkApp])\n"
"    _ => abort(\"not support yet\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:402
msgid "Running the G-Machine"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:404
msgid ""
"Once the super combinators are compiled, they need to be placed on the "
"heap (along with adding their addresses to the global table). This can be"
" done recursively."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:406
msgid ""
"fn build_initial_heap(\n"
"  scdefs : List[(String, Int, List[Instruction])]\n"
") -> (GHeap, @hashmap.T[String, Addr]) {\n"
"  let heap = { object_count: 0, memory: Array::make(10000, None) }\n"
"  let globals = @hashmap.new(capacity=50)\n"
"  loop scdefs {\n"
"    Nil => ()\n"
"    Cons((name, arity, instrs), rest) => {\n"
"      let addr = heap.alloc(NGlobal(name, arity, instrs))\n"
"      globals[name] = addr\n"
"      continue rest\n"
"    }\n"
"  }\n"
"  return (heap, globals)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:412
msgid ""
"Define a function \"step\" that updates the state of the G-Machine by one"
" step, returning false if the final state has been reached."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:414
msgid ""
"fn step(self : GState) -> Bool {\n"
"  match self.code {\n"
"    Nil => return false\n"
"    Cons(i, is) => {\n"
"      self.code = is\n"
"      self.stat_incr()\n"
"      match i {\n"
"        PushGlobal(f) => self.push_global(f)\n"
"        PushInt(n) => self.push_int(n)\n"
"        PushArg(n) => self.push_arg(n)\n"
"        MkApp => self.mk_apply()\n"
"        Unwind => self.unwind()\n"
"        Update(n) => self.update(n)\n"
"        Pop(n) => self.stack = self.stack.drop(n)\n"
"      }\n"
"      return true\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:420
msgid ""
"Additionally, define a function \"reify\" that continuously executes the "
"\"step\" function until the final state is reached."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:422
msgid ""
"fn reify(self : GState) -> Node {\n"
"  if self.step() {\n"
"    self.reify()\n"
"  } else {\n"
"    let stack = self.stack\n"
"    match stack {\n"
"      Cons(addr, Nil) => {\n"
"        let res = self.heap[addr]\n"
"        return res\n"
"      }\n"
"      _ => abort(\"wrong stack \\{stack}\")\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:428
msgid "Combine the above components."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:430
msgid ""
"fn run(codes : List[String]) -> Node {\n"
"  fn parse_then_compile(code : String) -> (String, Int, "
"List[Instruction]) {\n"
"    let tokens = tokenize(code)\n"
"    let code = \n"
"      try {\n"
"        tokens.parse_sc!()\n"
"      } catch {\n"
"        ParseError(s) => abort(s)\n"
"      } else {\n"
"        expr => expr\n"
"      }\n"
"    let code = compileSC(code)\n"
"    return code\n"
"  }\n"
"  let codes = codes.map(parse_then_compile) + prelude_defs.map(compileSC)"
"\n"
"  let (heap, globals) = build_initial_heap(codes)\n"
"  let initialState : GState = {\n"
"    heap : heap,\n"
"    stack : Nil,\n"
"    code : List::of([PushGlobal(\"main\"), Unwind]),\n"
"    globals : globals,\n"
"    stats : 0\n"
"  }\n"
"  initialState.reify()\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:436
#: ../../tutorial/example/gmachine/gmachine-2.md:214
#: ../../tutorial/example/myers-diff/myers-diff2.md:86
#: ../../tutorial/example/myers-diff/myers-diff3.md:113
#: ../../tutorial/example/segment-tree/segment-tree.md:141
#: ../../tutorial/example/segment-tree/segment-tree2.md:132
#: ../../tutorial/example/sudoku/index.md:388
msgid "Conclusion"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:438
msgid ""
"The features of the G-Machine we've constructed so far are too limited to"
" run even a somewhat decent program. In the next article, we will "
"incrementally add features such as primitives and custom data structures."
" Towards the end, we'll introduce lazy evaluation techniques after "
"covering the G-Machine."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:440
msgid "Reference"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-1.md:442
msgid ""
"Peyton Jones, Simon & Lester, David. (2000). Implementing functional "
"languages: a tutorial."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:1
msgid "G-Machine 2"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:3
msgid ""
"This article is the second in the series on implementing lazy evaluation "
"in MoonBit. In the first part, we explored the purposes of lazy "
"evaluation and a typical abstract machine for lazy evaluation, the "
"G-Machine, and implemented some basic G-Machine instructions. In this "
"article, we will further extend the G-Machine implementation from the "
"previous article to support `let` expressions and basic arithmetic, "
"comparison, and other operations."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:5
msgid "let Expressions"
msgstr "let 表达式"

#: ../../tutorial/example/gmachine/gmachine-2.md:7
msgid ""
"The `let` expression in coref differs slightly from that in MoonBit. A "
"`let` expression can create multiple variables but can only be used "
"within a limited scope. Here is an example:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:9
msgid ""
"{\n"
"  let x = n + m\n"
"  let y = x + 42\n"
"  x * y\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:17
msgid "Equivalent coref expression:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:19
msgid ""
"(let ([x (add n m)]\n"
"      [y (add x 42)])\n"
"  (mul x y)) ;; xy can only be used within let\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:25
msgid ""
"It is important to note that coref's `let` expressions must follow a "
"sequential order. For example, the following is not valid:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:27
msgid ""
"(let ([y (add x 42)]\n"
"      [x (add n m)])\n"
"  (mul x y))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:33
msgid ""
"In contrast, `letrec` is more complex as it allows the local variables "
"defined to reference each other without considering the order of their "
"definitions."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:35
msgid ""
"Before implementing `let` (and the more complex `letrec`), we first need "
"to modify the current parameter passing method. The local variables "
"created by `let` should intuitively be accessed in the same way as "
"parameters, but the local variables defined by `let` do not correspond to"
" `NApp` nodes. Therefore, we need to adjust the stack parameters before "
"calling the supercombinator."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:37
msgid ""
"The adjustment is done in the implementation of the `Unwind` instruction."
" If the supercombinator has no parameters, it is the same as the original"
" unwind. When there are parameters, the top address of the "
"supercombinator node is discarded, and the `rearrange` function is "
"called."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:39
msgid ""
"fn rearrange(self : GState, n : Int) -> Unit {\n"
"  let appnodes = self.stack.take(n)\n"
"  let args = appnodes.map(fn (addr) {\n"
"    guard let NApp(_, arg) = self.heap[addr] else {\n"
"      _ => panic()\n"
"    }\n"
"    arg \n"
"  })\n"
"  self.stack = args + appnodes.drop(n - 1)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:45
msgid ""
"The `rearrange` function assumes that the first N addresses on the stack "
"point to a series of `NApp` nodes. It keeps the bottommost one (used as "
"Redex update), cleans up the top N-1 addresses, and then places N "
"addresses that directly point to the parameters."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:47
msgid ""
"After this, both parameters and local variables can be accessed using the"
" same command by changing the `PushArg` instruction to a more general "
"`Push` instruction."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:49
msgid ""
"fn push(self : GState, offset : Int) -> Unit {\n"
"  // Push(n) a0 : . . . : an : s\n"
"  //     =>  an : a0 : . . . : an : s\n"
"  let addr = self.stack.unsafe_nth(offset)\n"
"  self.put_stack(addr)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:55
msgid ""
"The next issue is that we need something to clean up. Consider the "
"following expression:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:57
msgid ""
"(let ([x1 e1]\n"
"      [x2 e2])\n"
"  expr)\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:63
msgid ""
"After constructing the graph corresponding to the expression `expr`, the "
"stack still contains addresses pointing to e1 and e2 (corresponding to "
"variables x1 and x2), as shown below (the stack grows from bottom to "
"top):"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:65
msgid ""
"<Address pointing to expr>\n"
"       |\n"
"<Address pointing to x2>\n"
"       |\n"
"<Address pointing to x1>\n"
"       |\n"
"...remaining stack...\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:75
msgid ""
"Therefore, we need a new instruction to clean up these no longer needed "
"addresses. It is called `Slide`. As the name suggests, the function of "
"`Slide(n)` is to skip the first address and delete the following N "
"addresses."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:77
msgid ""
"fn slide(self : GState, n : Int) -> Unit {\n"
"  let addr = self.pop1()\n"
"  self.stack = Cons(addr, self.stack.drop(n))\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:83
msgid ""
"Now we can compile `let`. We will compile the expressions corresponding "
"to local variables using the `compileC` function. Then, traverse the list"
" of variable definitions (`defs`), compile and update the corresponding "
"offsets in order. Finally, use the passed `comp` function to compile the "
"main expression and add the `Slide` instruction to clean up the unused "
"addresses."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:85
msgid ""
"Compiling the main expression using the passed function makes it easy to "
"reuse when adding subsequent features."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:87
msgid ""
"fn compileLet(\n"
"  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],\n"
"  defs : List[(String, RawExpr[String])],\n"
"  expr : RawExpr[String],\n"
"  env : List[(String, Int)]\n"
") -> List[Instruction] {\n"
"  let (env, codes) = loop env, List::Nil, defs {\n"
"    env, acc, Nil => (env, acc)\n"
"    env, acc, Cons((name, expr), rest) => {\n"
"      let code = compileC(expr, env)\n"
"      let env = List::Cons((name, 0), argOffset(1, env))\n"
"      continue env, acc + code, rest\n"
"    }\n"
"  }\n"
"  codes + comp(expr, env) + List::of([Slide(defs.length())])\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:93
msgid ""
"The semantics of `letrec` are more complex - it allows the N variables "
"within the expression to reference each other, so we need to pre-allocate"
" N addresses and place them on the stack. We need a new instruction: "
"`Alloc(N)`, which pre-allocates N `NInd` nodes and pushes the addresses "
"onto the stack sequentially. The addresses in these indirect nodes are "
"negative and only serve as placeholders."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:95
msgid ""
"fn alloc_nodes(self : GState, n : Int) -> Unit {\n"
"  let dummynode : Node = NInd(Addr(-1))\n"
"  for i = 0; i < n; i = i + 1 {\n"
"    let addr = self.heap.alloc(dummynode)\n"
"    self.put_stack(addr)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:101
msgid "The steps to compile letrec are similar to `let`:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:103
msgid "Use `Alloc(n)` to allocate N addresses."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:104
msgid "Use the `loop` expression to build a complete environment."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:105
msgid ""
"Compile the local variables in `defs`, using the `Update` instruction to "
"update the results to the pre-allocated addresses after compiling each "
"one."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:106
msgid "Compile the main expression and use the `Slide` instruction to clean up."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:108
msgid ""
"fn compileLetrec(\n"
"  comp : (RawExpr[String], List[(String, Int)]) -> List[Instruction],\n"
"  defs : List[(String, RawExpr[String])],\n"
"  expr : RawExpr[String],\n"
"  env : List[(String, Int)]\n"
") -> List[Instruction] {\n"
"  let mut env = env\n"
"  loop defs {\n"
"    Nil => ()\n"
"    Cons((name, _), rest) => {\n"
"      env = Cons((name, 0), argOffset(1, env))\n"
"      continue rest\n"
"    }\n"
"  }\n"
"  let n = defs.length()\n"
"  fn compileDefs(\n"
"    defs : List[(String, RawExpr[String])],\n"
"    offset : Int\n"
"  ) -> List[Instruction] {\n"
"    match defs {\n"
"      Nil => comp(expr, env) + List::of([Slide(n)])\n"
"      Cons((_, expr), rest) =>\n"
"        compileC(expr, env) +\n"
"        Cons(Update(offset), compileDefs(rest, offset - 1))\n"
"    }\n"
"  }\n"
"\n"
"  Cons(Alloc(n), compileDefs(defs, n - 1))\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:114
msgid "Adding Primitives"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:116
msgid ""
"From this step, we can finally perform basic integer operations such as "
"arithmetic, comparison, and checking if two numbers are equal. First, "
"modify the `Instruction` type to add related instructions."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:118
msgid ""
"  Add\n"
"  Sub\n"
"  Mul\n"
"  Div\n"
"  Neg\n"
"  Eq // ==\n"
"  Ne // !=\n"
"  Lt // <\n"
"  Le // <=\n"
"  Gt // >\n"
"  Ge // >=\n"
"  Cond(List[Instruction], List[Instruction])\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:133
msgid ""
"At first glance, implementing these instructions seems simple. Take `Add`"
" as an example: just pop two top addresses from the stack, retrieve the "
"corresponding numbers from memory, perform the operation, and push the "
"result address back onto the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:135
msgid ""
"fn add(self : GState) -> Unit {\n"
"  let (a1, a2) = self.pop2() // Pop two top addresses\n"
"  match (self.heap[a1], self.heap[a2]) {\n"
"    (NNum(n1), NNum(n2)) => {\n"
"      let newnode = Node::NNum(n1 + n2)\n"
"      let addr = self.heap.alloc(newnode)\n"
"      self.putStack(addr)\n"
"    }\n"
"    ......\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:149
msgid ""
"However, the next problem we face is that this is a lazy evaluation "
"language. The parameters of `add` are likely not yet computed (i.e., not "
"`NNum` nodes). We also need an instruction that can force a computation "
"to give a result or never stop computing. We call it `Eval` (short for "
"Evaluation)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:151
msgid ""
"In jargon, the result of such a computation is called Weak Head Normal "
"Form (WHNF)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:153
msgid ""
"At the same time, we need to modify the structure of `GState` and add a "
"state called `dump`. Its type is `List[(List[Instruction], List[Addr])]`,"
" used by `Eval` and `Unwind` instructions."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:155
msgid "The implementation of the `Eval` instruction is not complicated:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:157
msgid "Pop the top address of the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:159
msgid ""
"Save the current unexecuted instruction sequence and stack (by putting "
"them into the dump)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:161
msgid "Clear the current stack and place the previously saved address."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:163
msgid "Clear the current instruction sequence and place the `Unwind` instruction."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:165
msgid ""
"This is similar to how strict evaluation languages handle saving caller "
"contexts, but practical implementations would use more efficient methods."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:167
msgid ""
"fn eval(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  self.put_dump(self.code, self.stack)\n"
"  self.stack = List::of([addr])\n"
"  self.code = List::of([Unwind])\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:173
msgid ""
"This simple definition requires modifying the `Unwind` instruction to "
"restore the context when `Unwind` in the `NNum` branch finds that there "
"is a recoverable context (`dump` is not empty)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:175
msgid ""
"fn unwind(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(_) => {\n"
"      match self.dump {\n"
"        Nil => self.put_stack(addr)\n"
"        Cons((instrs, stack), rest_dump) => {\n"
"          self.stack = stack\n"
"          self.put_stack(addr)\n"
"          self.dump = rest_dump\n"
"          self.code = instrs\n"
"        }\n"
"      }\n"
"    }\n"
"    NApp(a1, _) => {\n"
"      self.put_stack(addr)\n"
"      self.put_stack(a1)\n"
"      self.put_code(List::of([Unwind]))\n"
"    }\n"
"    NGlobal(_, n, c) => {\n"
"      if self.stack.length() < n {\n"
"        abort(\"Unwinding with too few arguments\")\n"
"      } else {\n"
"        if n != 0 {\n"
"          self.rearrange(n)\n"
"        } else {\n"
"          self.put_stack(addr)\n"
"        }\n"
"        self.put_code(c)\n"
"      }\n"
"    }\n"
"    NInd(a) => {\n"
"      self.put_stack(a)\n"
"      self.put_code(List::of([Unwind]))\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:181
msgid ""
"Next, we need to implement arithmetic and comparison instructions. We use"
" two functions to simplify the form of binary operations. The result of "
"the comparison instruction is a boolean value, and for simplicity, we use"
" numbers to represent it: 0 for `false`, 1 for `true`."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:183
msgid ""
"fn negate(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(n) => {\n"
"      let addr = self.heap.alloc(NNum(-n))\n"
"      self.put_stack(addr)\n"
"    }\n"
"    otherwise => {\n"
"      abort(\"negate: wrong kind of node \\{otherwise}, address "
"\\{addr}\")\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"fn lift_arith2(self : GState, op : (Int, Int) -> Int) -> Unit {\n"
"  let (a1, a2) = self.pop2()\n"
"  match (self.heap[a1], self.heap[a2]) {\n"
"    (NNum(n1), NNum(n2)) => {\n"
"      let newnode = Node::NNum(op(n1, n2))\n"
"      let addr = self.heap.alloc(newnode)\n"
"      self.put_stack(addr)\n"
"    }\n"
"    (node1, node2) => abort(\"liftArith2: \\{a1} = \\{node1} \\{a2} = "
"\\{node2}\")\n"
"  }\n"
"}\n"
"\n"
"fn lift_cmp2(self : GState, op : (Int, Int) -> Bool) -> Unit {\n"
"  let (a1, a2) = self.pop2()\n"
"  match (self.heap[a1], self.heap[a2]) {\n"
"    (NNum(n1), NNum(n2)) => {\n"
"      let flag = op(n1, n2)\n"
"      let newnode = if flag { Node::NNum(1) } else { Node::NNum(0) }\n"
"      let addr = self.heap.alloc(newnode)\n"
"      self.put_stack(addr)\n"
"    }\n"
"    (node1, node2) => abort(\"liftCmp2: \\{a1} = \\{node1} \\{a2} = "
"\\{node2}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:189
msgid "Finally, implement branching:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:191
msgid ""
"fn condition(self : GState, i1 : List[Instruction], i2 : "
"List[Instruction]) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(0) => {\n"
"      // false\n"
"      self.code = i2 + self.code\n"
"    }\n"
"    NNum(1) => {\n"
"      // true\n"
"      self.code = i1 + self.code\n"
"    }\n"
"    otherwise => abort(\"cond : \\{addr} = \\{otherwise}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:197
msgid ""
"No major adjustments are needed in the compilation part, just add some "
"predefined programs:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:199
#: ../../tutorial/example/gmachine/gmachine-3.md:9
msgid ""
"let compiled_primitives : List[(String, Int, List[Instruction])] = "
"List::of(\n"
"  [\n"
"    // Arith\n"
"    (\n"
"      \"add\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Add, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"sub\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Sub, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"mul\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Mul, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"div\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Div, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    // Compare\n"
"    (\n"
"      \"eq\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Eq, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"neq\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Ne, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"ge\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Ge, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"gt\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Gt, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"le\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Le, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    (\n"
"      \"lt\",\n"
"      2,\n"
"      List::of([Push(1), Eval, Push(1), Eval, Lt, Update(2), Pop(2), "
"Unwind]),\n"
"    ),\n"
"    // MISC\n"
"    (\"negate\", 1, List::of([Push(0), Eval, Neg, Update(1), Pop(1), "
"Unwind])),\n"
"    (\n"
"      \"if\",\n"
"      3,\n"
"      List::of(\n"
"        [\n"
"          Push(0),\n"
"          Eval,\n"
"          Cond(List::of([Push(1)]), List::of([Push(2)])),\n"
"          Update(3),\n"
"          Pop(3),\n"
"          Unwind,\n"
"        ],\n"
"      ),\n"
"    ),\n"
"  ],\n"
")\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:205
msgid "and modify the initial instruction sequence"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:207
msgid "code : List::of([PushGlobal(\"main\"), Eval]),\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-2.md:216
msgid ""
"In the next part, we will improve the code generation for primitives and "
"add support for data structures."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:1
msgid "G-Machine 3"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:3
msgid ""
"This article is the third in a series on implementing Haskell's lazy "
"evaluation in MoonBit. In the previous article, we learned how to compile"
" `let` expressions and how to implement basic arithmetic and comparison "
"operations. In this article, we will implement a context-based "
"optimization method and add support for data structures."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:5
msgid "Tracking Context"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:7
msgid ""
"Let's review how we implemented primitives in the [last "
"tutorial](gmachine-2.md)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:15
msgid ""
"This implementation introduces many `Eval` instructions, but they are not"
" always necessary. For example:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:17
msgid "(add 3 (mul 4 5))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:21
msgid ""
"The two arguments of `add` are already in WHNF (Weak Head Normal Form) "
"before executing `Eval`. Therefore, the `Eval` instructions here are "
"redundant."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:23
msgid ""
"One feasible optimization method is to consider the context when "
"compiling expressions. For example, `add` requires its arguments to be "
"evaluated to WHNF, so its arguments are in a strict context during "
"compilation. By doing this, we can identify some expressions that can be "
"safely compiled with strict evaluation (only a subset)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:25
msgid "An expression in a supercombinator definition is in a strict context."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:27
msgid ""
"If `(op e1 e2)` is in a strict context (where `op` is a primitive), then "
"`e1` and `e2` are also in a strict context."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:29
msgid ""
"If `(let (.....) e)` is in a strict context, then `e` is also in a strict"
" context (but the expressions corresponding to the local variables are "
"not, as `e` may not need their results)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:31
msgid ""
"We use the `compileE` function to implement compilation in a strict "
"context, ensuring that _the value at the top of the stack is always in "
"WHNF_."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:33
msgid ""
"For the default branch, we simply add an `Eval` instruction after the "
"result of `compileC`."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:35
msgid "_ => compileC(self, env) + List::of([Eval])\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:42
msgid "Constants are pushed directly."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:44
msgid "Num(n) => List::of([PushInt(n)])\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:51
msgid ""
"For `let/letrec` expressions, the specially designed `compileLet` and "
"`compileLetrec` become useful. Compiling a `let/letrec` expression in a "
"strict context only requires using `compileE` to compile its main "
"expression."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:53
msgid ""
"Let(rec, defs, e) => {\n"
"  if rec {\n"
"    compileLetrec(compileE, defs, e, env)\n"
"  } else {\n"
"    compileLet(compileE, defs, e, env)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:60
msgid ""
"The `if` and `negate` functions, with 3 and 1 arguments respectively, "
"require special handling."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:62
msgid ""
"App(App(App(Var(\"if\"), b), e1), e2) => {\n"
"  let condition = compileE(b, env)\n"
"  let branch1 = compileE(e1, env)\n"
"  let branch2 = compileE(e2, env)\n"
"  condition +  List::of([Cond(branch1, branch2)])\n"
"}\n"
"App(Var(\"negate\"), e) => {\n"
"  compileE(e, env) + List::of([Neg])\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:69
msgid ""
"Basic binary operations can be handled uniformly through a lookup table. "
"First, construct a hash table called `builtinOpS` to query the "
"corresponding instructions by the name of the primitive."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:71
msgid ""
"let builtinOpS : @hashmap.T[String, Instruction] = {\n"
"  let table  = @hashmap.new(capacity = 50)\n"
"  table[\"add\"] = Add \n"
"  table[\"mul\"] = Mul\n"
"  table[\"sub\"] = Sub\n"
"  table[\"div\"] = Div\n"
"  table[\"eq\"]  = Eq\n"
"  table[\"neq\"] = Ne\n"
"  table[\"ge\"] = Ge \n"
"  table[\"gt\"] = Gt\n"
"  table[\"le\"] = Le\n"
"  table[\"lt\"] = Lt\n"
"  table\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:77
msgid "The rest of the handling is not much different."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:79
msgid ""
"App(App(Var(op), e0), e1) => {\n"
"  match builtinOpS[op] {\n"
"    None => compileC(self, env) + List::of([Eval])\n"
"    Some(instr) => {\n"
"      let code1 = compileE(e1, env)\n"
"      let code0 = compileE(e0, argOffset(1, env))\n"
"      code1 + code0 + List::of([instr])\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:86
msgid ""
"Are we done? It seems so, but there's another WHNF besides integers: "
"partially applied functions."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:88
msgid ""
"A partial application is when the number of arguments is insufficient. "
"This situation is common in higher-order functions, for example:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:90
msgid "(map (add 1) listofnumbers)\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:94
msgid "Here, `(add 1)` is a partial application."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:96
msgid ""
"To ensure that the code generated by the new compilation strategy works "
"correctly, we need to modify the implementation of the `Unwind` "
"instruction for the `NGlobal` branch. When the number of arguments is "
"insufficient and the dump has saved stacks, we should only retain the "
"original redex and restore the stack."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:98
msgid ""
"NGlobal(_, n, c) => {\n"
"  let k = self.stack.length()\n"
"  if k < n {\n"
"    match self.dump {\n"
"      Nil => abort(\"Unwinding with too few arguments\")\n"
"      Cons((i, s), rest) => {\n"
"        // a1 : ...... : ak\n"
"        // ||\n"
"        // ak : s\n"
"        self.stack = self.stack.drop(k - 1) + s\n"
"        self.dump = rest\n"
"        self.code = i\n"
"      }\n"
"    }\n"
"  } else {\n"
"    if n != 0 {\n"
"      self.rearrange(n)\n"
"    } else {\n"
"      self.put_stack(addr)\n"
"    }\n"
"    self.put_code(c)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:105
msgid ""
"This context-based strictness analysis technique is useful but cannot do "
"anything with supercombinator calls. Here we briefly introduce a "
"strictness analysis technique based on boolean operations, which can "
"analyze which arguments of a supercombinator call should be compiled "
"using strict mode."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:107
msgid ""
"We first define a concept: bottom, which conceptually represents a value "
"that never terminates or causes an exception. For a supercombinator `f "
"a[1] ...... a[n]`, if one argument `a[i]` satisfies `a[i] = bottom`, then"
" `f a[1] .... a[i] .... a[n] = bottom` (other arguments are not bottom). "
"This indicates that no matter how complex the internal control flow of "
"`f` is, it **must** need the result of argument `a[i]` to get the final "
"result. Therefore, a`[i]` should be strictly evaluated."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:109
msgid ""
"If this condition is not met, it does not necessarily mean that the "
"argument is not needed at all; it may be used only in certain branches "
"and its use is determined at runtime. Such an argument is a typical "
"example of one that should be lazily evaluated."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:111
msgid ""
"Let's consider bottom as `false` and non-bottom values as `true`. In this"
" way, all functions in coref can be considered boolean functions. Take "
"`abs` as an example:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:113
msgid ""
"(defn abs[n]\n"
"  (if (lt n 0) (negate n) n))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:118
msgid "We analyze how to translate it into a boolean function from top to bottom:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:120
msgid ""
"For an expression like `(if x y z)`, x must be evaluated, but only one of"
" `y` or `z` needs to be evaluated. This can be translated into `x and (y "
"or z)`. Taking the example of the function above, if `n` is bottom, then "
"the condition `(lt n 0)` is also bottom, and thus the result of the "
"entire expression is also bottom."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:122
msgid "For primitive expressions, using `and` for all parts is sufficient."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:124
msgid ""
"To determine whether a parameter needs to be compiled strictly, you can "
"convert the above condition into a Boolean function: `a[i] = false` "
"implies `f a[1] .... a[i] .... a[n] = false` (with all other parameters "
"being true)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:126
msgid ""
"This is essentially a method of program analysis called \"abstract "
"interpretation.\""
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:128
msgid "Custom Data Structures"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:130
msgid ""
"The data structure type definition in Haskell is similar to the `enum` in"
" MoonBit. However, since CoreF is a simple toy language used to "
"demonstrate lazy evaluation, it does not allow custom data types. The "
"only built-in data structure is the lazy list."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:132
msgid ""
"(defn take[n l]\n"
"  (case l\n"
"    [(Nil) Nil]\n"
"    [(Cons x xs)\n"
"      (if (le n 0)\n"
"        Nil\n"
"        (Cons x (take (sub n 1) xs)))]))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:142
msgid ""
"As shown above, you can use the `case` expression for simple pattern "
"matching on lists."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:144
msgid ""
"The corresponding graph node for a list is `NConstr(Int, List[Addr])`, "
"which consists of two parts:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:146
msgid ""
"A tag for different value constructors: the tag for `Nil` is 0, and the "
"tag for `Cons` is 1."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:147
msgid ""
"A list of addresses for storing substructures, whose length corresponds "
"to the number of parameters (arity) of a value constructor."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:149
msgid ""
"This graph node structure can be used to implement various data "
"structures, but CoreF does not have a type system. For demonstration "
"purposes, only lazy lists are implemented."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:151
msgid ""
"We need to add two instructions, `Split` and `Pack`, to deconstruct and "
"construct lists."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:153
msgid ""
"fn pack(self : GState, t : Int, n : Int) -> Unit {\n"
"  let addrs = self.stack.take(n)\n"
"  self.stack = self.stack.drop(n)\n"
"  let addr = self.heap.alloc(NConstr(t, addrs))\n"
"  self.put_stack(addr)\n"
"}\n"
"\n"
"fn split(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NConstr(_, addrs) => {\n"
"      // n == addrs.length()\n"
"      self.stack = addrs + self.stack\n"
"    }\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:160
msgid ""
"Additionally, a `CaseJump` instruction is needed to implement the `case` "
"expression."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:162
msgid ""
"fn casejump(self : GState, table : List[(Int, List[Instruction])]) -> "
"Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NConstr(t, _) => {\n"
"      match table.lookup(t) {\n"
"        None => abort(\"casejump\")\n"
"        Some(instrs) => { \n"
"          self.code = instrs + self.code\n"
"          self.put_stack(addr)\n"
"        }\n"
"      }\n"
"    }\n"
"    otherwise => abort(\"casejump(): addr = \\{addr} node = "
"\\{otherwise}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:168
msgid ""
"After adding the above instructions, we need to modify the `compileC` and"
" `compileE` functions. Since the object matched by the `case` expression "
"needs to be evaluated to WHNF, only the `compileE` function can compile "
"it."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:170
msgid ""
"App(App(Constructor(tag = 1, arity = 2), x), xs) => {\n"
"  // Cons(x, xs)\n"
"  compileC(xs, env) + compileC(x, argOffset(1, env)) + List::of([Pack(1, "
"2)])\n"
"}\n"
"// Nil\n"
"Constructor(tag = 0, arity = 0) => List::of([Pack(0, 0)])\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:177
msgid ""
"Case(e, alts) => {\n"
"  compileE(e, env) + List::of([CaseJump(compileAlts(alts, env))])\n"
"}\n"
"Constructor(tag = 0, arity = 0) => {\n"
"  // Nil\n"
"  List::of([Pack(0, 0)])\n"
"}\n"
"App(App(Constructor(tag = 1, arity = 2), x), xs) => {\n"
"  // Cons(x, xs)\n"
"  compileC(xs, env) + compileC(x, argOffset(1, env)) + List::of([Pack(1, "
"2)])\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:184
msgid ""
"At this point, a new problem arises. Previously, printing the evaluation "
"result only needed to handle simple `NNum` nodes, but `NConstr` nodes "
"have substructures. When the list itself is evaluated to WHNF, its "
"substructures are mostly unevaluated `NApp` nodes. We need to add a "
"`Print` instruction, which will recursively evaluate and write the result"
" into the `output` component of `GState`."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:186
msgid ""
"fn gprint(self : GState) -> Unit {\n"
"  let addr = self.pop1()\n"
"  match self.heap[addr] {\n"
"    NNum(n) => {\n"
"      self.output.write_string(n.to_string())\n"
"      self.output.write_char(' ')\n"
"    }\n"
"    NConstr(0, Nil) => self.output.write_string(\"Nil\")\n"
"    NConstr(1, Cons(addr1, Cons(addr2, Nil))) => {\n"
"      self.code = List::of([Instruction::Eval, Print, Eval, Print]) + "
"self.code\n"
"      self.put_stack(addr2)\n"
"      self.put_stack(addr1)\n"
"    }\n"
"    _ => panic()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:192
msgid "Finally, change the initial code of the G-Machine to:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:194
msgid "code : List::of([PushGlobal(\"main\"), Eval, Print]),\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:201
msgid ""
"Now, we can write some classic functional programs using lazy lists, such"
" as the infinite Fibonacci sequence:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:203
msgid "(defn fibs[] (Cons 0 (Cons 1 (zipWith add fibs (tail fibs)))))\n"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:207
msgid ""
"After introducing data structures, strictness analysis becomes more "
"complex. For lazy lists, there are various evaluation modes:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:209
msgid ""
"Fully strict (requires the list to be finite and all elements to be non-"
"bottom)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:210
msgid "Fully lazy."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:211
msgid "Head strict (the list can be infinite, but its elements cannot be bottom)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:212
msgid "Tail strict (the list must be finite, but its elements can be bottom)."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:214
msgid ""
"Moreover, the context in which a function is used can change the "
"evaluation mode of its parameters (it cannot be analyzed in isolation and"
" requires cross-function analysis). Such complex strictness analysis "
"usually employs projection analysis techniques. Relevant literature "
"includes:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:216
msgid "Projections for Strictness Analysis"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:218
msgid "Static Analysis and Code Optimizations in Glasgow Haskell Compiler"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:220
msgid "Implementing Projection-based Strictness Analysis"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:222
msgid "Theory and Practice of Demand Analysis in Haskell"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:224
#: ../../tutorial/example/myers-diff/myers-diff.md:311
msgid "Epilogue"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:226
msgid ""
"Lazy evaluation can reduce runtime redundant calculations, but it also "
"introduces new problems, such as:"
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:228
msgid "The notorious side effect order issue."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:230
msgid ""
"Excessive redundant nodes. Some computations that are not shared still "
"store their results on the heap, which is detrimental to utilizing the "
"CPU's caching mechanism."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:232
msgid ""
"The representative of lazy evaluation languages, Haskell, offers a "
"controversial solution to the side effect order problem: Monads. This "
"solution has some value for eagerly evaluated languages as well, but many"
" online tutorials emphasize its mathematical background too much and fail"
" to explain how to use it effectively."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:234
msgid ""
"Idris2, Haskell's successor (which is no longer a lazy language), retains"
" Monads and introduces another mechanism for handling side effects: "
"Algebraic Effects."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:236
msgid ""
"The Spineless G-Machine designed by SPJ improved the problem of excessive"
" redundant nodes, and its successor, the STG, unified the data layout of "
"different types of nodes."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:238
msgid ""
"In addition to improvements in abstract machine models, GHC's "
"optimization of Haskell programs heavily relies on inline-based "
"optimizations and projection analysis-based strictness analysis "
"techniques."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:240
msgid ""
"In 2004, several GHC designers discovered that the previous push-enter "
"model, where parameters are pushed onto the stack and then a function is "
"called, was less effective than the eval-apply model, where the "
"responsibility is handed to the caller. They published a paper titled "
"\"Making a Fast Curry: Push/Enter vs. Eval/Apply for Higher-order "
"Languages.\""
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:242
msgid ""
"In 2007, Simon Marlow found that jump and execute code in the tagless "
"design significantly affected the performance of modern CPU branch "
"predictors. The paper \"_Faster laziness using dynamic pointer tagging_\""
" described several solutions."
msgstr ""

#: ../../tutorial/example/gmachine/gmachine-3.md:244
msgid ""
"Lazy purely functional languages have shown many interesting "
"possibilities, but they have also faced much criticism and reflection. "
"Nevertheless, it is undoubtedly an intriguing technology!"
msgstr ""

#: ../../tutorial/example/gmachine/index.md:7 ../../tutorial/example/index.md:5
#: ../../tutorial/example/myers-diff/index.md:3
#: ../../tutorial/example/segment-tree/index.md:13
msgid "Contents:"
msgstr "目录："

#: ../../tutorial/example/gmachine/index.md:3
msgid ""
"Lazy evaluation stands as a foundational concept in the realm of "
"programming languages. Haskell, renowned as a purely functional "
"programming language, boasts a robust lazy evaluation mechanism. This "
"mechanism not only empowers developers to craft code that's both more "
"efficient and concise but also enhances program performance and "
"responsiveness, especially when tackling sizable datasets or intricate "
"data streams."
msgstr ""

#: ../../tutorial/example/gmachine/index.md:5
msgid ""
"In this article, we'll delve into the Lazy Evaluation mechanism, "
"thoroughly examining its principles and implementation methods, and then "
"explore how to implement Haskell's evaluation semantics in "
"[MoonBit](https://www.moonbitlang.com/)."
msgstr ""

#: ../../tutorial/example/index.md:1
msgid "Examples"
msgstr ""

#: ../../tutorial/example/index.md:3
msgid "Here are some examples built with MoonBit."
msgstr ""

#: ../../tutorial/example/lambda/index.md:1
msgid "Lambda calculus"
msgstr "Lambda 演算"

#: ../../tutorial/example/lambda/index.md:3
#, fuzzy
msgid ""
"Functional programming rises with the fall of Moore's Law. The full "
"utilization of multi-core processors has become an increasingly important"
" optimization method, while functional programming also becomes more "
"popularized with its affinity for parallel computation. The reasons "
"behind this trend can be traced back to one of its theoretical "
"ancestors—Lambda calculus."
msgstr ""
"相信点开这篇文章的您或多或少地听说过函数式编程这个名词。在摩尔定律失效的今天，对多核处理器的充分利用成为了一种越发重要的程序优化方法，而函数式编程也因为其并行运算亲和的特点在大众视野中越发频繁地出现。究其原因，离不开它从其理论上的祖先之一"
" - lambda演算那里所继承的特征。"

#: ../../tutorial/example/lambda/index.md:5
msgid ""
"Lambda calculus originated from the 1930s. Created by Turing's mentor "
"Alonzo Church, formal systems have now evolved a vast and flourishing "
"family tree. This article will illustrate one of its most fundamental "
"forms: untyped Lambda calculus (which was also one of the earliest forms "
"proposed by Alonzo Church)."
msgstr "而lambda演算这一起源于20世纪30年代，出自图灵导师阿隆佐·邱奇之手的形式系统如今已经发展成了蔚为大观的一个大家族，本文将展示其中最基础的一种：无类型lambda演算(这也是最早阿隆佐·邱奇提出的那种)"

#: ../../tutorial/example/lambda/index.md:7
msgid "Basic rules of untyped Lambda calculus"
msgstr "无类型lambda演算的基本规则"

#: ../../tutorial/example/lambda/index.md:9
msgid ""
"The only actions allowed in untyped Lambda calculus are defining Lambdas "
"(often referred to as Abstraction) and calling Lambdas (often referred to"
" as Application). These actions constitute the basic expressions in "
"Lambda calculus."
msgstr "无类型lambda演算中能做的事情只有定义lambda(经常称为Abstraction)和调用lambda(经常称为Application)，它们也是lambda演算中的基础表达式。"

#: ../../tutorial/example/lambda/index.md:11
msgid ""
"Most programmers are no strange to the name \"Lambda expression\" as most"
" mainstream programming languages are hugely influenced by functional "
"language paradigm. Lambdas in untyped Lambda calculus are simpler than "
"those in mainstream programming languages. A Lambda typically looks like "
"this: `λx.x x`, where `x` is its parameter (each Lambda can only have one"
" parameter), `.` is the separator between the parameter and the "
"expression defining it, and `x x` is its definition."
msgstr ""
"由于函数式编程范式对主流编程语言的影响，大多数程序员对lambda表达式这个名字已经不会感到陌生了，不过，无类型lambda演算中的lambda要比主流编程语言简单一些。一个lambda通常看起来就像这样：`λx.x"
" x`, 其中x是它的参数(每个lambda只能有一个参数)，`.`是分隔参数与表达式具体定义的分隔符，后面的`x x`便是它的定义了。"

#: ../../tutorial/example/lambda/index.md:14
msgid ""
"Some materials may omit spaces, so the above example can be rewritten as "
"`λx.xx`."
msgstr "也有些材料的记法不写空格，上面的例子要改写成`λx.xx`"

#: ../../tutorial/example/lambda/index.md:17
msgid ""
"If we replace `x x` with `x(x)`, it might be more in line with the "
"function calls we see in general languages. However, in the more common "
"notation of Lambda calculus, calling a Lambda only requires a space "
"between it and its parameter. Here, we call the parameter given by `x`, "
"which is `x` itself."
msgstr ""
"上面的`x x`如果换成`x(x)`, "
"可能更符合我们在一般语言中见到的函数调用。但在lambda演算较常见的写法中，调用一个lambda只需要在它和它的参数中间写个空格。此处我们调用`x`所给出的参数就是`x`自己。"

#: ../../tutorial/example/lambda/index.md:19
msgid ""
"The combination of the above two expressions and the variables introduced"
" when defining Lambdas are collectively referred to as the Lambda term. "
"In MoonBit, we use an enum type to represent it:"
msgstr "以上两种表达式和定义lambda时引入的变量加在一起合称lambda项，我们在MoonBit里用一个enum类型来表示它："

#: ../../tutorial/example/lambda/index.md:21
msgid ""
"enum Term {\n"
"  Var(String) // Variable\n"
"  Abs(String, Term) // Define lambda, variables represented by strings\n"
"  App(Term, Term) // Call lambda\n"
"}\n"
msgstr ""
"enum Term {\n"
"  Var(String) // 变量\n"
"  Abs(String, Term) // 定义lambda，变量用字符串表示\n"
"  App(Term, Term) // 调用lambda\n"
"}\n"

#: ../../tutorial/example/lambda/index.md:27
msgid ""
"Concepts encountered in daily programming such as boolean values, if "
"expressions, natural number arithmetic, and even recursion can all be "
"implemented using Lambda expressions. However, this is not the focus of "
"this article."
msgstr "我们在日常编程中所接触的概念诸如布尔值，if表达式，自然数算术乃至递归都可以通过lambda表达式实现，但这并非本文内容的重心所在。"

#: ../../tutorial/example/lambda/index.md:30
msgid ""
"Interested readers can refer to: [Programming with "
"Nothing](https://tomstu.art/programming-with-nothing)"
msgstr ""
"有兴趣的读者可以参阅[Programming with Nothing](https://tomstu.art/programming-with-"
"nothing)这篇博客。"

#: ../../tutorial/example/lambda/index.md:33
msgid ""
"To implement an interpreter for untyped Lambda calculus, the basic things"
" we need to understand are just two rules: Alpha conversion and Beta "
"reduction."
msgstr "要实现一个无类型lambda演算的解释器，我们所需要了解的基本就只有两条规则：Alpha转换与Beta规约。"

#: ../../tutorial/example/lambda/index.md:35
msgid ""
"**Alpha conversion** describes the fact that the structure of Lambda is "
"crucial, and the names of variables are not that important. `λx.x` and "
"`λfoo.foo` can be interchanged. For certain nested Lambdas with repeated "
"variable names, such as `λx.(λx.x) x`, when renaming, the inner variables"
" cannot be renamed. For example, the above example can be rewritten using"
" Alpha conversion as `λy.(λx.x) y`."
msgstr ""
"Alpha转换所描述的事实是，lambda的结构是重点，变量名叫什么没那么重要。`λx.x`和`λfoo.foo`可以互相替换。对于某些有重复变量名的嵌套lambda例如`λx.(λx.x)"
" x`，重命名时不能把内层的变量也重命名了，例如上面的例子可以通过Alpha转换写成`λy.(λx.x) y`。"

#: ../../tutorial/example/lambda/index.md:37
msgid ""
"**Beta reduction** focuses on handling Lambda calls. Let's take an "
"example:"
msgstr "Beta规约则专注于处理lambda的调用，还是举一个例子："

#: ../../tutorial/example/lambda/index.md:39
msgid "(λx.(λy.x)) (λs.(λz.z))\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:43
msgid ""
"In untyped Lambda calculus, all that needs to be done after calling a "
"Lambda is to substitute the parameter. In the example above, we need to "
"replace the variable `x` with `(λs.(λz.z))`, resulting in:"
msgstr "在无类型lambda演算中，调用lambda之后所需要作的事情仅仅是对参数进行替换(substitution)，上面这个例子里就需要把变量`x`替换成`(λs.(λz.z))`，得到的结果是"

#: ../../tutorial/example/lambda/index.md:45
msgid "(λy.(λs.(λz.z)))\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:49
msgid "Free Variables and Variable Capture"
msgstr "自由变量与变量捕获"

#: ../../tutorial/example/lambda/index.md:51
msgid ""
"If a variable in a Lambda term is not defined in its context, we call it "
"a free variable. For example, in the Lambda term `(λx.(λy.fgv h))`, the "
"variables `fgv` and `h` do not have corresponding Lambda definitions."
msgstr ""
"一个lambda项中的变量如果在它所处的上下文中没有定义，那么我们叫它自由变量。例如`(λx.(λy.fgv "
"h))`这个lambda项中变量`fgv`和`h`就没有对应的lambda定义."

#: ../../tutorial/example/lambda/index.md:53
msgid ""
"During Beta reduction, if the Lambda term used for variable substitution "
"contains free variables, it may lead to a behavior called \"variable "
"capture\":"
msgstr "在进行Beta规约时，如果用于替换变量的那个lambda项中含有自由变量，可能会导致一种被称为“变量捕获”的行为"

#: ../../tutorial/example/lambda/index.md:55
msgid "(λx.(λy.x)) (λz.y)\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:59
msgid "After substitution:"
msgstr "上面这个表达式在替换后会变成"

#: ../../tutorial/example/lambda/index.md:61
msgid "λy.λz.y\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:65
msgid ""
"The free variable in `λz.y` is treated as a parameter of some Lambda, "
"which is obviously not what we want."
msgstr "`λz.y`中的自由变量被当成了某个lambda的参数，这显然不是我们想要的。"

#: ../../tutorial/example/lambda/index.md:67
msgid ""
"A common solution to the variable capture problem when writing "
"interpreters is to traverse the expression before substitution to obtain "
"a set of free variables. When encountering an inner Lambda during "
"substitution, check if the variable name is in this set of free "
"variables:"
msgstr ""
"变量捕获问题在编写解释器时的常见解决方案是在替换前遍历表达式得到一个自由变量的集合, "
"做替换时遇到内层lambda就判断一下变量名在不在这个自由变量集合里面"

#: ../../tutorial/example/lambda/index.md:71
msgid ""
"// (λx.E) T => E.subst(x, T)\n"
"fn subst(self : Term, var : String, term : Term) -> Term {\n"
"  let freeVars : Set[String] = term.get_free_vars()\n"
"  match self {\n"
"    Abs(variable, body) => {\n"
"      if freeVars.contains(variable) {\n"
"        // The variable name is in the set of free variables \n"
"        // of the current inner Lambda, indicating variable capture\n"
"        abort(\"subst(): error while encountering \\{variable}\")\n"
"      } else {\n"
"        ...\n"
"      }\n"
"    }\n"
"    ...\n"
"  }\n"
"}\n"
msgstr ""
"// (λx.E) T => E.subst(x, T)\n"
"fn subst(self : Term, var : String, term : Term) -> Term {\n"
"  let freeVars : Set[String] = term.get_free_vars()\n"
"  match self {\n"
"    Abs(variable, body) => {\n"
"      if freeVars.contains(variable) {\n"
"        //自由变量集合中有当前这个内层lambda的参数名，即会发生变量捕获\n"
"        abort(\"subst(): error while encountering \\{variable}\")\n"
"      } else {\n"
"        ...\n"
"      }\n"
"    }\n"
"    ...\n"
"  }\n"
"}\n"

#: ../../tutorial/example/lambda/index.md:90
msgid ""
"Next, I'll introduce a less popular but somewhat convenient method: de "
"Bruijn index."
msgstr "此处我们介绍一种较少见但具有一定便利性的方法：德布朗指数（de Bruijn index）。"

#: ../../tutorial/example/lambda/index.md:92
msgid "De Bruijn Index"
msgstr "德布朗指数"

#: ../../tutorial/example/lambda/index.md:94
msgid ""
"De Bruijn index is a technique for representing variables in Lambda terms"
" using integers. Specifically, it replaces specific variables with "
"Lambdas between the variable and its original imported position."
msgstr "德布朗指数是一种用整数表示lambda项中变量的技术，具体地说，它用变量所在位置和原先引入它的位置中间有几层lambda来替换特定变量。"

#: ../../tutorial/example/lambda/index.md:96
msgid ""
"λx.(λy.x (λz.z z))\n"
"\n"
"λ.(λ.1 (λ.0 0))\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:102
msgid ""
"In the example above, there is one Lambda `λy` between the variable `x` "
"and its introduction position `λx`, so `x` is replaced with `1`. For "
"variable `z`, there are no other Lambdas between its introduction "
"position and its usage, so it is directly replaced with `0`. In a sense, "
"the value of the de Bruijn index describes the relative distance between "
"the variable and its corresponding Lambda. Here, the distance is measured"
" by the number of nested Lambdas."
msgstr ""
"上面的例子中，变量`x`和引入它的地方`λx`中间有一个`λy`, "
"于是将`x`替换为`1`，而`z`和定义它的位置中间没有夹杂其他的lambda，于是直接用`0`替换。某种程度上说，德布朗指数的值描述的是变量与对应lambda的相对距离，此处的距离衡量标注就是中间嵌套的lambda层数。"

#: ../../tutorial/example/lambda/index.md:105
msgid ""
"The same variable may be replaced with different integers in different "
"positions."
msgstr "同一个变量在不同的地方可能会用不同的整数来替换。"

#: ../../tutorial/example/lambda/index.md:108
msgid ""
"We define a new type `TermDBI` to represent Lambda terms using de Bruijn "
"indices:"
msgstr "我们定义一个新类型`TermDBI`来表示使用德布朗指数的lambda项："

#: ../../tutorial/example/lambda/index.md:110
msgid ""
"enum TermDBI {\n"
"  Var(String, Int)\n"
"  Abs(String, TermDBI)\n"
"  App(TermDBI, TermDBI)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:116
msgid ""
"However, directly writing and reading Lambda terms in de Bruijn index "
"form is painful, so we need to write a function `bruijn()` to convert "
"`Term` to `TermDBI`. This is also why there is still a `String` in the "
"definition of the `TermDBI` type, so that the original variable name can "
"be used for its `Show` implementation, making it easy to print and view "
"the evaluation results with `println`."
msgstr ""
"不过直接编写以及阅读德布朗指数形式的lambda很痛苦，所以我们需要编写一个将`Term`转换成`TermDBI`的函数`debruijn()` "
"- "
"这也是`TermDBI`类型定义中仍有`String`的原因，保留原变量名可用于它的`Show`的实现，这样就可以方便地用`println`打印求值结果查看了。"

#: ../../tutorial/example/lambda/index.md:118
msgid ""
"impl Show for TermDBI with output(self : TermDBI, logger) -> Unit {\n"
"  match self {\n"
"    Var(name, _) => logger.write_string(name)\n"
"    Abs(name, body) => logger.write_string(\"(\\\\\\{name}.\\{body})\")\n"
"    App(t1, t2) => logger.write_string(\"\\{t1} \\{t2}\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:125
msgid ""
"To simplify implementation, if the input `Term` contains free variables, "
"the `bruijn()` function will report an error directly. MoonBit provides a"
" `Result[V, E]` type in the standard library, which has two constructors,"
" `Ok(V)` and `Err(E)`, representing success and failure in computation, "
"respectively."
msgstr ""
"为了简化实现，如果输入的Term中含有自由变量，`debruijn()`函数会直接报错。MoonBit中一般用`Result[V, "
"E]`类型表示可能会出错的计算, 它有`Ok(V)`和`Err(E)`两个值构造子，分别代表计算成功与失败。"

#: ../../tutorial/example/lambda/index.md:128
msgid "Readers familiar with Rust should find this familiar."
msgstr "使用过Rust语言的读者应该会感到熟悉。"

#: ../../tutorial/example/lambda/index.md:132
msgid "fn bruijn(self : Term) -> Result[TermDBI, String]\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:136
msgid ""
"We take a clumsy approach to save variable names and their associated "
"nesting depth. First, we define the `Index` type:"
msgstr "我们采取一种笨办法来保存变量名与相关联的嵌套深度，首先定义`Index`类型"

#: ../../tutorial/example/lambda/index.md:138
msgid ""
"struct Index {\n"
"  name : String\n"
"  depth : Int\n"
"}\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:144
msgid ""
"Then we write a helper function to find the corresponding `depth` based "
"on a specific `name` from `@immut/list.T[Index]`:"
msgstr "然后写一个从`@immut/list.T[Index]`中根据特定`name`查找对应`depth`的辅助函数"

#: ../../tutorial/example/lambda/index.md:146
msgid ""
"// Find the depth corresponding to the first varname in the environment\n"
"fn find(map : @immut/list.T[Index], varname : String) -> Result[Int, "
"String] {\n"
"  match map {\n"
"    Nil => Err(varname)\n"
"    Cons(i, rest) =>\n"
"      if i.name == varname {\n"
"        Ok(i.depth)\n"
"      } else {\n"
"        find(rest, varname)\n"
"      }\n"
"  }\n"
"}\n"
"\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:153
msgid "Now we can complete the `bruijn()` function."
msgstr "现在可以补全`debruijn()`函数了。"

#: ../../tutorial/example/lambda/index.md:155
msgid ""
"Handling `Var` is the simplest, just look up the table to find the "
"corresponding `depth`."
msgstr "`Var`的处理最简单，只需要查表寻找对应`depth`即可。"

#: ../../tutorial/example/lambda/index.md:156
msgid ""
"`Abs` is a bit more complicated. First, add one to the `depth` of all "
"`index` in the list (because the Lambda nesting depth has increased by "
"one), and then add `{ name : varname, depth : 0 }` to the beginning of "
"the list."
msgstr ""
"`Abs`稍微复杂一点，首先对列表中所有`index`的`depth`加一(因为lambda嵌套加深了一层)，然后在列表的开头加上`{ name "
": varname, depth : 0 }`。"

#: ../../tutorial/example/lambda/index.md:157
msgid ""
"`App` succeeds when both sub-items can be converted; otherwise, it "
"returns an `Err`."
msgstr "`App`在两个子项都能转换时成功，否则返回一个`Err`"

#: ../../tutorial/example/lambda/index.md:159
msgid ""
"fn go(m : @immut/list.T[Index], t : Term) -> Result[TermDBI, String] {\n"
"  match t {\n"
"    Var(name) => {\n"
"      let idx = find(m, name)\n"
"      match idx {\n"
"        Err(name) => Err(name)\n"
"        Ok(idx) => Ok(Var(name, idx))\n"
"      }\n"
"    }\n"
"    Abs(varname, body) => {\n"
"      let m = @immut/list.Cons(\n"
"        { name: varname, depth: 0 },\n"
"        m.map(fn(index) { { name: index.name, depth: index.depth + 1 } "
"}),\n"
"      )\n"
"      let res = go(m, body)\n"
"      match res {\n"
"        Err(name) => Err(name)\n"
"        Ok(term) => Ok(Abs(varname, term))\n"
"      }\n"
"    }\n"
"    App(e1, e2) =>\n"
"      match (go(m, e1), go(m, e2)) {\n"
"        (Ok(e1), Ok(e2)) => Ok(App(e1, e2))\n"
"        (Err(name), _) => Err(name)\n"
"        (_, Err(name)) => Err(name)\n"
"      }\n"
"  }\n"
"}\n"
"\n"
"go(Nil, self)\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:166
msgid "Reduce on TermDBI"
msgstr "在`TermDBI`上做规约"

#: ../../tutorial/example/lambda/index.md:168
msgid "Reduction mainly deals with App, i.e., calls:"
msgstr "规约主要处理的是`App`，即调用："

#: ../../tutorial/example/lambda/index.md:170
msgid ""
"fn eval(self : TermDBI) -> TermDBI {\n"
"  match self {\n"
"    App(t1, t2) =>\n"
"      match (eval(t1), eval(t2)) {\n"
"        (Abs(_, t1), t2) => eval(subst(t1, t2))\n"
"        (t1, t2) => App(t1, t2)\n"
"      }\n"
"    Abs(_) => self\n"
"    // Eval should not encounter any free variables\n"
"    _ => panic()\n"
"  }\n"
"}\n"
"\n"
msgstr ""
"fn eval(self : TermDBI) -> TermDBI {\n"
"  match self {\n"
"    App(t1, t2) =>\n"
"      match (eval(t1), eval(t2)) {\n"
"        (Abs(_, t1), t2) => eval(subst(t1, t2))\n"
"        (t1, t2) => App(t1, t2)\n"
"      }\n"
"    Abs(_) => self\n"
"    // Eval应该不会遇到自由变量才对\n"
"    _ => panic()\n"
"  }\n"
"}\n"
"\n"

#: ../../tutorial/example/lambda/index.md:176
msgid ""
"First, attempt reduction on both sub-items, then see if `eval(t1)` "
"results in a Lambda. If so, perform one step of variable substitution "
"(via the `subst` function) and then continue simplifying. For Lambdas "
"(`Abs`), simply return them as they are."
msgstr ""
"首先对两个子项尝试规约，然后看`eval(t1)`得到的是否是一个lambda，如果是，就执行一步变量替换(通过`subst`函数)然后继续化简。对于lambda(即`Abs`),"
" 直接原样返回即可。"

#: ../../tutorial/example/lambda/index.md:178
msgid ""
"The implementation of the `subst` function becomes much simpler when we "
"don't need to consider free variables. We just need to keep track of the "
"current depth recursively and compare it with the encountered variables. "
"If they match, it's the variable to be replaced."
msgstr ""
"`subst`函数的实现在不用考虑自由变量的情况下简单了许多, "
"只要记录递归到当前位置的深度并且与遇到的变量进行比对，大小相等就是需要替换的目标变量。"

#: ../../tutorial/example/lambda/index.md:180
msgid ""
"fn subst(t1 : TermDBI, t2 : TermDBI) -> TermDBI {\n"
"  fn go(t1 : TermDBI, t2 : TermDBI, depth : Int) -> TermDBI {\n"
"    match t1 {\n"
"      Var(_, d) => if d == depth { t2 } else { t1 }\n"
"      Abs(name, t) => Abs(name, go(t, t2, depth + 1))\n"
"      App(tl, tr) => App(go(tl, t2, depth), go(tr, t2, depth))\n"
"    }\n"
"  }\n"
"\n"
"  go(t1, t2, 0)\n"
"}\n"
"\n"
msgstr ""

#: ../../tutorial/example/lambda/index.md:186
msgid ""
"The full code: [GitHub repository](https://github.com/moonbitlang"
"/moonbit-docs/tree/main/next/sources/lambda-expression/src/top.mbt)"
msgstr ""
"完整代码请查看 [GitHub 代码仓库](https://github.com/moonbitlang/moonbit-"
"docs/tree/main/next/sources/lambda-expression/src/top.mbt)。"

#: ../../tutorial/example/lambda/index.md:188
msgid "Improvement"
msgstr "改进"

#: ../../tutorial/example/lambda/index.md:190
msgid ""
"When mapping variable names to indices, we used the "
"`@immut/list.T[Index]` type and updated the entire list every time we "
"added a new Lambda. However, this is actually quite a clumsy method. I "
"believe you can quickly realize that to store a `@immut/list.T[String]` "
"should simply suffice. If you're interested, you can try it yourself."
msgstr "笔者在保存变量名到索引的对应关系时使用了`@immut/list.T[Index]`类型，并且在每增加一层lambda时更新整个列表，但是这其实是个很笨的办法。相信聪明且注意力集中的读者很快就能发现，其实只需要保存一个`@immut/list.T[String]`就够了，有兴趣的读者可以自己试着做一做。"

#: ../../tutorial/example/myers-diff/index.md:1
msgid "Myers Diff"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:1
msgid "Myers diff"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:3
msgid ""
"Have you ever used the Unix tool `diff`? In short, it is a tool for "
"comparing the differences between two text files. What's more, Unix has a"
" tool called `patch`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:5
msgid ""
"Nowadays, few people manually apply patches to software packages, but "
"`diff` still retains its usefulness in another area: version control "
"systems. It's quite handy to have the function of being able to see what "
"changes have been made to source code files after a particular commit "
"(and highlighted with different colors). Take the most popular version "
"control system today, git, as an example:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:7
msgid ""
"diff --git a/main/main.mbt b/main/main.mbt\n"
"index 99f4c4c..52b1388 100644\n"
"--- a/main/main.mbt\n"
"+++ b/main/main.mbt\n"
"@@ -3,7 +3,7 @@\n"
"\n"
" fn main {\n"
"   let a = lines(\"A\\nB\\nC\\nA\\nB\\nB\\nA\")\n"
"-  let b = lines(\"C\\nB\\nA\\nB\\nA\\nC\")\n"
"+  let b = lines(\"C\\nB\\nA\\nB\\nA\\nA\")\n"
"   let r = shortst_edit(a, b)\n"
"   println(r)\n"
" }\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:23
msgid "But how exactly do we calculate the differences between two text files?"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:25
msgid ""
"git's default diff algorithm was proposed by _Eugene W. Myers_ in his "
"paper **An O(ND) Difference Algorithm and Its Variations**. This paper "
"mainly focuses on proving the correctness of the algorithm. In the "
"following text, we will understand the basic framework of this algorithm "
"in a less rigorous way and use MoonBit to write a simple implementation."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:27
msgid "Defining \"Difference\" and Its Measurement Criteria"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:29
msgid ""
"When we talk about the \"difference\" between two text files, what we are"
" actually referring to is a series of editing steps that can transform "
"text a into text b."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:31
msgid "Assume the content of text a is"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:33
msgid ""
"A\n"
"B\n"
"C\n"
"A\n"
"B\n"
"B\n"
"A\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:43
msgid "Assume the content of text b is"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:45
msgid ""
"C\n"
"B\n"
"A\n"
"B\n"
"A\n"
"C\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:54
msgid ""
"To transform text a into text b, the simplest edit sequence is to delete "
"each character in a (indicated with a minus sign) and then insert each "
"character in b (indicated with a plus sign)."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:56
msgid ""
"- A\n"
"- B\n"
"- C\n"
"- A\n"
"- B\n"
"- B\n"
"- A\n"
"+ C\n"
"+ B\n"
"+ A\n"
"+ B\n"
"+ A\n"
"+ C\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:72
msgid ""
"But such a result might not be very helpful for programmers reading the "
"code. The following edit sequence is much better, at least it is shorter."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:74
msgid ""
"- A\n"
"- B\n"
"  C\n"
"+ B\n"
"  A\n"
"  B\n"
"- B\n"
"  A\n"
"+ C\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:86
msgid ""
"In fact, it is one of the shortest edit sequences that can transform text"
" a into text b, with 5 operations. If we only measure the length of the "
"edit sequence, this result is satisfactory. But when we look at the "
"various programming languages, we find that there are other metrics that "
"are equally important for user experience. Let's look at the following "
"examples:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:88
msgid ""
"// good quality\n"
"  struct RHSet[T] {\n"
"    set : RHTable[T, Unit]\n"
"  }\n"
"+\n"
"+ fn RHSet::new[T](capacity : Int) -> RHSet[T] {\n"
"+  let set : RHTable[T, Unit]= RHTable::new(capacity)\n"
"+  { set : set }\n"
"+ }\n"
"\n"
"\n"
"// bad quality\n"
"  struct RHSet[T] {\n"
"    set : RHTable[T, Unit]\n"
"+ }\n"
"+\n"
"+ fn RHSet::new[T](capacity : Int) -> RHSet[T] {\n"
"+  let set : RHTable[T, Unit]= RHTable::new(capacity)\n"
"+  { set : set }\n"
"  }\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:111
msgid ""
"When we insert a new function definition at the end of a file, the "
"calculated edit sequence should ideally locate the changes at the end. In"
" similar cases, when there are both deletions and insertions, it is best "
"not to calculate an edit sequence that interleaves these two operations. "
"Here's another example."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:113
msgid ""
"Good:   - one         Bad:    - one\n"
"        - two                 + four\n"
"        - three               - two\n"
"        + four                + five\n"
"        + five                + six\n"
"        + six                 - three\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:122
msgid ""
"Myers' diff algorithm can fulfill all those requirements. It is a greedy "
"algorithm that skips over matching lines whenever possible (avoiding "
"inserting text before `{`), and it also tries to place deletions before "
"insertions, avoiding the latter situation."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:124
msgid "Algorithm Overview"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:126
msgid ""
"The basic idea in Myers' paper is to construct a grid graph of edit "
"sequences and then search for the shortest path on this graph. Using the "
"previous example `a = ABCABBA` and `b = CBABAC`, we create an `(x, y)` "
"coordinate grid."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:128
msgid ""
"    0     1     2     3     4     5     6     7\n"
"\n"
"0   o-----o-----o-----o-----o-----o-----o-----o\n"
"    |     |     | \\   |     |     |     |     |\n"
"    |     |     |  \\  |     |     |     |     |   C\n"
"    |     |     |   \\ |     |     |     |     |\n"
"1   o-----o-----o-----o-----o-----o-----o-----o\n"
"    |     | \\   |     |     | \\   | \\   |     |\n"
"    |     |  \\  |     |     |  \\  |  \\  |     |   B\n"
"    |     |   \\ |     |     |   \\ |   \\ |     |\n"
"2   o-----o-----o-----o-----o-----o-----o-----o\n"
"    | \\   |     |     | \\   |     |     | \\   |\n"
"    |  \\  |     |     |  \\  |     |     |  \\  |   A\n"
"    |   \\ |     |     |   \\ |     |     |   \\ |\n"
"3   o-----o-----o-----o-----o-----o-----o-----o\n"
"    |     | \\   |     |     | \\   | \\   |     |\n"
"    |     |  \\  |     |     |  \\  |  \\  |     |   B\n"
"    |     |   \\ |     |     |   \\ |   \\ |     |\n"
"4   o-----o-----o-----o-----o-----o-----o-----o\n"
"    | \\   |     |     | \\   |     |     | \\   |\n"
"    |  \\  |     |     |  \\  |     |     |  \\  |   A\n"
"    |   \\ |     |     |   \\ |     |     |   \\ |\n"
"5   o-----o-----o-----o-----o-----o-----o-----o\n"
"    |     |     | \\   |     |     |     |     |\n"
"    |     |     |  \\  |     |     |     |     |   C\n"
"    |     |     |   \\ |     |     |     |     |\n"
"6   o-----o-----o-----o-----o-----o-----o-----o\n"
"\n"
"\n"
"       A     B     C     A     B     B     A\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:161
msgid ""
"The upper left of this grid is the starting point `(0, 0)`, and the lower"
" right is the endpoint `(7, 6)`. Moving one step right along the x-axis "
"deletes the corresponding character in a, moving one step down along the "
"y-axis inserts the corresponding character in b, and diagonal lines "
"indicate matching characters that can be skipped without triggering any "
"edits."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:163
msgid ""
"Before writing the actual search code, let's manually perform two rounds "
"of searching:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:165
msgid ""
"The first round starts at `(0, 0)` and moves one step to reach `(0,1)` "
"and `(1,0)`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:167
msgid ""
"The second round starts at `(0,1)` and `(1,0)`. From `(0,1)`, moving down"
" reaches `(0,2)`, but there is a diagonal line leading to `(1,3)`, so the"
" final point is `(1,3)`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:169
msgid "The entire Myers algorithm is based on this kind of breadth-first search."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:171
#: ../../tutorial/example/segment-tree/segment-tree.md:33
#: ../../tutorial/example/segment-tree/segment-tree2.md:39
msgid "Implementation"
msgstr "实现"

#: ../../tutorial/example/myers-diff/myers-diff.md:173
msgid ""
"We have outlined the basic idea, now it's time to consider the design in "
"detail. The input to the algorithm is two strings, but the search needs "
"to be conducted on a graph. It's a waste of both memory and time to "
"construct the graph and then search it."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:175
msgid ""
"The implementation of the Myers algorithm adopts a clever approach by "
"defining a new coordinate `k = x - y`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:177
msgid "Moving right increases `k` by one."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:179
msgid "Moving left decreases `k` by one."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:181
msgid "Moving diagonally down-left keeps `k` unchanged."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:183
msgid ""
"Let's define another coordinate `d` to represent the depth of the search."
" Using `d` as the horizontal axis and `k` as the vertical axis, we can "
"draw a tree diagram of the search process."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:185
msgid ""
"    |      0     1     2     3     4     5\n"
"----+--------------------------------------\n"
"    |\n"
" 4  |                             7,3\n"
"    |                           /\n"
" 3  |                       5,2\n"
"    |                     /\n"
" 2  |                 3,1         7,5\n"
"    |               /     \\     /     \\\n"
" 1  |           1,0         5,4         7,6\n"
"    |         /     \\           \\\n"
" 0  |     0,0         2,2         5,5\n"
"    |         \\                       \\\n"
"-1  |           0,1         4,5         5,6\n"
"    |               \\     /     \\\n"
"-2  |                 2,4         4,6\n"
"    |                     \\\n"
"-3  |                       3,6\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:206
msgid ""
"You can see that in each round of searching, `k` is strictly within the "
"range `[-d, d]` (because in one move, it can at most increase or decrease"
" by one from the previous round), and the `k` values between points have "
"an interval of 2. The basic idea of Myers' algorithm comes from this "
"idea: searching by iterating over `d` and `k`. Of course, it also needs "
"to save the `x` coordinates of each round for use in the next round of "
"searching."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:208
msgid "Let's first define the `Line` struct, which represents a line in the text."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:210
msgid ""
"///|\n"
"struct Line {\n"
"  number : Int // Line number\n"
"  text : String // Does not include newline\n"
"} derive(Show)\n"
"\n"
"///|\n"
"fn Line::new(number : Int, text : String) -> Line {\n"
"  Line::{ number, text }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:216
msgid ""
"Then, define a helper function that splits a string into `Array[Line]` "
"based on newline characters. Note that line numbers start from 1."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:218
msgid ""
"fn lines(str : String) -> Array[Line] {\n"
"  let lines = Array::new(capacity=50)\n"
"  let mut line_number = 0\n"
"  for line in str.split(\"\\n\") {\n"
"    line_number = line_number + 1\n"
"    lines.push(Line::new(line_number, line))\n"
"  } else {\n"
"    return lines\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:224
msgid ""
"Next, we need to wrap the array so that it supports negative indexing "
"because we will use the value of `k` as an index."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:226
msgid ""
"type BPArray[T] Array[T] // BiPolar Array \n"
"\n"
"fn BPArray::make[T](capacity : Int, default : T) -> BPArray[T] {\n"
"  let arr = Array::make(capacity, default)\n"
"  BPArray(arr)\n"
"}\n"
"\n"
"fn copy(self : BPArray[Int]) -> BPArray[Int] {\n"
"  let BPArray(arr) = self\n"
"  let newarr = Array::make(arr.length(), 0)\n"
"  for i = 0; i < arr.length(); i = i + 1 {\n"
"    newarr[i] = arr[i]\n"
"  } else {\n"
"    BPArray(newarr)\n"
"  }\n"
"}\n"
"\n"
"fn op_get[T](self : BPArray[T], idx : Int) -> T {\n"
"  let BPArray(arr) = self\n"
"  if idx < 0 {\n"
"    arr[arr.length() + idx]\n"
"  } else {\n"
"    arr[idx]\n"
"  }\n"
"}\n"
"\n"
"fn op_set[T](self : BPArray[T], idx : Int, elem : T) -> Unit {\n"
"  let BPArray(arr) = self\n"
"  if idx < 0 {\n"
"    arr[arr.length() + idx] = elem\n"
"  } else {\n"
"    arr[idx] = elem\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:232
msgid ""
"Now we can start writing the search function. Before searching for the "
"complete path, let's start with our first goal to find the length of the "
"shortest path (equal to the search depth). Here is the basic framework:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:235
msgid ""
"fn shortst_edit(old~ : Array[Line], new~ : Array[Line]) -> Int {\n"
"  let n = old.length()\n"
"  let m = new.length()\n"
"  let max = n + m\n"
"  let v = BPArray::make(2 * max + 1, 0)\n"
"  for d = 0; d < max + 1; d = d + 1 {\n"
"    for k = -d; k < d + 1; k = k + 2 {\n"
"    ......\n"
"    }\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:249
msgid ""
"In the most extreme case (the two texts have no matching lines), it can "
"be inferred that the maximum number of steps needed is `n + m`, and the "
"minimum is 0. Therefore, set the variable `max = n + m`. The array `v` "
"uses `k` as an index to store the historical record of `x` values. Since "
"`k` ranges from `[-d, d]`, the size of this array is set to `2 * max + "
"1`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:251
msgid ""
"But even at this point, it is still difficult to figure out what to do "
"next, so let's only consider the case `d = 0; k = 0` for now. At this "
"point, it must be at `(0, 0)`. Also, if the beginnings of the two texts "
"are the same, they can be skipped directly. We write the final "
"coordinates of this round into the array `v`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:254
msgid ""
"if d == 0 { // When d equals 0, k must also equal 0\n"
"  x = 0\n"
"  y = x - k\n"
"  while x < n && y < m && old[x].text == new[y].text {\n"
"    // Skip all matching lines\n"
"    x = x + 1\n"
"    y = y + 1\n"
"  }\n"
"  v[k] = x\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:267
msgid ""
"When `d > 0`, the coordinate information stored from the previous round "
"is required. When we know the `k` value of a point and the coordinates of"
" the points from the previous round of searching, the value of `v[k]` is "
"easy to deduce. Because with each step k can only increase or decrease by"
" one, `v[k]` in the search tree must extend from either `v[k - 1]` or "
"`v[k + 1]`. The next question is: how to choose between the two paths "
"ending at `v[k - 1]` and `v[k + 1]`?"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:269
msgid "There are two boundary cases: `k == -d` and `k == d`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:271
msgid "When `k == -d`, you can only choose `v[k + 1]`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:273
msgid "When `k == -d`, you can only choose `v[k - 1]`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:275
msgid ""
"Recalling the requirement mentioned earlier: arranging deletions before "
"insertions as much as possible, this essentially means choosing the "
"position with the largest `x` value from the previous position."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:278
msgid ""
"if k == -d {\n"
"  x = v[k + 1]\n"
"} else if k == d {\n"
"  x = v[k - 1] + 1 // add 1 to move horizontally\n"
"} else if v[k - 1] < v[k + 1] {\n"
"  x = v[k + 1]\n"
"} else {\n"
"  x = v[k - 1] + 1\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:290
msgid "Merging these four branches, we get the following code:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:293
msgid ""
"if k == -d || (k != d && v[k - 1] < v[k + 1]) {\n"
"  x = v[k + 1]\n"
"} else {\n"
"  x = v[k - 1] + 1\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:301
msgid "Combining all the steps above, we get the following code:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:303
msgid ""
"fn shortest_edit(old~ : Array[Line], new~ : Array[Line]) -> Int {\n"
"  let n = old.length()\n"
"  let m = new.length()\n"
"  let max = n + m\n"
"  let v = BPArray::make(2 * max + 1, 0)\n"
"  // v[1] = 0\n"
"  for d = 0; d < max + 1; d = d + 1 {\n"
"    for k = -d; k < d + 1; k = k + 2 {\n"
"      let mut x = 0\n"
"      let mut y = 0\n"
"      // if d == 0 {\n"
"      //   x = 0\n"
"      // }\n"
"      if k == -d || (k != d && v[k - 1] < v[k + 1]) {\n"
"        x = v[k + 1]\n"
"      } else {\n"
"        x = v[k - 1] + 1\n"
"      }\n"
"      y = x - k\n"
"      while x < n && y < m && old[x].text == new[y].text {\n"
"        // Skip all matching lines\n"
"        x = x + 1\n"
"        y = y + 1\n"
"      }\n"
"      v[k] = x\n"
"      if x >= n && y >= m {\n"
"        return d\n"
"      }\n"
"    }\n"
"  } else {\n"
"    abort(\"impossible\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:309
msgid ""
"Since the initial value of the array is 0, we can omit the branch for `d "
"== 0`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:313
msgid ""
"We have implemented an incomplete version of Myers' algorithm, which "
"completes the forward path search. In the next article, we will implement"
" the backtracking to restore the complete edit path and write a function "
"to output a colored diff."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:315
msgid "This article references:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:317
msgid ""
"[https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-"
"part-2/](https://blog.jcoglan.com/2017/02/15/the-myers-diff-algorithm-"
"part-2/)"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff.md:319
msgid "Thanks to the author James Coglan."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:1
msgid "Myers diff 2"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:3
msgid ""
"This is the second post in the diff series. In the [previous "
"one](https://www.moonbitlang.com/docs/examples/myers-diff), we learned "
"how to transform the process of computing diffs into a graph search "
"problem and how to search for the shortest edit distance. In this "
"article, we will learn how to extend the search process from the previous"
" post to obtain the complete edit sequence."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:5
msgid "Recording the Search Process"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:7
msgid ""
"The first step to obtaining the complete edit sequence is to save the "
"entire editing process. This step is relatively simple; we just need to "
"save the current search depth `d` and the graph node with depth `d` at "
"the beginning of each search round."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:9
msgid ""
"fn shortest_edit(\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line]\n"
") -> Array[(BPArray[Int], Int)] {\n"
"  let n = old.length()\n"
"  let m = new.length()\n"
"  let max = n + m\n"
"  let v = BPArray::make(2 * max + 1, 0)\n"
"  let trace = []\n"
"  fn push(v : BPArray[Int], d : Int) -> Unit {\n"
"    trace.push((v, d))\n"
"  }\n"
"  // v[1] = 0\n"
"  for d = 0; d < max + 1; d = d + 1 {\n"
"    push(v.copy(), d) \n"
"    for k = -d; k < d + 1; k = k + 2 {\n"
"      let mut x = 0\n"
"      let mut y = 0\n"
"      // if d == 0 {\n"
"      //   x = 0\n"
"      // }\n"
"      if k == -d || (k != d && v[k - 1] < v[k + 1]) {\n"
"        x = v[k + 1]\n"
"      } else {\n"
"        x = v[k - 1] + 1\n"
"      }\n"
"      y = x - k\n"
"      while x < n && y < m && old[x].text == new[y].text {\n"
"        x = x + 1\n"
"        y = y + 1\n"
"      }\n"
"      v[k] = x\n"
"      if x >= n && y >= m {\n"
"        return trace\n"
"      }\n"
"    }\n"
"  } else {\n"
"    abort(\"impossible\")\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:15
msgid "Backtracking the Edit Path"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:17
msgid ""
"After recording the entire search process, the next step is to walk back "
"from the endpoint to find the path taken. But before we do that, let's "
"first define the `Edit` type."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:19
msgid ""
"enum Edit {\n"
"  Insert(new~ : Line)\n"
"  Delete(old~ : Line)\n"
"  Equal(old~ : Line, new~ : Line) // old, new\n"
"} derive(Show)\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:25
msgid "Next, let's perform the backtracking."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:27
msgid ""
"fn backtrack(\n"
"  new~ : Array[Line],\n"
"  old~ : Array[Line],\n"
"  trace : Array[(BPArray[Int], Int)]\n"
") -> Array[Edit] {\n"
"  let mut x = old.length()\n"
"  let mut y = new.length()\n"
"  let edits = Array::new(capacity=trace.length())\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:33
msgid ""
"The method of backtracking is essentially the same as forward search, "
"just in reverse."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:35
msgid "Calculate the current `k` value using `x` and `y`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:37
msgid ""
"Access the historical records and use the same judgment criteria as in "
"forward search to find the `k` value at the previous search round."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:39
msgid "Restore the coordinates of the previous search round."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:41
msgid "Try free movement and record the corresponding edit actions."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:43
msgid "Determine the type of edit that caused the change in `k` value."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:45
msgid "Continue iterating."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:47
msgid ""
"for i = trace.length() - 1; i >= 0; i = i - 1 {\n"
"  let (v, d) = trace[i]\n"
"  let k = x - y\n"
"  let prev_k = if k == -d || (k != d && v[k - 1] < v[k + 1]) {\n"
"    k + 1\n"
"  } else {\n"
"    k - 1\n"
"  }\n"
"  let prev_x = v[prev_k]\n"
"  let prev_y = prev_x - prev_k\n"
"  while x > prev_x && y > prev_y {\n"
"    x = x - 1\n"
"    y = y - 1\n"
"    edits.push(Equal(old=old[x], new=new[y]))\n"
"  }\n"
"  if d > 0 {\n"
"    if x == prev_x {\n"
"      edits.push(Insert(new=new[prev_y]))\n"
"    } else if y == prev_y {\n"
"      edits.push(Delete(old=old[prev_x]))\n"
"    }\n"
"    x = prev_x\n"
"    y = prev_y\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:54
msgid "Combining the two functions, we get a complete `diff` implementation."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:56
msgid ""
"fn diff(old~ : Array[Line], new~ : Array[Line]) -> Array[Edit] {\n"
"  let trace = shortest_edit(old~, new~)\n"
"  backtrack(old~, new~, trace)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:62
msgid "Printing the Diff"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:64
msgid ""
"To print a neat diff, we need to left-align the text. Also, due to the "
"order issue during backtracking, we need to print from back to front."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:66
msgid ""
"let line_width = 4\n"
"\n"
"fn pad_right(s : String, width : Int) -> String {\n"
"  String::make(width - s.length(), ' ') + s\n"
"}\n"
"\n"
"fn pprint_edit(edit : Edit) -> String {\n"
"  match edit {\n"
"    Insert(_) as edit => {\n"
"      let tag = \"+\"\n"
"      let old_line = pad_right(\"\", line_width)\n"
"      let new_line = pad_right(edit.new.number.to_string(), line_width)\n"
"      let text = edit.new.text\n"
"      \"\\{tag} \\{old_line} \\{new_line}    \\{text}\"\n"
"    }\n"
"    Delete(_) as edit => {\n"
"      let tag = \"-\"\n"
"      let old_line = pad_right(edit.old.number.to_string(), line_width)\n"
"      let new_line = pad_right(\"\", line_width)\n"
"      let text = edit.old.text\n"
"      \"\\{tag} \\{old_line} \\{new_line}    \\{text}\"\n"
"    }\n"
"    Equal(_) as edit => {\n"
"      let tag = \" \"\n"
"      let old_line = pad_right(edit.old.number.to_string(), line_width)\n"
"      let new_line = pad_right(edit.new.number.to_string(), line_width)\n"
"      let text = edit.old.text\n"
"      \"\\{tag} \\{old_line} \\{new_line}    \\{text}\"\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"fn pprint_diff(diff : Array[Edit]) -> String {\n"
"  let buf = @buffer.new(size_hint = 100)\n"
"  for i = diff.length(); i > 0; i = i - 1 {\n"
"    buf.write_string(pprint_edit(diff[i - 1]))\n"
"    buf.write_char('\\n')\n"
"  } else {\n"
"    buf.contents().to_unchecked_string()\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:72
msgid "The result is as follows:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:74
msgid ""
"-    1         A\n"
"-    2         B\n"
"     3    1    C\n"
"+         2    B\n"
"     4    3    A\n"
"     5    4    B\n"
"-    6         B\n"
"     7    5    A\n"
"+         6    C\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff2.md:88
msgid ""
"The Myers algorithm demonstrated above is complete, but due to the "
"frequent copying of arrays, it has a very large space overhead. "
"Therefore, most software like Git uses a linear variant of the diff "
"algorithm (found in the appendix of the original paper). This variant may"
" sometimes produce diffs of lower quality (harder for humans to read) "
"than the standard Myers algorithm but can still ensure the shortest edit "
"sequence."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:1
msgid "Myers diff 3"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:3
msgid ""
"This article is the third in the [diff "
"series](https://docs.moonbitlang.com/examples/myers-diff). In the "
"[previous part](https://docs.moonbitlang.com/examples/myers-diff2), we "
"explored the full Myers algorithm and its limitations. In this post, "
"we'll learn how to implement a variant of the Myers algorithm that "
"operates with linear space complexity."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:5
msgid "Divide and Conquer"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:7
msgid ""
"The linear variant of Myers' diff algorithm used by Git employs a concept"
" called the _Snake_ (sometimes referred to as the _Middle Snake_) to "
"break down the entire search process. A Snake in the edit graph "
"represents a diagonal movement of 0 to N steps after a single left or "
"down move. The linear Myers algorithm finds the middle Snake on the "
"optimal edit path and uses it to divide the entire edit graph into two "
"parts. The subsequent steps apply the same technique to the resulting "
"subgraphs, eventually producing a complete edit path."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:9
msgid ""
"    0   1   2   3   4   5   6   7   8   9  10  11  12  13  14\n"
" 0  o---o---o---o---o---o---o\n"
"    |   |   |   |   |   |   |\n"
" 1  o---o---o---o---o---o---o\n"
"    |   | \\ |   |   |   |   |\n"
" 2  o---o---o---o---o---o---o\n"
"    |   |   |   |   |   |   |\n"
" 3  o---o---o---o---o---o---o\n"
"    |   |   |   |   | \\ |   |\n"
" 4  o---o---o---o---o---o---o\n"
"    |   |   |   |   |   |   |\n"
" 5  o---o---o---o---o---o---o\n"
"                              \\\n"
" 6                              @\n"
"                                  \\\n"
" 7                                  @---o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
" 8                                      o---o---o---o---o---o\n"
"                                        | \\ |   |   |   |   |\n"
" 9                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
"10                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
"11                                      o---o---o---o---o---o\n"
"                                        |   |   | \\ |   |   |\n"
"12                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   |   |\n"
"13                                      o---o---o---o---o---o\n"
"                                        |   |   |   |   | \\ |\n"
"14                                      o---o---o---o---o---o\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:42
msgid ""
"A quick recap: The optimal edit path is the one that has the shortest "
"distance to the endpoint (a diagonal distance of zero), and there can be "
"more than one such path."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:44
msgid ""
"Attentive readers may have noticed a chicken-and-egg problem: to find a "
"Snake, you need an optimal edit path, but to get an optimal edit path, it"
" seems like you need to run the original Myers algorithm first."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:46
msgid ""
"In fact, the idea behind the linear Myers algorithm is somewhat "
"unconventional: it alternates the original Myers algorithm from both the "
"top-left and bottom-right corners, but without storing the history. "
"Instead, it simply checks if the searches from both sides overlap. When "
"they do, the overlapping portion is returned as the Middle Snake."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:48
msgid ""
"This approach seems straightforward, but there are still some details to "
"sort out."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:50
msgid ""
"When searching from the bottom-right, the diagonal coordinate can no "
"longer be referred to as _k_. We need to define a new diagonal coordinate"
" **c = k - delta**. This coordinate is the mirror image of _k_, perfectly"
" suited for reverse direction search."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:52
msgid ""
"        x                       k\n"
"                                  0     1     2     3\n"
"        0     1     2     3         \\     \\     \\     \\\n"
"  y  0  o-----o-----o-----o           o-----o-----o-----o\n"
"        |     |     |     |      -1   |     |     |     | \\\n"
"        |     |     |     |         \\ |     |     |     |   2\n"
"     1  o-----o-----o-----o           o-----o-----o-----o\n"
"        |     | \\   |     |      -2   |     | \\   |     | \\\n"
"        |     |   \\ |     |         \\ |     |   \\ |     |   1\n"
"     2  o-----o-----o-----o           o-----o-----o-----o\n"
"                                        \\     \\     \\     \\\n"
"                                        -3    -2    -1      0\n"
"                                                              c\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:68
msgid ""
"How do we determine if the searches overlap? Simply check if the position"
" on a diagonal line in the forward search has an _x_ value greater than "
"that in the reverse search. However, since the _k_ and _c_ coordinates "
"differ for the same diagonal, the conversion can be a bit tricky."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:70
msgid "Code Implementation"
msgstr "代码实现"

#: ../../tutorial/example/myers-diff/myers-diff3.md:72
msgid ""
"We'll start by defining `Snake` and `Box` types, representing the middle "
"snake and the sub-edit graphs (since they're square, we call them `Box`)."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:74
msgid ""
"struct Box {\n"
"  left : Int\n"
"  right : Int\n"
"  top : Int\n"
"  bottom : Int\n"
"} derive(Show)\n"
"\n"
"struct Snake {\n"
"  start : (Int, Int)\n"
"  end : (Int, Int)\n"
"} derive(Show)\n"
"\n"
"fn width(self : Box) -> Int {\n"
"  self.right - self.left\n"
"}\n"
"\n"
"fn height(self : Box) -> Int {\n"
"  self.bottom - self.top\n"
"}\n"
"\n"
"fn size(self : Box) -> Int {\n"
"  self.width() + self.height()\n"
"}\n"
"\n"
"fn delta(self : Box) -> Int {\n"
"  self.width() - self.height()\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:80
msgid ""
"To avoid getting bogged down in details too early, let's assume we "
"already have a function `midpoint : (Box, Array[Line], Array[Line]) -> "
"Snake?` to find the middle snake. Then, we can build the function "
"`find_path` to search for the complete path."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:82
msgid ""
"fn find_path(\n"
"  box : Box,\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line]\n"
") -> Iter[(Int, Int)]? {\n"
"  guard let Some(snake) = midpoint(box, old~, new~) else { None => None }"
"\n"
"  let start = snake.start\n"
"  let end = snake.end\n"
"  let headbox = Box::{\n"
"    left: box.left,\n"
"    top: box.top,\n"
"    right: start.0,\n"
"    bottom: start.1,\n"
"  }\n"
"  let tailbox = Box::{\n"
"    left: end.0,\n"
"    top: end.1,\n"
"    right: box.right,\n"
"    bottom: box.bottom,\n"
"  }\n"
"  let head = find_path(headbox, old~, new~).or(Iter::singleton(start))\n"
"  let tail = find_path(tailbox, old~, new~).or(Iter::singleton(end))\n"
"  Some(head.concat(tail))\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:88
msgid ""
"The implementation of `find_path` is straightforward, but `midpoint` is a"
" bit more complex:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:90
msgid "For a `Box` of size 0, return `None`."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:91
msgid ""
"Calculate the search boundaries. Since forward and backward searches each"
" cover half the distance, divide by two. However, if the size of the "
"`Box` is odd, add one more to the forward search boundary."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:92
msgid "Store the results of the forward and backward searches in two arrays."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:93
msgid ""
"Alternate between forward and backward searches, returning `None` if no "
"result is found."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:95
msgid ""
"fn midpoint(self : Box, old~ : Array[Line], new~ : Array[Line]) -> Snake?"
" {\n"
"  if self.size() == 0 {\n"
"    return None\n"
"  }\n"
"  let max = {\n"
"    let half = self.size() / 2\n"
"    if is_odd(self.size()) {\n"
"      half + 1\n"
"    } else {\n"
"      half\n"
"    }\n"
"  }\n"
"  let vf = BPArray::make(2 * max + 1, 0)\n"
"  vf[1] = self.left\n"
"  let vb = BPArray::make(2 * max + 1, 0)\n"
"  vb[1] = self.bottom\n"
"  for d = 0; d < max + 1; d = d + 1 {\n"
"    match self.forward(forward = vf, backward = vb, d, old~, new~) {\n"
"      None =>\n"
"        match self.backward(forward = vf, backward = vb, d, old~, new~) {"
"\n"
"          None => continue\n"
"          res => return res\n"
"        }\n"
"      res => return res\n"
"    }\n"
"  } else {\n"
"    None\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:101
msgid ""
"The forward and backward searches have some modifications compared to the"
" original Myers algorithm, which need a bit of explanation:"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:103
msgid ""
"Since we need to return the snake, the search process must calculate the "
"previous coordinate (`px` stands for previous x)."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:104
msgid ""
"The search now works within a `Box` (not the global edit graph), so "
"calculating `y` from `x` (or vice versa) requires conversion."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:105
msgid ""
"The backward search minimizes `y` as a heuristic strategy, but minimizing"
" `x` would also work."
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:107
msgid ""
"fn forward(\n"
"  self : Box,\n"
"  forward~ : BPArray[Int],\n"
"  backward~ : BPArray[Int],\n"
"  depth : Int,\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line]\n"
") -> Snake? {\n"
"  for k = depth; k >= -depth; k = k - 2 {\n"
"    let c = k - self.delta()\n"
"    let mut x = 0\n"
"    let mut px = 0\n"
"    if k == -depth || (k != depth && forward[k - 1] < forward[k + 1]) {\n"
"      x = forward[k + 1]\n"
"      px = x\n"
"    } else {\n"
"      px = forward[k - 1]\n"
"      x = px + 1\n"
"    }\n"
"    let mut y = self.top + (x - self.left) - k\n"
"    let py = if depth == 0 || x != px { y } else { y - 1 }\n"
"    while x < self.right && y < self.bottom && old[x].text == new[y].text"
" {\n"
"      x = x + 1\n"
"      y = y + 1\n"
"    }\n"
"    forward[k] = x\n"
"    if is_odd(self.delta()) &&\n"
"      (c >= -(depth - 1) && c <= depth - 1) &&\n"
"      y >= backward[c] {\n"
"      return Some(Snake::{ start: (px, py), end: (x, y) })\n"
"    }\n"
"  }\n"
"  return None\n"
"}\n"
"\n"
"\n"
"fn backward(\n"
"  self : Box,\n"
"  forward~ : BPArray[Int],\n"
"  backward~ : BPArray[Int],\n"
"  depth : Int,\n"
"  old~ : Array[Line],\n"
"  new~ : Array[Line]\n"
") -> Snake? {\n"
"  for c = depth; c >= -depth; c = c - 2 {\n"
"    let k = c + self.delta()\n"
"    let mut y = 0\n"
"    let mut py = 0\n"
"    if c == -depth || (c != depth && backward[c - 1] > backward[c + 1]) {"
"\n"
"      y = backward[c + 1]\n"
"      py = y\n"
"    } else {\n"
"      py = backward[c - 1]\n"
"      y = py - 1\n"
"    }\n"
"    let mut x = self.left + (y - self.top) + k\n"
"    let px = if depth == 0 || y != py { x } else { x + 1 }\n"
"    while x > self.left && y > self.top && old[x - 1].text == new[y - "
"1].text {\n"
"      x = x - 1\n"
"      y = y - 1\n"
"    }\n"
"    backward[c] = y\n"
"    if is_even(self.delta()) && (k >= -depth && k <= depth) && x <= "
"forward[k] {\n"
"      return Some(Snake::{ start: (x, y), end: (px, py) })\n"
"    }\n"
"  }\n"
"  return None\n"
"}\n"
msgstr ""

#: ../../tutorial/example/myers-diff/myers-diff3.md:115
msgid ""
"In addition to the default diff algorithm, Git also offers another diff "
"algorithm called patience diff. It differs significantly from Myers diff "
"in approach and sometimes produces more readable diff results."
msgstr ""

#: ../../tutorial/example/segment-tree/index.md:1
msgid "Segment Tree"
msgstr "线段树"

#: ../../tutorial/example/segment-tree/index.md:3
msgid ""
"The Segment Tree is a common data structure used to solve various range "
"modification and query problems. For instance, consider the following "
"problem:"
msgstr "先断树是一种常见的数据结构，用于一些线性区间的修改、查询问题，比如对于以下问题："

#: ../../tutorial/example/segment-tree/index.md:5
msgid ""
"Given a known-length array of numbers with initial values, we need to "
"perform multiple range addition operations (adding a value to all "
"elements in a range) and range sum operations (calculating the sum of "
"elements in a range)."
msgstr "给出一个长度已知的、有初值的数字数组，接下来要进行许多区间加法操作（将一个区间的数值加到所有元素上）和区间求和操作（计算一个区间的元素和）。"

#: ../../tutorial/example/segment-tree/index.md:7
msgid ""
"Using a standard array, assuming the length og this array is N, each "
"modification and query would take O(N) time. However, after constructing "
"a Segment Tree in O(log N) time, both operations can be performed in "
"O(log N), highlighting the importance of Segment Trees for range queries."
msgstr ""
"如果该问题使用正常的数组方式来遍历求解，假设该数组长度为 N，每次修改和查询的操作耗时是 O(N)的；但线段树经过 O(N log N) "
"的构建之后，可以对上述两个操作做到 O(log N) 的优秀复杂度，足以体现其在区间问题上的重要性。"

#: ../../tutorial/example/segment-tree/index.md:9
msgid ""
"This example illustrates just one simple problem that Segment Trees can "
"address. They can handle much more complex and interesting scenarios. In "
"the upcoming articles, we will explore the concept of Segment Trees and "
"how to implement them in MoonBit, ultimately creating a tree that "
"supports range addition and multiplication, enables range sum queries, "
"and has immutable properties."
msgstr ""
"当然上面的例子只是线段树可以解决的一个简单问题，它可以做到的更复杂、更有趣的事情还有很多。在接下来的几篇文章当中我们将会学习使用线段树的概念以及如何使用"
" MoonBit 实现它，最终我们将一步步实现一棵支持区间加法与乘法、并可以查询区间和、拥有不可变特性的线段树。"

#: ../../tutorial/example/segment-tree/index.md:11
msgid ""
"In this section, we will learn the basic principles of Segment Trees and "
"how to write a simple Segment Tree in MoonBit that supports point "
"modifications and queries."
msgstr "本节我们将学习线段树的基本原理以及如何使用 MoonBit 编写一棵最基本的支持单点修改、查询的线段树。"

#: ../../tutorial/example/segment-tree/segment-tree.md:1
msgid "Segment Trees (Part 1)"
msgstr "线段树（第一部分）"

#: ../../tutorial/example/segment-tree/segment-tree.md:3
msgid "What is a Segment Tree?"
msgstr "线段树是什么？"

#: ../../tutorial/example/segment-tree/segment-tree.md:5
msgid ""
"This section focuses on concepts and theory. If you're already familiar "
"with Segment Trees and their principles, feel free to skip to the next "
"section."
msgstr "本节是纯粹的概念、理论内容，如果读者已经了解并且熟悉线段树的构成与其原理，可以直接阅读下一节内容。"

#: ../../tutorial/example/segment-tree/segment-tree.md:7
msgid ""
"As mentioned in the introduction, Segment Trees address a class of range "
"problems, but what do they look like, and what is the principle behind "
"their excellent complexity?"
msgstr "就像引言当中所说的，线段树可以解决一类区间问题，但他长什么样子，能做到如此优秀复杂度的原理又是什么呢？"

#: ../../tutorial/example/segment-tree/segment-tree.md:9
msgid ""
"Let's consider a linear sequence of numbers as an example. If we want to "
"build a Segment Tree from it, it will look like this:"
msgstr "我们以下图一个线性的数字序列为例，如果我们希望以它建立一棵线段树，那么它将会长这个样子："

#: ../../tutorial/example/segment-tree/segment-tree.md:11
msgid "![build segment tree](/imgs/segment-tree-build.png)"
msgstr "![构建线段树](/imgs/segment-tree-build.png)"

#: ../../tutorial/example/segment-tree/segment-tree.md:11
msgid "build segment tree"
msgstr "构建线段树"

#: ../../tutorial/example/segment-tree/segment-tree.md:13
msgid ""
"We can see that we recursively divide the linear sequence into two equal "
"parts (with one side having an extra element if the length is odd) until "
"we reach segments of length one. During this process, we compute the sum "
"of each segment (shown in parentheses), thereby creating a Segment Tree "
"that supports range sum queries from a linear sequence."
msgstr "可以看到我们把一个线性序列的区间层层分而治之，每次分割为两个对等（如果是奇数则一边多一个）的两个区间（区间范围下标在图示中），最终直到分割为长度为一的区间，并且在此过程中计算了其中每个区间元素的加和（在括号中），这样就从一个线性序列创建了一棵支持查询区间和线段树。"

#: ../../tutorial/example/segment-tree/segment-tree.md:15
msgid ""
"So, how does it work when querying a range sum? Let's take the example of"
" querying the sum from index 1 to 6:"
msgstr "那么在查询区间和的时候，它如何工作呢？我们以查询区间 1-6 的和为例："

#: ../../tutorial/example/segment-tree/segment-tree.md:17
msgid "![query segment tree](/imgs/segment-tree-query.png)"
msgstr "![查询线段树](/imgs/segment-tree-query.png)"

#: ../../tutorial/example/segment-tree/segment-tree.md:17
msgid "query segment tree"
msgstr "查询线段树"

#: ../../tutorial/example/segment-tree/segment-tree.md:19
msgid ""
"The highlighted parts in the diagram sum up to the total for the range "
"1-6, and we didn't have to consider all elements; we simply selected the "
"minimum number of segments needed to obtain our result and combined them."
" We can traverse the Segment Tree from top to bottom to determine the "
"intersections and containment relationships between segments to select "
"the appropriate ranges."
msgstr ""
"可以发现图中的标红部分加起来就等于区间 1-6 "
"的区间和，而我们并没有统计到所有元素，只是选取了最少的区间来频出我们需要求解的区间，并且把我们要求的结果（此处为和）合并起来即可得到最终解。而我们只需要从上到下遍历这棵线段树来判断区间之间的交集/包含关系即可选择到符合条件的区间。"

#: ../../tutorial/example/segment-tree/segment-tree.md:21
msgid "Specifically:"
msgstr "具体来说："

#: ../../tutorial/example/segment-tree/segment-tree.md:23
msgid ""
"First, we check the relationship between the ranges 1-7 and 1-6. The "
"latter is a subset of the former, so the data from 1-7 cannot be used in "
"our calculation, and we proceed to explore its two child nodes."
msgstr "首先询问区间 1-7 与 1-6 的关系，显然后者为前者的子集，当前 1-7 的数据不能用于统计，因此继续向下遍历两个子节点。"

#: ../../tutorial/example/segment-tree/segment-tree.md:24
msgid ""
"Next, we check the relationship between 1-3 and 1-6. The former is a "
"subset of the latter, contributing to our result."
msgstr "再询问 1-3 与 1-6 的关系，前者为后者的子集，可以作为解的一部分，统计入当前结果中。"

#: ../../tutorial/example/segment-tree/segment-tree.md:25
msgid ""
"Then, we examine the relationship between 4-7 and 1-6, which overlap, "
"requiring us to explore both child nodes further."
msgstr "接下来询问 4-7 与 1-6 的关系，二者有交集，因此要继续向下遍历两个子节点。"

#: ../../tutorial/example/segment-tree/segment-tree.md:26
msgid ""
"And we examine the relationship between 4-5 and 1-6, just as the third "
"step."
msgstr "然后询问 4-5 与 1-6 的关系，此处与第三条一致。"

#: ../../tutorial/example/segment-tree/segment-tree.md:27
msgid "We repeat this process..."
msgstr "以此类推..."

#: ../../tutorial/example/segment-tree/segment-tree.md:29
msgid ""
"Based on binary decomposition, we will query at most Log N segments for "
"any range of length N, ensuring guaranteed complexity."
msgstr "根据二进制分解的知识，我们对任何长度为 N 的区间最多只会求解 Log N 个区间，因此复杂度是可以保证的。"

#: ../../tutorial/example/segment-tree/segment-tree.md:31
msgid ""
"This section only discusses the query operation; we will elaborate on the"
" principles and implementation of modification operations in the next "
"section."
msgstr "这里仅聊到查询操作，关于线段树上的修改操作的原理和实现我们将会在下一节详细说明。"

#: ../../tutorial/example/segment-tree/segment-tree.md:35
#: ../../tutorial/example/segment-tree/segment-tree2.md:41
msgid "Basic Definition"
msgstr "基础定义"

#: ../../tutorial/example/segment-tree/segment-tree.md:37
msgid "We use a classic approach to represent the Segment Tree:"
msgstr "我们采用一个非常经典的方法来表达线段树："

#: ../../tutorial/example/segment-tree/segment-tree.md:39
msgid ""
"enum Node {\n"
"  Nil\n"
"  Node(Int, Node, Node)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:45
msgid ""
"Here, `Nil` represents an empty tree, while a `Node` contains the stored "
"data (of type Int) and its left and right children."
msgstr "其中 `Nil` 代表空树，而一个 `Node` 则包含一个它所储存的数据（为 Int 类型）和左右两个节点。"

#: ../../tutorial/example/segment-tree/segment-tree.md:47
#: ../../tutorial/example/segment-tree/segment-tree2.md:53
msgid "Building the Tree"
msgstr "建树"

#: ../../tutorial/example/segment-tree/segment-tree.md:49
msgid ""
"Building the tree refers to the process of abstracting a linear sequence "
"into a Segment Tree, commonly referred to as `build`."
msgstr "建树是指将一个线性序列抽象为线段树的过程，一般将其称为 `build` 。"

#: ../../tutorial/example/segment-tree/segment-tree.md:51
msgid ""
"To start, we should write an overloaded `op_add` function for the `Node` "
"type to assist with the tree-building process:"
msgstr "作为前置，我们应该根据需求为 `Node` 类型编写一个 `op_add` 的重载来配合下面建树的过程："

#: ../../tutorial/example/segment-tree/segment-tree.md:53
msgid ""
"fn op_add(self : Node, v : Node) -> Node {\n"
"  match (self, v) {\n"
"    (Node(left, _, _), Node(right, _, _)) => Node(left + right, self, v)\n"
"    (Node(_), Nil) => self\n"
"    (Nil, Node(_)) => v\n"
"    (Nil, Nil) => Nil\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:59
msgid ""
"With this operation defined, we can easily merge two `Node` instances "
"while maintaining the segment sums, laying the foundation for building "
"the tree. In some descriptions of Segment Trees, this process is also "
"called `pushup`."
msgstr ""
"定义这一运算之后就可以轻松的向上合并两个 `Node` "
"节点，并在此过程中维护区间的和，为我们建树打下了基础，在有些线段树的叙述当中，这个过程也叫做 `pushup` 。"

#: ../../tutorial/example/segment-tree/segment-tree.md:61
msgid ""
"We can leverage MoonBit's `ArrayView` feature (known as `slice` in some "
"languages) to recursively build the tree from a segment of a linear "
"structure at a low cost, achieving O(Log N) complexity:"
msgstr ""
"我们可以用 MoonBit 的 `ArrayView` 特性（某些语言当中也叫做 `slice` "
"）作为参数来低成本的取出一个线性结构的一段进行递归建树，这个过程是 `O(N Log N)` 的："

#: ../../tutorial/example/segment-tree/segment-tree.md:63
msgid ""
"fn build(data : ArrayView[Int]) -> Node {\n"
"  if data.length() == 1 {\n"
"    Node(data[0], Nil, Nil)\n"
"  } else {\n"
"    let mid = (data.length() + 1) >> 1\n"
"    build(data[0:mid]) + build(data[mid:])\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:69
msgid "Let’s analyze this code:"
msgstr "分析一下这段代码："

#: ../../tutorial/example/segment-tree/segment-tree.md:71
msgid ""
"If the current length is 1, the segment does not need further "
"subdivision, so we return a leaf node with empty left and right branches."
msgstr "首先如果当前长度已经为 1，就证明该区间不再需要细分，直接返回左右分支为空的叶子节点。"

#: ../../tutorial/example/segment-tree/segment-tree.md:72
msgid ""
"Otherwise, we split the segment at the midpoint and recursively build the"
" left and right segments, then merge the results."
msgstr "否则就证明该区间还可被分割，则求其中间值将其分割为两个区间分而治之的建树再通过 `Node` 之间的加法合并。"

#: ../../tutorial/example/segment-tree/segment-tree.md:74
msgid ""
"This code is concise, highly readable, and optimization-friendly, serving"
" as a great learning paradigm for other data structures."
msgstr "这段代码是非常简洁、可读性非常高的，而且对优化非常友好，可以作为后续其他数据结构的范式学习。"

#: ../../tutorial/example/segment-tree/segment-tree.md:76
msgid "Now, let's build a tree and test it:"
msgstr "让我们来建立一棵树并测试看看："

#: ../../tutorial/example/segment-tree/segment-tree.md:78
msgid ""
"test {\n"
"  let tree = build([1, 2, 3, 4, 5][:])\n"
"  @json.inspect!(\n"
"    tree,\n"
"    content=[\n"
"      15,\n"
"      [6, [3, [1, \"Nil\", \"Nil\"], [2, \"Nil\", \"Nil\"]], [3, \"Nil\","
" \"Nil\"]],\n"
"      [9, [4, \"Nil\", \"Nil\"], [5, \"Nil\", \"Nil\"]],\n"
"    ],\n"
"  )\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:84
msgid "Great! We've successfully built the tree!"
msgstr "漂亮，我们已经成功完成了建树的过程！"

#: ../../tutorial/example/segment-tree/segment-tree.md:86
msgid "Querying"
msgstr "查询"

#: ../../tutorial/example/segment-tree/segment-tree.md:88
msgid ""
"Next, we need to implement the query function. Since the nodes of our "
"Segment Tree maintain segment sums, we can write a `query` function to "
"retrieve these sums:"
msgstr "接下来我们要编写查询，因为这棵线段树的节点向上合并时维护的是区间和，因此我们可以编写一个 `query` 函数来查询它："

#: ../../tutorial/example/segment-tree/segment-tree.md:90
msgid ""
"let empty_node : Node = Node(0, Nil, Nil)\n"
"\n"
"fn query(self : Node, l : Int, r : Int, query_l : Int, query_r : Int) -> "
"Node {\n"
"  if query_l > r || l > query_r {\n"
"    empty_node\n"
"  } else if query_l <= l && query_r >= r {\n"
"    self\n"
"  } else {\n"
"    guard let Node(_, left, right) = self\n"
"    let mid = (l + r) >> 1\n"
"    left.query(l, mid, query_l, query_r) +\n"
"    right.query(mid + 1, r, query_l, query_r)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:97
msgid ""
"Here, `l` and `r` represent the currently queried range, while `query_l` "
"and `query_r` denote the range we need to query. Let's break down this "
"implementation:"
msgstr ""
"首先，`l` 与 `r` 是当前函数中已经查询到的区间， `query_l` 与 `query_r` "
"是需要查询的区间，让我们来尝试解析一下这段实现："

#: ../../tutorial/example/segment-tree/segment-tree.md:99
msgid ""
"If the queried range does not overlap with the current range, it "
"contributes nothing to the result. We define an `empty_node` to represent"
" a zero-contribution node and return it."
msgstr "如果需查询的区间和当前的区间状态为互不相交，则对解没有贡献，我们定义了一个 `empty_node` 来表示 0 贡献节点，将其返回则为无贡献。"

#: ../../tutorial/example/segment-tree/segment-tree.md:100
msgid ""
"If the current range is a subset of the queried range, it fully "
"contributes to the result, so we return it directly."
msgstr "如果当前区间就是需查询区间的子集，那么实际上对解的贡献就是它自己，直接返回它即可。"

#: ../../tutorial/example/segment-tree/segment-tree.md:101
msgid ""
"If the current range overlaps with the queried range, we continue "
"searching downwards to find the exact covering ranges, merging the "
"results of the left and right nodes."
msgstr "如果当前区间和需要查询的区间存在交集关系，那么需要继续向下搜索来确定准确的覆盖，因此继续求出中间值向下搜索并且合并两边的 `Node` 结果。"

#: ../../tutorial/example/segment-tree/segment-tree.md:103
msgid "Before We Continue"
msgstr "在继续之前"

#: ../../tutorial/example/segment-tree/segment-tree.md:105
msgid ""
"Notice the highlighted line. When using the `let` to destructure `Node`, "
"we could be sure that the enum being destructured wasn’t `Nil`. However, "
"the compiler couldn't guarantee this, so we would have received a warning"
" for using:"
msgstr ""
"注意被高亮的行。在使用 let 解构 Node 时，我们是可以确定要解构的 enum 一定不是 "
"Nil，但编译器是不能确定这一点的的，所以如果我们尝试这样去解构它："

#: ../../tutorial/example/segment-tree/segment-tree.md:107
msgid "let Node(x, y) = z\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:111
msgid ""
"Although it didn’t affect execution, it was somewhat misleading. With "
"MoonBit’s newly introduced `guard` statement, we can now handle this "
"better using:"
msgstr ""
"会发现编译器实际上给我们了一个警告。尽管不影响运行，但有些误导。因此我们可以用，MoonBit 的 guard 语句，用 guard let "
"这种方法来更好的解决这种需求："

#: ../../tutorial/example/segment-tree/segment-tree.md:113
msgid "guard let Node(x, y) = z\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:117
msgid "Q&A"
msgstr "问与答"

#: ../../tutorial/example/segment-tree/segment-tree.md:119
msgid ""
"**Q:** Why use `Node` as the return value? Can't I destructure and sum "
"the values directly?"
msgstr "问：为什么要用 `Node` 作为返回值，我用相同的逻辑也可以直接把 `Node` 当中的值给解构出来相加呀？"

#: ../../tutorial/example/segment-tree/segment-tree.md:120
msgid ""
"**A:** We have defined an addition operation for `Node`. Consider a "
"scenario where we need to maintain not just the sum but also the minimum "
"value of a range. In that case, we can modify the `op_add` logic to "
"maintain the minimum while the `query` function remains unaffected. It "
"ultimately returns a `Node` that can contain all necessary information, "
"so let's stick with using `Node`!"
msgstr ""
"答：首先，我们为 `Node` "
"已经编写了加和运算，不妨考虑一种情况，我们不止要维护区间和，而是要同时维护区间和还有区间最小值，这时候我们只需要更改 `Node` 的 "
"`op_add` 逻辑来维护最小值即可，而 `query` 函数和我们要维护的数据没有关系，它最终返回的是一个 `Node` "
"，它可以求出所有信息！所以不妨就让我们使用 `Node` ！"

#: ../../tutorial/example/segment-tree/segment-tree.md:122
msgid "**Q:** Shouldn't the `empty_node` change in this case?"
msgstr "问：你说的这种情况 `empty_node` 是不是也要改变？"

#: ../../tutorial/example/segment-tree/segment-tree.md:123
msgid ""
"**A:** Yes, the `empty_node` ensures that it doesn’t affect the result "
"when added to any other `Node`. It's a zero-contribution node, akin to "
"how 0 contributes nothing in sum operations. For minimum value "
"maintenance, it can represent a value that won't affect the outcome, "
"making the process flexible!"
msgstr ""
"答：对， `empty_node` 是用来保证它和任何其他 `Node` 相加都不会产生改变的元素，是一个零贡献的`Node` "
"，类比在维护区间和的时候零贡献是 0，那么其实对于维护最小值来说你的值是当前可以取到的最大值，那就是零贡献的，这个过程处理的其实很灵活！"

#: ../../tutorial/example/segment-tree/segment-tree.md:125
msgid "Now, let's test the query process:"
msgstr "让我们来测试一下这个查询过程："

#: ../../tutorial/example/segment-tree/segment-tree.md:127
msgid ""
"\n"
"test {\n"
"  let tree = build([1, 2, 3, 4, 5][:])\n"
"  let sum = match tree.query(1, 5, 1, 3) {\n"
"    Node(sum, _, _) => sum\n"
"    _ => fail!(\"Expected Node\")\n"
"  }\n"
"  inspect!(sum, content=\"6\")\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree.md:133
msgid "The output is `6`."
msgstr "输出是：`6`。"

#: ../../tutorial/example/segment-tree/segment-tree.md:135
msgid "Fantastic! We've obtained the correct output!"
msgstr "太好了，我们得到了正确的输出！"

#: ../../tutorial/example/segment-tree/segment-tree.md:137
msgid "Code"
msgstr "代码"

#: ../../tutorial/example/segment-tree/segment-tree.md:139
msgid ""
"For the complete code, please check the [GitHub "
"repository](https://github.com/moonbitlang/moonbit-"
"docs/tree/main/next/sources/segment-tree/src/part1/top.mbt)."
msgstr ""
"完整代码请查看 [GitHub 代码仓库](https://github.com/moonbitlang/moonbit-"
"docs/tree/main/next/sources/segment-tree/src/part1/top.mbt)。"

#: ../../tutorial/example/segment-tree/segment-tree.md:143
msgid ""
"Today, we learned how to build and query a simple Segment Tree. In the "
"next lesson, we will explore more complex principles and implementations "
"of Segment Trees. Interested readers can solidify their knowledge and "
"expand on it by implementing the following:"
msgstr "今天我们学习了如何编写一棵简单的线段树的构建和查询操作的编写，下一节课我们将会学习更加复杂的线段树的原理和实现，感兴趣的读者可以在阅读文章之后自行实现下面内容来巩固知识和拓展更多内容："

#: ../../tutorial/example/segment-tree/segment-tree.md:145
msgid ""
"Try implementing a Segment Tree that maintains multiple pieces of "
"information (e.g., range sum, maximum, and minimum)."
msgstr "尝试实现一个可以维护多个信息（如区间和、区间最大值最小值）的线段树。"

#: ../../tutorial/example/segment-tree/segment-tree.md:146
msgid ""
"Understand how to implement point query/modification operations for "
"Segment Trees."
msgstr "自行了解如何实现线段树的单点查询/修改操作并实现。"

#: ../../tutorial/example/segment-tree/segment-tree.md:147
msgid ""
"Explore range modification operations for Segment Trees and related Lazy "
"Tags."
msgstr "自行了解线段树的区间修改操作以及 LazyTag 的相关知识。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:1
msgid "Segment Trees (Part 2)"
msgstr "线段树（第二部分）"

#: ../../tutorial/example/segment-tree/segment-tree2.md:3
msgid "Introduction"
msgstr "介绍"

#: ../../tutorial/example/segment-tree/segment-tree2.md:5
msgid ""
"In the previous article, we discussed the basic implementation of a "
"segment tree. That tree only allowed range queries (single-point "
"modifications and queries were also possible), but it couldn't handle "
"range modifications, such as adding a value to all elements in a given "
"range."
msgstr "在上一篇文章当中我们讨论了最基础线段树的实现，但那棵线段树只能做到区间的查询（当然单点的修改与查询也是可以的），但做不到区间的修改（一个经典的应用是区间加法，即整个区间都加上某个值）。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:7
msgid ""
"In this session, we will deepen the abstraction by introducing the "
"concept of **LazyTag** to handle range modifications, creating a more "
"functional segment tree."
msgstr "在本节当中我们将基于上次的线段树继续加深抽象，引入 LazyTag 的概念来解决区间修改的问题，完成一棵功能基本完备的线段树。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:9
msgid "How to Implement Range Modifications?"
msgstr "怎么做到区间修改？"

#: ../../tutorial/example/segment-tree/segment-tree2.md:11
msgid ""
"First, let's imagine what happens if we add a number to all elements in a"
" range on the segment tree. How would we do this using a straightforward "
"approach?"
msgstr "先设想如果我们在线段树上给一个区间都加上某个数会发生什么？或者换种说法，以最简单的办法来说，我们是如何完成它的？"

#: ../../tutorial/example/segment-tree/segment-tree2.md:13
msgid "![add to segment tree](/imgs/segment-tree-add.png)"
msgstr "![插入线段树](/imgs/segment-tree-add.png)"

#: ../../tutorial/example/segment-tree/segment-tree2.md:13
msgid "add to segment tree"
msgstr "插入线段树"

#: ../../tutorial/example/segment-tree/segment-tree2.md:15
msgid ""
"Take the segment tree from the last lesson as an example. In the figure "
"below, we add 1 to the range [4, 7]. You'll notice that we need to "
"rebuild and maintain all parts of the tree that cover this range, which "
"is too costly."
msgstr ""
"以上节课的线段树为例，上面这张图中，我们对 [4, 7] 的区间都加上 "
"1。这时候我们会发现这需要把涉及到这段区间的所有树上部分都重新构建维护一次，这个时间代价我们肯定是不能接受的。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:17
msgid "Is there a better way? Of course! We can use **LazyTag**."
msgstr "那有没有更好的方法？当然有！可以使用 LazyTag！"

#: ../../tutorial/example/segment-tree/segment-tree2.md:19
msgid "![lazytag](/imgs/segment-tree-lazytag.png)"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:19
msgid "lazytag"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:21
msgid ""
"Consider that instead of modifying every affected part, we mark the "
"smallest covering range with a \"+1\" tag. Based on the length of the "
"range, we calculate its value and merge it upward. Following the "
"complexity of querying from the last lesson, this operation would be "
"O(log N)."
msgstr ""
"设想我们在操作时，仅把 [4, 7] 区间的最少覆盖区间（就像查询需要的区间一样）打上一个 “+1” "
"的标记，并且根据这个区间的长度计算他应该有的值，然后合并上去，根据上节课 query 的复杂度类推，这个操作的复杂度应为 O(Log N) 的。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:23
msgid ""
"However, there's a problem. While querying ranges like [1, 7] or [4, 7] "
"works fine, what if we query [4, 6]? The minimal covering ranges are [4, "
"5] and [6, 6], not [4, 7], so our tag doesn't propagate to lower nodes."
msgstr ""
"但有个问题，现在这种处理方法查询 [1, 7] 或者 [4, 7] 这些区间都没有问题，但如果我们要查询 [4, 6] 呢？容易发现对于区间 "
"[4, 6]，它的最小覆盖区间是 [4, 5] 与 [6, 6] 而不是 [4, 7]，我们的 Tag 并没有对下面的节点生效。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:25
msgid "Here’s where the **Lazy** aspect of LazyTag comes into play."
msgstr "下面我们就要用到 LazyTag 除了 Tag 外的另一个性质：Lazy。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:27
msgid "![add using lazytag](/imgs/segment-tree-add-lazytag.png)"
msgstr "![使用lazytag插入](/imgs/segment-tree-add-lazytag.png)"

#: ../../tutorial/example/segment-tree/segment-tree2.md:27
msgid "add using lazytag"
msgstr "使用lazytag插入"

#: ../../tutorial/example/segment-tree/segment-tree2.md:29
msgid ""
"We define that when querying a node with a tag, the tag is distributed to"
" its child nodes. These child nodes inherit the tag and compute their "
"values based on their length. The following diagram shows the propagation"
" of the tag downward when querying [4, 6]."
msgstr ""
"我们规定在查询到某个节点时，如果当前节点上有一个加法的 Tag，就把它分发给下面的节点，下面的节点同样接收这个 Tag "
"并且根据自己的长度计算出自己应有的值。上图展示了在查询区间 [4, 6] 的结果时发生的 Tag 向下分发的操作。非常符合直觉的，叶子节点接收 "
"Tag 之后可以直接转换为自身的改变而不需要再保留 Tag。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:31
msgid ""
"This \"lazy propagation\" ensures that each modification is completed in "
"O(log N), while ensuring correct query results."
msgstr "容易发现像这样的“懒惰下推 Tag”的方法可以保证每次修改的操作在 O(Log N) 的时间内完成，还可以保证查询时可以查询到正确的结果！"

#: ../../tutorial/example/segment-tree/segment-tree2.md:34
msgid ""
"Some may wonder about overlapping tags. However, additive tags like these"
" merge seamlessly without affecting the total sum of a node."
msgstr "可能有些同学会疑问如果 Tag 重叠会怎么样，如果我们尝试一下就可以发现上文的这种加法 Tag 之间其实具有良好的合并性，不影响该节点总和的计算。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:37
msgid "Let’s dive into the code!"
msgstr "让我们来试试代码实现吧！"

#: ../../tutorial/example/segment-tree/segment-tree2.md:43
msgid ""
"In the previous code, we defined the segment tree using `enum`. However, "
"none of the elements were clearly named, which was manageable when the "
"data size was small. Now, we need to add **Tag** and **Length** "
"attributes, so it makes sense to use labeled arguments in the `enum` "
"definition:"
msgstr ""
"上节课的代码当中使用 enum 定义了线段树，但是每个 enum "
"当中的每个元素是用来干什么的其实没有名称标识，因为数据量比较小，对我们的心智负担影响不大，但目前我们需要添加 Tag 和 Length "
"属性存储，会显得匹配和定义的时候无法区分参数。所以我们可以使用 enum 的 labeled-argument 写法来完成更好的定义："

#: ../../tutorial/example/segment-tree/segment-tree2.md:45
msgid ""
"enum Data {\n"
"  Data(sum~ : Int, len~ : Int)\n"
"}\n"
"\n"
"enum LazyTag {\n"
"  Nil\n"
"  Tag(Int)\n"
"}\n"
"\n"
"enum Node {\n"
"  Nil\n"
"  Node(data~ : Data, tag~ : LazyTag, left~ : Node, right~ : Node)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:51
msgid ""
"This allows for clearer initialization and pattern matching, making the "
"code easier to follow. We've also abstracted the `Data` type, adding a "
"`len` attribute to represent the length of the current range, which is "
"useful for calculating the node's value."
msgstr ""
"这样我们就清晰地完成了对数据、LazyTag 和节点结构的定义，在下面初始化与模式匹配时将会更加清晰。另外，我们把 Data "
"类型单独抽象出来，比上节课多了一个 len 属性，用来标记当前区间的长度，以配合 Tag 计算当前节点的值。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:55
msgid ""
"Similar to the last lesson, before building the tree, we need to define "
"the addition operations between `Node` types. However, since we’ve "
"abstracted `Data`, we must account for its addition too:"
msgstr "我们依然像上一节一样在编写建树逻辑之前需要先考虑 Node 类型之间的加法，但本节中因为我们单独抽象了 Data，所以也要考虑他们之间的加法："

#: ../../tutorial/example/segment-tree/segment-tree2.md:57
msgid ""
"fn op_add(self : Data, v : Data) -> Data {\n"
"  match (self, v) {\n"
"    (Data(sum=a, len=len_a), Data(sum=b, len=len_b)) =>\n"
"      Data(sum=a + b, len=len_a + len_b)\n"
"  }\n"
"}\n"
"\n"
"fn op_add(self : Node, v : Node) -> Node {\n"
"  match (self, v) {\n"
"    (Node(data=l, ..), Node(data=r, ..)) =>\n"
"      Node(data=l + r, tag=Nil, left=self, right=v)\n"
"    (Node(_), Nil) => self\n"
"    (Nil, Node(_)) => v\n"
"    (Nil, Nil) => Nil\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:63
msgid ""
"Here, we’ve ignored merging LazyTags for now and set the resulting tag to"
" `Nil` because once a node is reached, its parent’s LazyTag no longer "
"applies."
msgstr ""
"可以发现这里暂时还没有考虑 LazyTag 的合并，而是认为他们加法的结果得到的节点的 LazyTag 均为 "
"Nil，这是很好理解的，如果已经走到一个节点，那么它的父节点当然会是没有 LazyTag 的。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:65
msgid "Now, we can implement the tree-building function:"
msgstr "接下来就可以写出建树的代码，这与上节非常相似："

#: ../../tutorial/example/segment-tree/segment-tree2.md:67
msgid ""
"fn build(data : ArrayView[Int]) -> Node {\n"
"  if data.length() == 1 {\n"
"    Node(data=Data(sum=data[0], len=1), tag=Nil, left=Nil, right=Nil)\n"
"  } else {\n"
"    let mid = (data.length() + 1) >> 1\n"
"    build(data[0:mid]) + build(data[mid:])\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:73
msgid "LazyTag and Range Modifications"
msgstr "LazyTag 与区间修改的实现"

#: ../../tutorial/example/segment-tree/segment-tree2.md:75
msgid ""
"We define a node receiving a LazyTag as `apply`. The key logic lies in "
"here: the node receiving the LazyTag may not own a LazyTag, and if it did"
" own one, how do we merge them? And how do we compute the new value of "
"the node based on the LazyTag?"
msgstr ""
"我们把一个节点接受一个 LazyTag 的行为定义为 apply，容易发现其实真正的核心逻辑就在这里，当前接受上方 LazyTag "
"的节点身上不一定是否有 LazyTag，而如果有，又应该怎么合并？怎么根据 LazyTag 计算当前节点新的值？答案都在这个操作当中。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:77
msgid ""
"A decent implementation is to define a new addition operation to merge "
"LazyTags, and define an `apply` function for Node to receive it."
msgstr ""
"一个很好的实现方法是我们对 LazyTag 再单独定义一套加法运算来实现他们的合并，然后为 Node 类型编写一个 apply 函数来接收一个 "
"LazyTag。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:80
msgid ""
"fn op_add(self : LazyTag, v : LazyTag) -> LazyTag {\n"
"  match (self, v) {\n"
"    (Tag(a), Tag(b)) => Tag(a + b)\n"
"    (Nil, t) | (t, Nil) => t\n"
"  }\n"
"}\n"
"\n"
"fn apply(self : Node, v : LazyTag) -> Node {\n"
"  match (self, v) {\n"
"    (Node(data=Data(sum=a, len=length), tag~, left~, right~), Tag(v) as "
"new_tag) =>\n"
"      Node(\n"
"        data=Data(sum=a + v * length, len=length),\n"
"        tag=tag + new_tag,\n"
"        left~,\n"
"        right~,\n"
"      )\n"
"    (_, Nil) => self\n"
"    (Nil, _) => Nil\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:86
msgid ""
"Here is the core part of this section: compute the correct node's value "
"with the segment's length and the value of LazyTag."
msgstr "这是我们这节课最核心的地方，根据当前区间长度和 LazyTag 的值计算出了当前节点的正确数值，这样我们就有了 LazyTag 的实现。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:88
msgid "Then how do we implement range modifications?"
msgstr "怎么做到区间修改？"

#: ../../tutorial/example/segment-tree/segment-tree2.md:90
msgid ""
"fn modify(\n"
"  self : Node,\n"
"  l : Int,\n"
"  r : Int,\n"
"  modify_l : Int,\n"
"  modify_r : Int,\n"
"  tag : LazyTag\n"
") -> Node {\n"
"  if modify_l > r || l > modify_r {\n"
"    self\n"
"  } else if modify_l <= l && modify_r >= r {\n"
"    self.apply(tag)\n"
"  } else {\n"
"    guard let Node(left~, right~, ..) = self\n"
"    let mid = (l + r) >> 1\n"
"    left.modify(l, mid, modify_l, modify_r, tag) +\n"
"    right.modify(mid + 1, r, modify_l, modify_r, tag)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:96
msgid ""
"The logic is similar to the query function from the previous lesson, but "
"now each relevant node applies the necessary LazyTag for the "
"modification."
msgstr "逻辑实际上与上节课编写的 query 大差不差，只是每个地方都让对应的节点 apply 了我们需要修改的值（作为 LazyTag）。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:98
msgid ""
"When we arrive here, we find that, even with the range modification, it's"
" still a persistent, or **Immutable** segment tree. The `modify` function"
" will return the recently created segment tree, without changing the "
"original one, and the semantics of recurring and merging represent this "
"vividly."
msgstr ""
"不过写到这里我们可以发现，这棵线段树就算加入了区间修改之后居然还是一个可持久化的，或者说 Immutable 的线段树！我们的 modify "
"函数将会返回最新的那棵线段树，并没有对原来的线段树作任何改变，而我们的递归与合并语义非常明显的体现了这一点。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:100
msgid ""
"This means that using these kind of implementations (ADT(enum), "
"recursion) for meeting immutable requirements is natural and elegant. "
"With the garbage collection mechanism of MoonBit, we don't need to use "
"pointers **explicitly** for some relationships in recurring ADT(enum), "
"and we don't need to take care of the memory."
msgstr ""
"这说明在一些 Immutable 的需求上上采用这类写法（ADT(enum)、递归）是非常优雅而且自然的。而且 MoonBit "
"语言存在垃圾回收机制 (GC)，所以在无限递归的 ADT(enum) "
"当中不需要**显式地**用指针来指代一些关系，我们并不需要关心内存里面发生了什么。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:102
msgid ""
"Readers unfamiliar with the functional programming languages may not "
"notice this, but we actually always profit from it. For example, writing "
"a `ConsList` in Rust using ADT(enum), we usually need:"
msgstr ""
"很多对函数式编程语言不熟悉的读者可能使用 MoonBit 时没有太关注到这个问题，但其实我们一直从中受益，比如如果我们需要在 Rust 当中使用 "
"ADT(enum) 来写一个 ConsList，我们往往需要："

#: ../../tutorial/example/segment-tree/segment-tree2.md:104
msgid ""
"enum List<T> {\n"
"    Cons(T, Box<List<T>>),\n"
"    Nil,\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:111
msgid "But in MoonBit, we only need:"
msgstr "但在 MoonBit，我们只需要："

#: ../../tutorial/example/segment-tree/segment-tree2.md:113
msgid ""
"enum List[T] {\n"
"  Cons(T, List[T])\n"
"  Nil\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:120
msgid "GC is really interesting!"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:122
msgid "Queries"
msgstr "查询"

#: ../../tutorial/example/segment-tree/segment-tree2.md:124
msgid "For queries, we need to remember to push the LazyTag downwards:"
msgstr "查询部分只要记得需要下推 LazyTag 即可。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:126
msgid ""
"let empty_node : Node = Node(\n"
"  data=Data(sum=0, len=0),\n"
"  tag=Nil,\n"
"  left=Nil,\n"
"  right=Nil,\n"
")\n"
"\n"
"fn query(self : Node, l : Int, r : Int, query_l : Int, query_r : Int) -> "
"Node {\n"
"  if query_l > r || l > query_r {\n"
"    empty_node\n"
"  } else if query_l <= l && query_r >= r {\n"
"    self\n"
"  } else {\n"
"    guard let Node(tag~, left~, right~, ..) = self\n"
"    let mid = (l + r) >> 1\n"
"    left.apply(tag).query(l, mid, query_l, query_r) +\n"
"    right.apply(tag).query(mid + 1, r, query_l, query_r)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/segment-tree/segment-tree2.md:134
msgid ""
"With this, we have a segment tree that supports range modifications and "
"is much more functional!"
msgstr "到这里我们就完成了一棵支持区间修改的，更加完美的线段树！"

#: ../../tutorial/example/segment-tree/segment-tree2.md:136
msgid ""
"In the next lesson, we’ll add multiplication support to the segment tree "
"and explore some use cases for immutable segment trees. Stay tuned!"
msgstr ""
"接下来，在最后一节课当中我们将会学习如何给当前这棵线段树再加入一个 “乘法操作”，以及探索一些 Immutable "
"线段树的应用场景。感兴趣的读者可以提前自行了解。"

#: ../../tutorial/example/segment-tree/segment-tree2.md:138
msgid ""
"Full code is available [here](https://github.com/moonbitlang/moonbit-"
"docs/tree/main/next/sources/segment-tree/src/part2/top.mbt)."
msgstr ""
"​本篇编程实践完整代码[见此处](https://github.com/moonbitlang/moonbit-"
"docs/tree/main/next/sources/segment-tree/src/part2/top.mbt)"

#: ../../tutorial/example/sudoku/index.md:1
msgid "Sudoku Solver"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:3
msgid ""
"Sudoku is a logic-based puzzle game that originated in 1979. It was well-"
"suited for print media like newspapers, and even in the digital age, many"
" Sudoku game programs are available for computers and smartphones. "
"Despite the variety of entertainment options today, Sudoku enthusiasts "
"continue to form active communities (online forum such as: "
"[enjoysudoku](http://forum.enjoysudoku.com/)). This article will "
"demonstrate how to write a suitable program to solve Sudoku using "
"MoonBit. ![sudoku example](/imgs/sudoku.jpg)"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:3
msgid "sudoku example"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:6
msgid "Squares, Units, and Peers"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:8
msgid ""
"The most common form of Sudoku is played on a 9x9 grid. We label the rows"
" from top to bottom as A-I, and the columns from left to right as 1-9. "
"This gives each square in the grid a coordinate, for example, the square "
"containing the number 0 in the grid below has the coordinate C3."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:10
msgid ""
"  1 2 3 4 5 6 7 8 9\n"
"A . . . . . . . . .\n"
"B . . . . . . . . .\n"
"C . . 0 . . . . . .\n"
"D . . . . . . . . .\n"
"E . . . . . . . . .\n"
"F . . . . . . . . .\n"
"G . . . . . . . . .\n"
"H . . . . . . . . .\n"
"I . . . . . . . . .\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:23
msgid ""
"This 9x9 grid has a total of 9 units, and each unit contains squares that"
" must have unique digits from 1 to 9. However, in the initial state of "
"the game, most squares do not contain any digits."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:25
msgid ""
" 4  1  7 | 3  6  9 | 8  2  5\n"
" 6  3  2 | 1  5  8 | 9  4  7\n"
" 9  5  8 | 7  2  4 | 3  1  6\n"
"---------+---------+---------\n"
" 8  2  5 | 4  3  7 | 1  6  9\n"
" 7  9  1 | 5  8  6 | 4  3  2\n"
" 3  4  6 | 9  1  2 | 7  5  8\n"
"---------+---------+---------\n"
" 2  8  9 | 6  4  3 | 5  7  1\n"
" 5  7  3 | 2  9  1 | 6  8  4\n"
" 1  6  4 | 8  7  5 | 2  9  3\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:39
msgid ""
"Beyond the units, another important concept is peers. A square's peers "
"include other squares in the same row, column, and unit. For example, the"
" peers of C2 include these squares:"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:41
msgid ""
"\n"
"    A2   |         |\n"
"    B2   |         |\n"
"    C2   |         |\n"
"---------+---------+---------\n"
"    D2   |         |\n"
"    E2   |         |\n"
"    F2   |         |\n"
"---------+---------+---------\n"
"    G2   |         |\n"
"    H2   |         |\n"
"    I2   |         |\n"
"\n"
"         |         |\n"
"         |         |\n"
" C1 C2 C3| C4 C5 C6| C7 C8 C9\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
"\n"
" A1 A2 A3|         |\n"
" B1 B2 B3|         |\n"
" C1 C2 C3|         |\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
"---------+---------+---------\n"
"         |         |\n"
"         |         |\n"
"         |         |\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:80
msgid "No two squares that are peers can contain the same digit."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:82
msgid ""
"We need a data type, SquareMap[T], to store the 81 squares and the "
"information associated with each square. This can be implemented using a "
"hashtable, but using an array would be more compact and simple. First, we"
" write a function to convert coordinates A1-I9 to indices 0-80:"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:84
msgid ""
"// A1 => 0, A2 => 1\n"
"fn square_to_int(s : String) -> Int {\n"
"  if in(s[0], 'A', 'I') && in(s[1], '1', '9') {\n"
"    let row = s[0].to_int() - 65 // 'A' <=> 0\n"
"    let col = s[1].to_int() - 49 // '1' <=> 0\n"
"    return row * 9 + col\n"
"  } else {\n"
"    abort(\"square_to_int(): \\{s} is not a square\")\n"
"  }\n"
"}\n"
"\n"
"// Helper function `in` checks if a character is between `lw` and `up`\n"
"fn in(this : Char, lw : Char, up : Char) -> Bool {\n"
"  this >= lw && this <= up\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:102
msgid ""
"Then we wrap the array and provide operations for creating, accessing, "
"assigning values to specific coordinates, and copying SquareMap[T]. By "
"overloading the op_get and op_set methods, we can write convenient code "
"like table[\"A2\"] and table[\"C3\"] = Nil."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:104
msgid ""
"struct SquareMap[T] {\n"
"  contents : Array[T]\n"
"}\n"
"\n"
"fn SquareMap::new[T](val : T) -> SquareMap[T] {\n"
"  { contents : Array::make(81, val) }\n"
"}\n"
"\n"
"fn copy[T](self : SquareMap[T]) -> SquareMap[T] {\n"
"  let arr = Array::make(81, self.contents[0])\n"
"  let mut i = 0\n"
"  while i < 81 {\n"
"    arr[i] = self.contents[i]\n"
"    i = i + 1\n"
"  }\n"
"  return { contents : arr }\n"
"}\n"
"\n"
"fn op_get[T](self : SquareMap[T], square : String) -> T {\n"
"  self.contents[square_to_int(square)]\n"
"}\n"
"\n"
"fn op_set[T](self : SquareMap[T], square : String, x : T) -> Unit {\n"
"  self.contents[square_to_int(square)] = x\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:132
msgid "Next, we prepare some constants:"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:134
msgid ""
"let rows = \"ABCDEFGHI\"\n"
"let cols = \"123456789\"\n"
"\n"
"// squares contains the coordinates of each square\n"
"let squares : List[String] = ......\n"
"\n"
"// units[coord] contains the other squares in the unit of the square at "
"coord\n"
"// for example：units[\"A3\"] => [C3, C2, C1, B3, B2, B1, A2, A1]\n"
"let units : SquareMap[List[String]] = ......\n"
"\n"
"// peers[coord] contains all the peers of the square at coord\n"
"// for example：peers[\"A3\"] => [A1, A2, A4, A5, A6, A7, A8, A9, B1, B2, "
"B3, C1, C2, C3, D3, E3, F3, G3, H3, I3]\n"
"let peers : SquareMap[List[String]] = ......\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:150
msgid ""
"The process of constructing the units and peers tables is tedious, so it "
"will not be detailed here."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:152
msgid "Preprocessing the Grid"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:154
msgid ""
"We use a string to represent the initial Sudoku grid. Various formats are"
" acceptable; both `.` and `0` represent empty squares, and other "
"characters like spaces and newlines are ignored."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:156
msgid ""
"\"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\""
"\n"
"\n"
"\"\n"
"400000805\n"
"030000000\n"
"000700000\n"
"020000060\n"
"000080400\n"
"000010000\n"
"000603070\n"
"500200000\n"
"104000000\"\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:171
msgid ""
"For now, let's not consider game rules too much. If we only consider the "
"digits that can be filled in each square, then 1-9 are all possible. "
"Therefore, we initially set the content of all squares to `['1', '2', "
"'3', '4', '5', '6', '7', '8', '9']` (a List)."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:173
msgid ""
"fn parseGrid(s : String) -> SquareMap[List[Char]] {\n"
"  let digits = cols.to_list()\n"
"  let values : SquareMap[List[Char]] = SquareMap::new(digits)\n"
"  ......\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:181
msgid ""
"Next, we need to assign values to the squares with known digits from the "
"input. This process can be implemented with the function `assign(values, "
"key, val)`, where `key` is a string like `A6` and `val` is a character. "
"It is easy to write such code."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:183
msgid ""
"fn assign(values : SquareMap[List[Char]], key : String, val : Char) {\n"
"  values[key] = Cons(val, Nil)\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:189
msgid "Let's run it and see"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:191
msgid ""
"\"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\""
"\n"
"\n"
"// Using parseGrid and printGrid functions, skipping implementation "
"details for simplicity\n"
"\n"
" 4          123456789  123456789 | 123456789  123456789  123456789 | 8"
"          123456789  5\n"
" 123456789  3          123456789 | 123456789  123456789  123456789 | "
"123456789  123456789  123456789\n"
" 123456789  123456789  123456789 | 7          123456789  123456789 | "
"123456789  123456789  123456789\n"
"---------------------------------+---------------------------------+---------------------------------"
"\n"
" 123456789  2          123456789 | 123456789  123456789  123456789 | "
"123456789  6          123456789\n"
" 123456789  123456789  123456789 | 123456789  8          123456789 | 4"
"          123456789  123456789\n"
" 123456789  123456789  123456789 | 123456789  1          123456789 | "
"123456789  123456789  123456789\n"
"---------------------------------+---------------------------------+---------------------------------"
"\n"
" 123456789  123456789  123456789 | 6          123456789  3         | "
"123456789  7          123456789\n"
" 5          123456789  123456789 | 2          123456789  123456789 | "
"123456789  123456789  123456789\n"
" 1          123456789  4         | 123456789  123456789  123456789 | "
"123456789  123456789  123456789\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:209
msgid "This implementation is simple and precise, but we can do more."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:211
msgid ""
"Now, we can reintroduce the rules that we set aside earlier. However, the"
" rules themselves do not tell us what to do. We need heuristic strategies"
" to gain insights from the rules, similar to solving Sudoku with pen and "
"paper. Let's start with the elimination method:"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:213
msgid ""
"**Strategy 1**: If a square `key` is assigned a value `val`, then its "
"peers (peers[key]) should not contain `val` in their lists of possible "
"values, as this would violate the rule that no two squares in the same "
"unit, row, or column can have the same digit."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:215
msgid ""
"**Strategy 2**: If there is only one square in a unit that can hold a "
"specific digit (possibly happen after applying the above rule several "
"times), then that digit should be assigned to that square."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:217
msgid ""
"We adjust the code by defining an `eliminate` function, which removes a "
"digit from the possible values of a square. After performing the "
"elimination task, it applies the above strategies to `key` and `val` to "
"attempt further eliminations. Note that it includes a boolean return "
"value to handle possible contradictions. If the list of possible values "
"for a square becomes empty, something went wrong, and we return `false`."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:219
msgid ""
"fn eliminate(values : SquareMap[List[Char]], key : String, val : Char) ->"
" Bool {\n"
"  if not(exist(values[key], fn (v) { v == val })) {\n"
"    return true\n"
"  }\n"
"  values[key] = values[key].remove(val)\n"
"  // If `key` has only one possible value left, remove this value from "
"its peers\n"
"  match single(values[key]) {\n"
"    Err(b) => {\n"
"      if not(b) {\n"
"        return false\n"
"      }\n"
"    }\n"
"    Ok(val) => {\n"
"      let mut result = true\n"
"      peers[key].iter(fn (key) {\n"
"        result = result && eliminate(values, key, val)\n"
"      })\n"
"      if not(result) {\n"
"        return false\n"
"      }\n"
"    }\n"
"  }\n"
"  //  If there is only one square in the unit of `key` that can hold "
"`val`, assign `val` to that square\n"
"  let unit = units[key]\n"
"  let places = unit.filter(fn (sq) {\n"
"    exist(values[sq], fn (v) { v == val })\n"
"  })\n"
"  match single(places) {\n"
"    Err(b) => {\n"
"      return b\n"
"    }\n"
"    Ok(key) => {\n"
"      return assign(values, key, val)\n"
"    }\n"
"  }\n"
"}\n"
"\n"
"\n"
"// Return `Err(false)` if the list is empty\n"
"// Return `Ok(x)` if the list contains only `[x]`\n"
"// Return `Err(true)` if the list contains `[x1, x2, ......]`\n"
"fn single[T](this : List[T]) -> Result[T, Bool] {\n"
"  match this {\n"
"    Nil => Err(false)\n"
"    Cons(x, Nil) => Ok(x)\n"
"    _ => Err(true)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:270
msgid ""
"Next, we define `assign(values, key, val)` to remove all values except "
"`val` from the possible values of `key`."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:272
msgid ""
"fn assign(values : SquareMap[List[Char]], key : String, val : Char) -> "
"Bool {\n"
"  let other_values = values[key].remove(val)\n"
"  let mut result = true\n"
"  other_values.iter(fn (val) {\n"
"    result = result && eliminate(values, key, val)\n"
"  })\n"
"  return result\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:283
msgid ""
"These two functions apply heuristic strategies to each square they "
"access. A successful heuristic application introduces new squares to "
"consider, allowing these strategies to propagate widely across the grid. "
"This is key to quickly eliminating invalid options."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:285
msgid "Let's try the example again"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:287
msgid ""
"\"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\""
"\n"
"\n"
" 4        1679     12679   | 139      2369     269     | 8        1239"
"     5\n"
" 26789    3        1256789 | 14589    24569    245689  | 12679    1249"
"     124679\n"
" 2689     15689    125689  | 7        234569   245689  | 12369    12349"
"    123469\n"
"---------------------------+---------------------------+---------------------------"
"\n"
" 3789     2        15789   | 3459     34579    4579    | 13579    6"
"        13789\n"
" 3679     15679    15679   | 359      8        25679   | 4        12359"
"    12379\n"
" 36789    4        56789   | 359      1        25679   | 23579    23589"
"    23789\n"
"---------------------------+---------------------------+---------------------------"
"\n"
" 289      89       289     | 6        459      3       | 1259     7"
"        12489\n"
" 5        6789     3       | 2        479      1       | 69       489"
"      4689\n"
" 1        6789     4       | 589      579      5789    | 23569    23589"
"    23689\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:303
msgid ""
"A significant improvement! In fact, this preprocessing can already solve "
"some simple Sudoku puzzles."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:305
msgid ""
"\"003020600900305001001806400008102900700000008006708200002609500800203009005010300\""
"\n"
"\n"
" 4  8  3 | 9  2  1 | 6  5  7\n"
" 9  6  7 | 3  4  5 | 8  2  1\n"
" 2  5  1 | 8  7  6 | 4  9  3\n"
"---------+---------+---------\n"
" 5  4  8 | 1  3  2 | 9  7  6\n"
" 7  2  9 | 5  6  4 | 1  3  8\n"
" 1  3  6 | 7  9  8 | 2  4  5\n"
"---------+---------+---------\n"
" 3  7  2 | 6  8  9 | 5  1  4\n"
" 8  1  4 | 2  5  3 | 7  6  9\n"
" 6  9  5 | 4  1  7 | 3  8  2\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:321
msgid ""
"If you are interested in artificial intelligence, you might recognize "
"this as a Constraint Satisfaction Problem (CSP), and `assign` and "
"`eliminate` are specialized arc consistency algorithms. For more on this "
"topic, refer to Chapter 6 of _Artificial Intelligence: A Modern "
"Approach_."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:323
msgid "Search"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:325
msgid ""
"After preprocessing, we can boldly use brute-force enumeration to search "
"for all feasible combinations. However, we can still use the heuristic "
"strategies during the search process. When trying to assign a value to a "
"square, we still use `assign`, which allows us to apply previous "
"optimizations to eliminate many invalid branches during the search."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:327
msgid ""
"Another point to note is that conflicts may arise during the search (when"
" a square's possible values are exhausted). Since mutable structures make"
" backtracking troublesome, we directly copy values each time we assign a "
"value."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:329
msgid ""
"fn search(values : SquareMap[List[Char]]) -> "
"Option[SquareMap[List[Char]]] {\n"
"  if values.contains(fn (digits){ not(isSingleton(digits)) }) {\n"
"    // // Find the square with the smallest number of possible values "
"greater than 1, and start the search from this square\n"
"    // This is just a heuristic strategy; you can try finding a smarter "
"and more effective one\n"
"    let mut minsq = \"\"\n"
"    let mut n = 10\n"
"    squares.iter(fn (sq) {\n"
"      let len = values[sq].length()\n"
"      if len > 1 {\n"
"        if len < n {\n"
"          n = len\n"
"          minsq = sq\n"
"        }\n"
"      }\n"
"    })\n"
"    // Iterate through assignments and stop if a successful search is "
"found\n"
"    loop values[minsq] {\n"
"      Nil => None\n"
"      Cons(digit, rest) => {\n"
"        let another = values.copy()\n"
"        if assign(another, minsq, digit){\n"
"          match search(another) {\n"
"            None => continue rest\n"
"            Some(_) as result => result\n"
"          }\n"
"        } else {\n"
"          continue rest\n"
"        }\n"
"      }\n"
"    }\n"
"  } else {\n"
"    return Some(values)\n"
"  }\n"
"}\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:366
msgid ""
"Let's run the same example again (the example is actually taken from "
"[magictour](http://magictour.free.fr/top95), a list of difficult Sudoku "
"puzzles, which is not easy for humans)"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:368
msgid ""
"> "
"solve(\"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\")"
"\n"
"\n"
" 4  1  7 | 3  6  9 | 8  2  5\n"
" 6  3  2 | 1  5  8 | 9  4  7\n"
" 9  5  8 | 7  2  4 | 3  1  6\n"
"---------+---------+---------\n"
" 8  2  5 | 4  3  7 | 1  6  9\n"
" 7  9  1 | 5  8  6 | 4  3  2\n"
" 3  4  6 | 9  1  2 | 7  5  8\n"
"---------+---------+---------\n"
" 2  8  9 | 6  4  3 | 5  7  1\n"
" 5  7  3 | 2  9  1 | 6  8  4\n"
" 1  6  4 | 8  7  5 | 2  9  3\n"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:384
msgid ""
"Running on [MoonBit online IDE](https://try.moonbitlang.com/), It takes "
"only about 0.11 seconds to solve this Sudoku!"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:386
msgid ""
"Complete code here: "
"[try.moonbitlang.com/#6806c2fe](https://try.moonbitlang.com/#6806c2fe)"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:390
msgid ""
"The purpose of games is to relieve boredom and bring joy. If playing a "
"game becomes more anxiety-inducing than exciting, it might go against the"
" game designer's original intent. The article demonstrated that simple "
"elimination methods and brute-force search can quickly solve some Sudoku "
"puzzles. This does not mean that Sudoku is not worth playing; rather, it "
"reveals that one should not be overly concerned with an unsolvable Sudoku"
" puzzle."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:392
msgid "Let's play with MoonBit with ease!"
msgstr ""

#: ../../tutorial/example/sudoku/index.md:394
msgid ""
"Visit MoonBit [Gallery](https://www.moonbitlang.com/gallery/sudoku/) to "
"play with the Sudoku solver written in MoonBit. Click [this "
"link](https://github.com/myfreess/sudoku) to view the full source code."
msgstr ""

#: ../../tutorial/example/sudoku/index.md:396
msgid ""
"This tutorial references Norvig's blog: "
"[http://norvig.com/sudoku.html](http://norvig.com/sudoku.html)"
msgstr ""

#: ../../tutorial/index.md:1
msgid "Tutorial"
msgstr "教程"

#: ../../tutorial/index.md:3
msgid "Here are some tutorials that may help you learn the programming language:"
msgstr "以下是一些可能帮助您学习编程语言的教程："

#: ../../tutorial/index.md:5
msgid "[An interactive tour with language basics](https://tour.moonbitlang.com)"
msgstr ""

#: ../../tutorial/index.md:6
msgid "[Tour for Beginners](./tour.md)"
msgstr "[新手之旅](./tour.md)"

#: ../../tutorial/index.md:7
msgid "[Examples](./example/index.md)"
msgstr ""

#: ../../tutorial/tour.md:1
msgid "A Tour of MoonBit for Beginners"
msgstr "MoonBit：新手之旅"

#: ../../tutorial/tour.md:3
msgid ""
"This guide is intended for newcomers, and it's not meant to be a 5-minute"
" quick tour. This article tries to be a succinct yet easy to understand "
"guide for those who haven't programmed in a way that MoonBit enables them"
" to, that is, in a more modern, functional way."
msgstr ""
"这一文档针对不熟悉语言的新手用户所写，并不打算作为一个几分钟就能读完的小文章。本文希望为那些对 MoonBit 的编程思路 "
"(更加现代化，函数式的) 不甚了解的用户提供一个简洁而不失易懂性的指南。"

#: ../../tutorial/tour.md:6
msgid ""
"See [the General Introduction](../language/index.md) if you want to "
"straight delve into the language."
msgstr "如果您想直接深入了解语言，请参阅[总体介绍](../language/index.md)。"

#: ../../tutorial/tour.md:8
msgid "Installation"
msgstr "安装"

#: ../../tutorial/tour.md:10
msgid "the Extension"
msgstr "语言扩展"

#: ../../tutorial/tour.md:12
msgid ""
"Currently, MoonBit development support are through VS Code extension. "
"Navigate to [VS Code "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=moonbit"
".moonbit-lang) to download MoonBit language support."
msgstr ""
"目前，MoonBit 的开发支持是通过 VS Code 扩展实现的。请前往[VS Code "
"Marketplace](https://marketplace.visualstudio.com/items?itemName=moonbit"
".moonbit-lang)下载 MoonBit 语言支持。"

#: ../../tutorial/tour.md:15
msgid "the toolchain"
msgstr "工具链"

#: ../../tutorial/tour.md:17
msgid ""
"(Recommended) If you've installed the extension above, the runtime can be"
" directly installed by running 'Install moonbit toolchain' in the action "
"menu and you may skip this part: ![runtime-installation](/imgs/runtime-"
"installation.png)"
msgstr ""
"(推荐) 如果您已安装了上面的扩展，运行操作菜单中的 “Install moonbit toolchain” "
"即可直接安装运行时并跳过这部分介绍：![安装运行时](/imgs/runtime-installation.png)"

#: ../../tutorial/tour.md:17
msgid "runtime-installation"
msgstr "安装运行时"

#: ../../tutorial/tour.md:20
msgid ""
"We also provide an installation script: Linux & macOS users can install "
"via"
msgstr "我们还提供了一个安装脚本：Linux 和 macOS 用户可以通过以下方式安装："

#: ../../tutorial/tour.md:22
msgid "curl -fsSL https://cli.moonbitlang.com/install/unix.sh | bash\n"
msgstr ""

#: ../../tutorial/tour.md:26
msgid "For Windows users, powershell is used:"
msgstr "对于 Windows 用户，使用 Powershell："

#: ../../tutorial/tour.md:28
msgid ""
"Set-ExecutionPolicy RemoteSigned -Scope CurrentUser; irm "
"https://cli.moonbitlang.com/install/powershell.ps1 | iex\n"
msgstr ""

#: ../../tutorial/tour.md:32
msgid ""
"This automatically installs MoonBit in `$HOME/.moon` and adds it to your "
"`PATH`."
msgstr "这将自动安装 MoonBit 到 `$HOME/.moon` 并将其添加到您的 `PATH`。"

#: ../../tutorial/tour.md:34
msgid ""
"If you encounter `moon` not found after installation, try restarting your"
" terminal or vscode to let the environment variable take effect."
msgstr "如果安装后遇到 `moon` 未找到的情况，请尝试重新启动终端或 VSCode 以使环境变量生效。"

#: ../../tutorial/tour.md:36
msgid ""
"Do notice that MoonBit is not production-ready at the moment, it's under "
"active development. To update MoonBit, just run the commands above again."
msgstr "请注意，目前 MoonBit 还不适用于生产环境：它正在积极开发中。要更新 MoonBit，只需再次运行上面的命令即可。"

#: ../../tutorial/tour.md:38
msgid ""
"Running `moon help` gives us a bunch of subcommands. But right now the "
"only commands we need are `build` `run` and `new`."
msgstr "运行 `moon help` 可以看到一堆子命令。但是现在我们只需要 `build` `run` 和 `new` 这三个命令。"

#: ../../tutorial/tour.md:40
msgid ""
"To create a project (or module, more formally), run `moon new`. You will "
"be greeted with a creation wizard, filling up all the info and we get"
msgstr "要创建一个项目（或模块，更正式地说），运行 `moon new`。您将看到一个创建向导，填写所有信息后我们会得到："

#: ../../tutorial/tour.md:42
msgid ""
"my-project\n"
"├── LICENSE\n"
"├── moon.mod.json\n"
"├── README.md\n"
"└── src\n"
"    ├── lib\n"
"    │   ├── hello.mbt\n"
"    │   ├── hello_test.mbt\n"
"    │   └── moon.pkg.json\n"
"    └── main\n"
"        ├── main.mbt\n"
"        └── moon.pkg.json\n"
msgstr ""

#: ../../tutorial/tour.md:57
msgid ""
"This resembles a typical MoonBit module structure. Try running `moon run "
"src/main`."
msgstr "这是一个典型的 MoonBit 模块结构。尝试运行 `moon run src/main`。"

#: ../../tutorial/tour.md:59
msgid "Now, we can get started."
msgstr "现在，我们可以开始了。"

#: ../../tutorial/tour.md:61
msgid "Start Writing"
msgstr "开始编写"

#: ../../tutorial/tour.md:63
msgid ""
"In our tour, we will write all of the codes below in `main.mbt`. As you "
"may have guessed, the `main` function within the `main` package is the "
"main entrance of a program. For a thorough introduction, please take a "
"look at our [build system tutorial](../toolchain/moon/tutorial.md)."
msgstr ""
"在我们的新手之旅中，我们将在 `main.mbt` 中编写下面的所有代码。正如您可能猜到的那样，`main` 包中的 `main` "
"函数是程序的主入口。要进行全面的介绍，请查看我们的[构建系统教程](../toolchain/moon/tutorial.md)。"

#: ../../tutorial/tour.md:66
msgid "Variables"
msgstr "变量"

#: ../../tutorial/tour.md:68
msgid "Variables are defined with `let`:"
msgstr "变量使用 `let` 定义："

#: ../../tutorial/tour.md:70
msgid ""
"let e = 2.718281828459045 // double\n"
"let int_min = -2147483648 // int\n"
"let int_max : Int = 2147483647 // explicit type annotation\n"
"let tuple = (1, 2) // 2-tuple\n"
msgstr ""
"let e = 2.718281828459045 // double\n"
"let int_min = -2147483648 // int\n"
"let int_max : Int = 2147483647 // 显示类型标注\n"
"let tuple = (1, 2) // 2-tuple\n"

#: ../../tutorial/tour.md:77
msgid ""
"fn init {\n"
"  let array = [1, 2, 3, 4, 5]\n"
"  // array = [4, 5, 6, 7, 8] // WRONG: let creates immutable bindings\n"
"  let mut mut_array = [1, 2, 3, 4, 5]\n"
"  mut_array = [4, 5, 6, 7, 8]\n"
"  println(mut_array)\n"
"}\n"
msgstr ""
"fn init {\n"
"  let array = [1, 2, 3, 4, 5]\n"
"  // array = [4, 5, 6, 7, 8] // 错误：let 创建的是不可变绑定\n"
"  let mut mut_array = [1, 2, 3, 4, 5]\n"
"  mut_array = [4, 5, 6, 7, 8]\n"
"  println(mut_array)\n"
"}\n"

#: ../../tutorial/tour.md:87
msgid ""
"MoonBit is a strictly typed language with type inference. In the example "
"above, `let` binds (we prefer the word _bind_ to assign) a symbol to a "
"value. The symbol is inferred to have the same type as the value. Hover "
"over any of the symbols to check its type."
msgstr ""
"MoonBit 是一种严格类型的语言，具有类型推断。在上面的示例中，`let` 将一个符号绑定（我们更喜欢使用 _绑定_ 这个词而不是 "
"赋值）到一个值。该符号被推断为与该值具有相同的类型。将鼠标悬停在任何符号上以检查其类型。"

#: ../../tutorial/tour.md:91
msgid ""
"By default, the `let` - binding creates an immutable reference to a "
"value. That is, you cannot change the symbol to reference something else "
"without rebinding it (using `let`). Otherwise one should use `let mut`."
msgstr ""
"默认情况下，`let` - 绑定会创建一个不可变的引用到一个值。也就是说，您不能更改符号以引用其他内容而不重新绑定它（使用 "
"`let`）。否则，应该使用 `let mut`。"

#: ../../tutorial/tour.md:93
msgid "Function"
msgstr "函数"

#: ../../tutorial/tour.md:95
msgid ""
"Function is just a piece of code that takes some inputs and produce a "
"result. We may define a function using the keyword `fn` (function name in"
" MoonBit should not begin with uppercase letters A-Z):"
msgstr ""
"函数只是一段代码，它接受一些输入并产生一个结果。我们可以使用关键字 `fn` 定义一个函数（MoonBit 中的函数名不应以大写字母 A-Z "
"开头）："

#: ../../tutorial/tour.md:97
msgid ""
"fn identity[T](x : T) -> T {\n"
"  // `Identity` won't work as it violates naming convention\n"
"  x\n"
"}\n"
msgstr ""
"fn identity[T](x : T) -> T {\n"
"  // `Identity` 不符合命名规范\n"
"  x\n"
"}\n"

#: ../../tutorial/tour.md:104
msgid ""
"In this example, we provide types explicitly. Notice how it differs from "
"traditional C-like languages which uses prefix type notation `T x`, here "
"we use postfix type notation `x: T` (Formally, we call it _type "
"annotation_)."
msgstr ""
"在这个例子中，我们显式地提供了类型。请注意它与传统的类 C 语言的区别，传统的类 C 语言使用前缀类型表示法 `T "
"x`，而这里我们使用后缀类型表示法 `x: T`（正式地，我们称之为 _类型标注_）。"

#: ../../tutorial/tour.md:107
msgid ""
"We write a arrow `->` before the return type to show the nature of a "
"function: a map from some types to some other types. Formally, we call "
"this syntax _trailing return type_ (languages such as C++, Rust, Swift, "
"etc have this syntax as well)."
msgstr ""
"我们在返回类型之前写一个箭头 `->` 来显示函数的本质：从某些类型到某些其他类型的映射。正式地，我们称这种语法为 _尾随返回类型_ （诸如 "
"C++、Rust、Swift 等语言也有这种语法）。"

#: ../../tutorial/tour.md:109
msgid ""
"The word _expression_ is loosely used. Intuitively, An expression is "
"something with a value we care about."
msgstr "术语 _表达式_ 被宽泛地使用。直观地说，表达式是我们关心的具有值的东西。"

#: ../../tutorial/tour.md:111
msgid ""
"Consequently, a function type is denoted `(S) -> T` where `S` (within "
"parenthesis) is the parameter type and `T` is the return type. Functions "
"in MoonBit are first-class, meaning it's always possible to pass "
"functions around if you get the type right:"
msgstr ""
"因此，函数类型表示为 `(S) -> T`，其中 `S`（在括号内）是参数类型，`T` 是返回类型。MoonBit "
"中的函数是头等公民，这意味着如果您的类型正确，则始终可以传递函数："

#: ../../tutorial/tour.md:115
msgid ""
"fn compose[S, T, U](f : (T) -> U, g : (S) -> T) -> (S) -> U {\n"
"  let composition = fn(x : S) { f(g(x)) } // returns a composition of `f`"
" and `g`\n"
"\n"
"  // moonbit also provides the pipe `|>` operator,\n"
"  // similar to a lot of functional languages.\n"
"  fn(x : S) { g(x) |> f } // equivalent\n"
"}\n"
msgstr ""
"fn compose[S, T, U](f : (T) -> U, g : (S) -> T) -> (S) -> U {\n"
"  let composition = fn(x : S) { f(g(x)) } // 定义 `f` 和 `g` 的复合函数\n"
"\n"
"  // 和其他函数式语言类似\n"
"  // MoonBit 提供管道运算符 `|>`\n"
"  fn(x : S) { g(x) |> f } // 等价写法\n"
"}\n"

#: ../../tutorial/tour.md:125
msgid ""
"Languages nowadays have something called _lambda expression_. Most "
"languages implement it as a mere syntactic sugar. A lambda expression is "
"really just a anonymous closure, this, is resembled in our MoonBit's "
"syntax:"
msgstr ""
"现在的语言中有一种叫做 _lambda 表达式_ 的东西。大多数语言将其实现为一种纯粹的语法糖。lambda "
"表达式实际上只是一个匿名闭包，这在我们 MoonBit 的语法中体现为："

#: ../../tutorial/tour.md:127
msgid ""
"a closure only captures variables in its surroundings, together with its "
"bound variable, that is, having the same indentation level (suppose we've"
" formatted the code already)."
msgstr "闭包只捕获其周围的变量，以及其绑定变量，即具有相同缩进级别（假设我们已经格式化了代码）。"

#: ../../tutorial/tour.md:129
msgid ""
"fn foo() -> Int {\n"
"  fn inc(x) { x + 1 }  // named as `inc`\n"
"  (fn (x) { x + inc(2) })(6) // anonymous, a so-called 'lambda "
"expression'\n"
"  // function automatically captures the result of the last expression\n"
"}\n"
msgstr ""
"fn foo() -> Int {\n"
"  fn inc(x) { x + 1 }  // 命名为 `inc`\n"
"  (fn (x) { x + inc(2) })(6) // 匿名函数，即 lambda 表达式\n"
"  // 函数会自动捕捉最后一个表达式的值并返回\n"
"}\n"

#: ../../tutorial/tour.md:137
msgid "foo() // => 9\n"
msgstr ""

#: ../../tutorial/tour.md:141
msgid "Now we've learned the very basic, let's learn the rest by coding."
msgstr "现在我们已经学习了最基本的内容，让我们通过编码来学习其他内容。"

#: ../../tutorial/tour.md:143
msgid "Implementing List"
msgstr "实现列表"

#: ../../tutorial/tour.md:145
msgid "enum type"
msgstr "枚举类型"

#: ../../tutorial/tour.md:147
msgid ""
"A linked list is a series of node whose right cell is a reference to its "
"successor node. Sounds recursive? Because it is. Let's define it that way"
" using MoonBit:"
msgstr "链表是一系列节点，其右侧单元是对其后继节点的引用。听起来像是递归？因为它确实是。让我们使用 MoonBit 来定义它："

#: ../../tutorial/tour.md:149
msgid ""
"enum List[T] {\n"
"  Nil // base case: empty list\n"
"  Cons(T, List[T]) // an recursive definition\n"
"}\n"
msgstr ""
"enum List[T] {\n"
"  Nil // 基本情况：空表\n"
"  Cons(T, List[T]) // 递归定义\n"
"}\n"

#: ../../tutorial/tour.md:156
msgid ""
"The `enum` type works like any `enum` from traditional OO languages. "
"However, let's refrain from using the OO-term `case`, we'll use "
"_constructor_ from now on. We may read the above code as"
msgstr ""
"`enum` 类型的工作方式类似于传统面向对象语言中的任何 `enum`。但是，让我们避免使用面向对象术语 `case`，从现在开始我们将使用 "
"_构造器_。我们可以将上面的代码理解为："

#: ../../tutorial/tour.md:158
msgid ""
"the type `List[T]` can be constructed from the constructor `Nil` or "
"`Cons`, the former represents an empty list; the latter carries some data"
" of type `T` and the rest of the list."
msgstr "类型 `List[T]` 可以从构造器 `Nil` 或 `Cons` 构造，前者表示一个空列表；后者携带类型 `T` 的一些数据和列表的其余部分。"

#: ../../tutorial/tour.md:160
msgid ""
"The square bracket used here denotes a _polymorphic_ (generic) "
"definition, meaning a list of something of type `T`. Should we "
"_instantiate_ `T` with a concrete type like `Int`, we define a list "
"containing integers."
msgstr "这里使用的方括号表示 _多态_（泛型）定义，意味着一个类型为 `T` 的东西的列表。如果我们使用具体类型（如 `Int`）_实例化_ `T`，"

#: ../../tutorial/tour.md:162
msgid ""
"Another datatype frequently used in MoonBit is our good old `Struct`, "
"which works like you would expect. Let's create a list of `User` using "
"the definition above and `Struct`:"
msgstr ""
"在 MoonBit 中经常使用的另一种数据类型是我们熟悉的 `Struct`，它的工作方式与您期望的一样。让我们使用上面的定义和 `Struct`"
" 创建一个 `User` 列表："

#: ../../tutorial/tour.md:164
msgid ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  // by default the properties/fields of a struct is immutable.\n"
"  // the `mut` keyword works exactly the way we've mentioned before.\n"
"  mut email : String\n"
"} derive(Show)\n"
"\n"
"// a method of User is defined by passing a object of type User as self "
"first.\n"
"// just like what you would do in Python.\n"
"// Note that methods may only be defined within the same package the type"
" is in.\n"
"// We may not define methods for foreign types directly\n"
"fn greetUser(self : User) -> String { // a method of struct/type/class "
"`User`\n"
"  let id = self.id\n"
"  let name = self.name\n"
"  \"Greetings, \\{name} of id \\{id}\" // string interpolation\n"
"}\n"
"// construct a User object.\n"
"let evan : User = { id: 0, name: \"Evan\", email: \"someone@example.com\""
" }\n"
"// we use a shorthand by duplicating evan's information\n"
"// and replacing w/ someone elses' email.\n"
"let listOfUser : List[User] = Cons(evan, Cons({ ..evan, email: "
"\"someoneelse@example.com\" }, Nil))\n"
msgstr ""
"struct User {\n"
"  id : Int\n"
"  name : String\n"
"  // 默认情况下 Struct 的属性/字段是不可变的\n"
"  // `mut` 关键字就和我们之前说的一样\n"
"  mut email : String\n"
"} derive(Show)\n"
"\n"
"// 我们通过把函数第一个参数定义为 `self : User` 来给该Struct定义一个方法\n"
"// 写法和 Python 类似\n"
"// 注意：只有类型所在的包能为其定义方法。不能直接为外部类型定义方法。\n"
"fn greetUser(self : User) -> String { // `User`的一个方法\n"
"  let id = self.id\n"
"  let name = self.name\n"
"  \"Greetings, \\{name} of id \\{id}\" // 字符串插值写法\n"
"}\n"
"// 构造 User 对象\n"
"let evan : User = { id: 0, name: \"Evan\", email: \"someone@example.com\""
" }\n"
"// 可以用一个语法糖将 evan 的属性复制一遍\n"
"// 并将其 email 属性换成其他的值，构建一个新的对象\n"
"let listOfUser : List[User] = Cons(evan, Cons({ ..evan, email: "
"\"someoneelse@example.com\" }, Nil))\n"

#: ../../tutorial/tour.md:189
msgid ""
"Another datatype is `type`, a specific case of `enum` type. `type` can be"
" thought as a wrapper around an existing type, allowing additional "
"methods to be defined. Through this we extends the method definition of a"
" foreign type without actually modifying it. Consider the type of `name` "
"in `User`, we may define it as"
msgstr ""
"另一种数据类型是 `type`，是 `enum` 类型的特殊情况。`type` 可以被视为对现有类型的包装器，保留 `String` "
"的方法，但允许定义额外的方法。通过这种方式，我们可以扩展外部类型的方法定义，而无需实际修改它。考虑 `User` 中的 `name` "
"的类型，我们可以将其定义为："

#: ../../tutorial/tour.md:195
msgid ""
"type UserName String // a newtype `UserName` based on `String`\n"
"\n"
"// defining a method for UserName is allowed but not String.\n"
"fn is_blank(self : UserName) -> Bool {\n"
"  // use `._` to access its basetype String\n"
"  // iter() creates a *internal iterator*\n"
"  // which provides a functional way to iterate on sequences.\n"
"  // find_first short circuits on the first `true` i.e. non-blank "
"character\n"
"  let res = self._.iter().find_first(\n"
"    fn(c) { if c == ' ' { false } else { true } },\n"
"  )\n"
"  match res {\n"
"    Some(_) => false\n"
"    // found NO non-blank character, thus it's a blank string.\n"
"    None => true\n"
"  }\n"
"}\n"
msgstr ""
"type UserName String // 一个新类型 UserName，基于 String\n"
"\n"
"// 可以为 UserName 定义方法，String 则不行\n"
"fn is_blank(self : UserName) -> Bool {\n"
"  // 通过 `._` 访问其内部类型（String）\n"
"  // iter() 创建一个内部迭代器（internal iterator）\n"
"  // 并借此以函数式的风格在某个序列结构上迭代\n"
"  // find_first 遇到第一个 true（即非空字符）就短路\n"
"  let res = self._.iter().find_first(\n"
"    fn(c) { if c == ' ' { false } else { true } },\n"
"  )\n"
"  match res {\n"
"    Some(_) => false\n"
"    // 找不到非空字符，所以是只由空格组成的字符串\n"
"    None => true\n"
"  }\n"
"}\n"

#: ../../tutorial/tour.md:215
msgid ""
"`enum`, `struct` and `newtype` are the 3 ways to define a datatype. There"
" isn't `class` in MoonBit, nor does it need that."
msgstr "`enum`、`struct` 和 `newtype` 是定义数据类型的 3 种方式。MoonBit 中没有 `class`，也不需要。"

#: ../../tutorial/tour.md:218
msgid ""
"the `derive` keyword is like Java's `implements`. Here `Show` is a "
"_trait_ which indicates a type is printable. So what is a trait?"
msgstr ""
"`derive` 关键字类似于 Java 的 `implements`。这里的 `Show` 是一个 "
"_trait_，表示一个类型是可打印的。那么什么是 trait？"

#: ../../tutorial/tour.md:221
msgid "Trait"
msgstr "特征"

#: ../../tutorial/tour.md:223
msgid ""
"A trait (or type trait) is what we would call an `interface` in "
"traditional OO-languages. `println(evan)` would print `{id: 0, name: "
"\"Evan\", email: \"someone@example.com\"}`. As `User` consists of builtin"
" types `Int` `String`, which already implements `Show`. Therefore we do "
"not need to implement it explicitly. Let's implement our own trait "
"`Printable` by implementing `to_string()`:"
msgstr ""
"特征（或类型特征）是我们在传统面向对象语言中称为 `interface` 的东西。`println(evan)` 将打印 `{id: 0, "
"name: \"Evan\", email: \"someone@example.com\"}`。由于 `User` 由内置类型 `Int` "
"`String` 组成，这些类型已经实现了 `Show`。因此我们不需要显式实现它。让我们通过实现 `to_string()` "
"来实现我们自己的特征 `Printable`："

#: ../../tutorial/tour.md:229
msgid ""
"trait Printable {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"fn to_string(self : User) -> String {\n"
"  (self.id, self.name, self.email).to_string()\n"
"} // now `Printable` is implemented\n"
"\n"
"fn to_string[T : Printable](self : List[T]) -> String {\n"
"  let string_aux = to_string_aux(self)\n"
"  // function arguments can have label\n"
"  \"[\" + string_aux.substring(end=string_aux.length() - 1) + \"]\"\n"
"}\n"
"\n"
"// polymorphic functions have to be toplevel.\n"
"fn to_string_aux[T : Printable](self : List[T]) -> String {\n"
"  match self {\n"
"    Nil => \"\"\n"
"    Cons(x, xs) => \"\\{x} \" + to_string_aux(xs)\n"
"  }\n"
"}\n"
msgstr ""
"trait Printable {\n"
"  to_string(Self) -> String\n"
"}\n"
"\n"
"fn to_string(self : User) -> String {\n"
"  (self.id, self.name, self.email).to_string()\n"
"} // 这样就实现了`Printable`\n"
"\n"
"fn to_string[T : Printable](self : List[T]) -> String {\n"
"  let string_aux = to_string_aux(self)\n"
"  // 函数参数可以有标签\n"
"  \"[\" + string_aux.substring(end=string_aux.length() - 1) + \"]\"\n"
"}\n"
"\n"
"// 多态函数一定是顶层函数\n"
"fn to_string_aux[T : Printable](self : List[T]) -> String {\n"
"  match self {\n"
"    Nil => \"\"\n"
"    Cons(x, xs) => \"\\{x} \" + to_string_aux(xs)\n"
"  }\n"
"}\n"

#: ../../tutorial/tour.md:253
msgid ""
"listOfUser.to_string()\n"
"// => [(0, Evan, someone@example.com) (0, Evan, someoneelse@example.com)]"
"\n"
msgstr ""

#: ../../tutorial/tour.md:258
msgid ""
"We use `<T extends Printable>` in Java to constrain the type of list "
"element to make sure objects of type `T` can be printed, similarly, in "
"MoonBit we would write `[T: Printable]`."
msgstr ""
"我们在 Java 中使用 `<T extends Printable>` 来约束列表元素的类型，以确保类型为 `T` 的对象可以被打印，同样，在 "
"MoonBit 中我们会写 `[T: Printable]`。"

#: ../../tutorial/tour.md:261
msgid "Pattern Matching"
msgstr "模式匹配"

#: ../../tutorial/tour.md:263
msgid ""
"In the example above we use the `match` expression, a core feature of "
"MoonBit (and many other functional programming languages.) In short, we "
"use pattern matching to _destructure_ (to strip the encapsulation of) a "
"structure."
msgstr ""
"在上面的示例中，我们使用了 `match` 表达式，这是 MoonBit（以及许多其他函数式编程语言）的核心特性。简而言之，我们使用模式匹配来 "
"_解构_（剥离封装）一个结构。"

#: ../../tutorial/tour.md:267
msgid "We may express the above `match` code as"
msgstr "我们可以将上面的 `match` 代码表示为："

#: ../../tutorial/tour.md:269
msgid ""
"if `self` is constructed with `Nil` (an empty list), we return `\"\"`; "
"otherwise if `self` is constructed with `Cons(x,xs)` (a non-empty list) "
"we print `x` and rest of the list. Where `x` is the head of the `self` "
"and `xs` being the rest."
msgstr ""
"如果 `self` 是用 `Nil`（空列表）构造的，我们返回 `\"\"`；否则，如果 `self` 是用 "
"`Cons(x,xs)`（非空列表）构造的，我们打印 `x` 和列表的其余部分。其中 `x` 是 `self` 的头部，`xs` 是其余部分。"

#: ../../tutorial/tour.md:274
msgid ""
"Intuitively, we extract `x` and `xs` (they are bound in situ) from `self`"
" using pattern matching. Let's implement typical list operations such as "
"`map` `reduce` `zip`:"
msgstr ""
"直观地说，我们使用模式匹配从 `self` 中提取 `x` 和 `xs`（它们在原地绑定）。让我们实现典型的列表操作，如 `map` "
"`reduce` `zip`："

#: ../../tutorial/tour.md:277
msgid ""
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
"\n"
"fn zip[T](self : List[T], other : List[T]) -> List[T] {\n"
"  match (self, other) {\n"
"    (Nil, _) => Nil // we use underscore to ignore the value we don't "
"care\n"
"    (_, Nil) => Nil\n"
"    (Cons(x, xs), Cons(y, ys)) => Cons(x, Cons(y, zip(xs, ys)))\n"
"  }\n"
"}\n"
msgstr ""
"fn map[S, T](self : List[S], f : (S) -> T) -> List[T] {\n"
"  match self {\n"
"    Nil => Nil\n"
"    Cons(x, xs) => Cons(f(x), map(xs, f))\n"
"  }\n"
"}\n"
"\n"
"fn reduce[S, T](self : List[S], op : (T, S) -> T, init : T) -> T {\n"
"  match self {\n"
"    Nil => init\n"
"    Cons(x, xs) => reduce(xs, op, op(init, x))\n"
"  }\n"
"}\n"
"\n"
"fn zip[T](self : List[T], other : List[T]) -> List[T] {\n"
"  match (self, other) {\n"
"    (Nil, _) => Nil // 我们用下划线表示我们不关心的值\n"
"    (_, Nil) => Nil\n"
"    (Cons(x, xs), Cons(y, ys)) => Cons(x, Cons(y, zip(xs, ys)))\n"
"  }\n"
"}\n"

#: ../../tutorial/tour.md:301
msgid ""
"Now we have a somewhat usable `List` type. Realistically, we always "
"prefer the builtin `Array` which is much more efficient."
msgstr "现在我们有了一个可以使用的 `List` 类型。实际上，我们总是更喜欢内置的 `Array`，它更高效。"

#: ../../tutorial/tour.md:304
msgid ""
"Pattern matching can be used in `let` as well. In `greetUser()`, instead "
"of writing 2 `let`'s, we may write"
msgstr "模式匹配也可以在 `let` 中使用。在 `greetUser()` 中，我们可以把两个`let`绑定改写成："

#: ../../tutorial/tour.md:307
msgid ""
"fn greetUserAlt(self : User) -> String {\n"
"  // extract `id` `name` from `self` of type User. ignores email.\n"
"  let { id: id, name: name, email: _ } = self\n"
"  // equivalent, but ignores the rest.\n"
"  let { id, name, .. } = self\n"
"  \"Greetings, \\{name} of id \\{id}\"\n"
"}\n"
msgstr ""
"fn greetUserAlt(self : User) -> String {\n"
"  // 从 self 中提取 id name 字段，忽略 email\n"
"  let { id: id, name: name, email: _ } = self\n"
"  // 等价写法，但是忽略 id name 以外的所有字段\n"
"  let { id, name, .. } = self\n"
"  \"Greetings, \\{name} of id \\{id}\"\n"
"}\n"

#: ../../tutorial/tour.md:317
msgid "Iteration"
msgstr "迭代"

#: ../../tutorial/tour.md:319
msgid ""
"Finally, let's talk about the major point of every OO-language: looping. "
"Although we've been using recursion most of the times, MoonBit is "
"designed to be multi-paradigm, thus it retains C-style imperative `for` "
"`while` loop."
msgstr ""
"最后，让我们谈谈每种面向对象语言的主要特点：循环。尽管我们大多数时候都在使用递归，但 MoonBit 被设计为多范式，因此它保留了类 C "
"风格的命令式 `for` `while` 循环。"

#: ../../tutorial/tour.md:324
msgid ""
"Additionally, MoonBit provides a more interesting loop construct, the "
"functional loop. For example the Fibonacci number can be calculated by"
msgstr "此外，MoonBit 还提供了一个更有趣的循环结构，即函数式循环。例如，可以通过以下方式计算斐波那契数："

#: ../../tutorial/tour.md:327
msgid ""
"fn fib(n : Int) -> Int {\n"
"  loop n, 0, 1 { // introduces 3 loop variables: `n` `a = 0` `b = 1`\n"
"    // pattern matching is available in `loop`\n"
"    0, a, b => a // what can be constructed from 0 -- Only 0 it self!\n"
"    // assign `b` to `a`, `(a + b)` to `b`, decrease counter `n`\n"
"    n, a, b => continue n - 1, b, a + b\n"
"  }\n"
"}\n"
msgstr ""
"fn fib(n : Int) -> Int {\n"
"  loop n, 0, 1 { // 引入了三个循环变量 `n` `a = 0` `b = 1`\n"
"    // `loop` 中也可以使用模式匹配\n"
"    0, a, b => a // 只有 0 能从 0 构造出来\n"
"    // 将 `b` 赋值给 `a`, `(a + b)` 赋值给 `b`，循环计数器 `n - 1`\n"
"    n, a, b => continue n - 1, b, a + b\n"
"  }\n"
"}\n"

#: ../../tutorial/tour.md:338
msgid "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10].map(fib) // => [1,1,2,3,5,8,13,21,34,55]\n"
msgstr ""

#: ../../tutorial/tour.md:342
msgid ""
"Semantic-wise, the `loop` construct focuses more on the transition of "
"each state, providing better readability, preserving recursive flavor and"
" same performance without writing [tail-"
"recursion](https://en.wikipedia.org/wiki/Tail_call) explicitly."
msgstr ""
"从语义上讲，`loop` 结构更注重每个状态的转换，提供更好的可读性，保留递归风格，并在不显式编写 "
"[尾递归](https://baike.baidu.com/item/尾递归/554682) 的情况下保持相同的性能。"

#: ../../tutorial/tour.md:345
msgid "Closing"
msgstr "结束语"

#: ../../tutorial/tour.md:347
msgid ""
"At this point, we've learned about the very basic and most not-so-trivial"
" features of MoonBit, yet MoonBit is a feature-rich, multi-paradigm "
"programming language. After making sure that you are comfortable with the"
" basics of MoonBit, we suggest that you look into some [interesting "
"examples](https://github.com/moonbitlang/moonbit-"
"docs/tree/main/legacy/examples) to get a better hold of MoonBit."
msgstr ""
"到目前为止，我们已经了解了 MoonBit 的基本特性和一些不那么简单的特性，但 MoonBit 是一种功能丰富的多范式编程语言。在确保您对 "
"MoonBit 的基础知识感到满意后，我们建议您查看一些[有趣的示例](https://github.com/moonbitlang"
"/moonbit-docs/tree/main/legacy/examples) 以更好地掌握 MoonBit。"

#~ msgid "App(App(add, 33), square3)\n"
#~ msgstr ""

